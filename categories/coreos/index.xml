<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coreos on SOTA</title>
    <link>http://deeeet.com/categories/coreos/</link>
    <description>Recent content in Coreos on SOTA</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>Copyright (C) 2013-2015 Taichi Nakashima All Right Reserved.</copyright>
    <lastBuildDate>Wed, 26 Nov 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://deeeet.com/categories/coreos/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>CoreOSクラスタ内のDockerコンテナの動的リンク</title>
      <link>http://deeeet.com/writing/2014/11/26/coreos-etcd-docker-link/</link>
      <pubDate>Wed, 26 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/11/26/coreos-etcd-docker-link/</guid>
      <description>Dynamic Docker links with an ambassador powered by etcd
上記の記事を参考にCoreOSのクラスタ内で複数ホスト間にまたがりDockerコンテナを連携させる方法について検証した．
背景と問題 複数ホストにまたがりDockerのコンテナを接続する方法としてはAmbassador パターンが有名である．これはトラフィックを別ホストへforwardすることに特化したコンテナを立てる方法で，ホストに無駄な設定なし，かつDockerコンテナのみで行えるシンプルな方法である．例えば，あるホストからredis-cliを使って，別ホストで動くredisに接続する場合は以下のように接続する．
(redis-cli) --&amp;gt; (ambassador) ---network---&amp;gt; (ambassador) --&amp;gt; (redis)  redis-cliコンテナとambassadorコンテナ，redisコンテナとambassadorコンテナはdockerのlink機能で接続し，ambassadorコンテナはトラフィックをネットワーク越しにフォワードする．
この方法は，接続側がその相手先のホストを知っている必要がある．例えば上記の場合，redis-cliコンテナ側のambassadorコンテナは以下のように相手先のホストのIP（e.g., 192.168.1.52）を指定して起動しなければならない．
$ docker run -d --name ambassador --expose 6379 -e REDIS_PORT_6379_TCP=tcp://192.168.1.52:6379 svendowideit/ambassador  ホストが固定されている場合は問題ないが，CoreOSのように動的にホストが変わる可能性がある場合は問題になる．接続先のホスト情報を直接既述すると，ホストが変わる度に設定を更新する必要があり，かなり億劫な感じになる．
CoreOSにおける1つの解法 CoreOSはクラスタの形成に分散Key-Valueストアであるetcdを使っている．このetcdを使うと動的なambassadorパターンを作り上げることができる．つまり，以下のようなことをする．
 接続される側は接続情報をetcdに書き込み続けるコンテナを立てる 接続する側はその情報を読み込み続ける動的なambassadorコンテナを立てる  あとは，この動的なambassadorコンテナとlink接続すれば，相手先の情報を環境変数として取得するとができる．これで接続する側は接続相手のホスト情報を知らなくてもよくなる．
検証ストーリー これを実際にCoreOSクラスタを立てて検証してみる．
ここでは，Docker公式のドキュメント&amp;ldquo;Link via an Ambassador Container&amp;rdquo;と同様の例を用いる．クラスタ内のあるホストよりredis-cliコンテナを使って，別ホストのredisコンテナに接続するという状況を考える．
CoreOSクラスタを立てる 利用するCoreOSクラスタはtcnksm/vagrant-digitalocean-coreosを使って，VagrantでDigitalOcean上に立てる．
$ export NUM_INSTANCES=3 $ vagrant up --provider=digital_ocean  これで，DigitalOcean上に3つのCoreOSインスタンスが立ち上がる．
利用するコンテナ 全部で5つのコンテナを用いる．
https://coreos.com/assets/images/media/etcd-ambassador-hosts.png
HostA（redisを動かすホスト）では以下のコンテナを立てる．
 crosbymichael/redis - Ambassador パターンで使われているものと同様のRedisコンテナ polvi/simple-amb - socatコマンドを使って，特定のポートへのトラフィックを与えられたホストにforwardするだけのコンテナ．etcdへのフォーワードに利用する． polvi/docker-register - docker portコマンドを使って与えられたDockerコンテナのIPとPortを取得し，etcdにそれを登録するコンテナ  HostB（redis-cliを動かすホスト）では以下のコンテナを立てる．</description>
    </item>
    
    <item>
      <title>Fleetの使い方，Unitファイルの書き方</title>
      <link>http://deeeet.com/writing/2014/11/20/fleet/</link>
      <pubDate>Thu, 20 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/11/20/fleet/</guid>
      <description>CoreOSに入門した | SOTA
CoreOSではすべてのアプリケーションをDockerで動かす．このとき，コンテナによるサービスをCoreOSクラスタのどのマシンで起動するかをいちいち人手で決めるわけにはいけない．クラスタ内のリソースの状態や動いているサービスに基づき，適切なマシンでコンテナを動かすスケジューリングの仕組みが必要になる．
このスケジューリングとコンテナの管理にCoreOSはfleetを用いる． fleetを使うとCoreOSクラスタが1つのinit systemで動いているかのようにそれを扱うことができるようになる．開発者はどのマシンでどのDockerコンテナが動いているかを気にする必要がなくなる．
例えば，5つのコンテナを動かす必要があれば，fleetはクラスタのどこかでその5つのコンテナが動いてることを保証する．もしコンテナが動いているマシンに障害があっても，fleetはそのコンテナを別のマシンにスケジューリングしなおす（フェイルオーバー）．
スケジューリングは柔軟で，マシンのRegionやRoleによって振り分けることもできるし，同じサービスを同じマシンでは動かさないようにするといった設定もできる．例えば，複数のDBコンテナを別々のマシンに分散させるといったこともできる．
DigitalOceanの&amp;ldquo;Getting Started with CoreOS&amp;rdquo;シリーズの
 How To Use Fleet and Fleetctl to Manage your CoreOS Cluster How to Create Flexible Services for a CoreOS Cluster with Fleet Unit Files  において，fleetを操作するためのfleettclコマンドの使い方と，その設定ファイルであるUnitファイルの書き方を良い感じに解説していたので，それらを参考にfleetの使い方をまとめておく．
まずfleetの技術的概要をまとめる，次にfleetctlコマンドによるサービスの管理方法を書く．最後にUnitファイルの書き方について説明する．
fleetの技術的概要 fleetはクラスタレベルのsystemdと捉えることができる（単一マシンのinit systemがsystemdで，クラスタのinit systemがfleet）．
https://coreos.com/assets/images/media/fleet-schedule-diagram.png
fleetはengineとagentという大きく2つのコンポーネントから構成される．engineはジョブスケジューリングとクラスタサイズの変更を管理する．agentはマシンの代わりにジョブを引き受ける．Unitがクラスタに割り当てられると，agentはUnitファイルを読み込み，それを開始する．そして，systemdの状態をfleetに通知する．
バックエンドではetcdクラスタが動いており，engineとagentの協調に使われる．
fleetctlによるサービスの管理 fleetの設定ファイルは，systemdのunitファイルにfleet特有の設定（e.g., クラスタ内での分散方法など）を加えたものを利用する． このファイルの詳細は後述するとして，ここでは以下のようなHello Worldを出力しつづけるhello.serviceを利用する．
[Unit] Description=My Service After=docker.service [Service] TimeoutStartSec=0 ExecStartPre=-/usr/bin/docker kill hello ExecStartPre=-/usr/bin/docker rm hello ExecStartPre=/usr/bin/docker pull busybox ExecStart=/usr/bin/docker run --name hello busybox /bin/sh -c &amp;quot;while true; do echo Hello World; sleep 1; done&amp;quot; ExecStop=/usr/bin/docker stop hello  fleetによるサービス管理はfleetctlコマンドを使って行う．サービスの起動は以下の流れで行われる．</description>
    </item>
    
    <item>
      <title>CoreOSに入門した</title>
      <link>http://deeeet.com/writing/2014/11/17/coreos/</link>
      <pubDate>Mon, 17 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/11/17/coreos/</guid>
      <description>CoreOS is Linux for Massive Server Deployments · CoreOS
CoreOS + Docker Meetup Tokyo #1に参加してCoreOSにめっちゃ感動したので，CoreOSに入門していろいろ触ってみた．
まず，CoreOSの概要とそれを支える技術について説明する．次に実際にDigitalOcenan上にVagrantを使って実際にCoreOSクラスタを立てて，CoreOSで遊ぶ方法について書く．
CoreOSとは何か CoreOSは，GoogleやFacebook，Twitterといった企業が実現している柔軟かつスケーラブル，耐障害性の高いインフラの構築を目的としたLinuxディストリビューションである．軽量かつ使い捨てを前提にしており，クラウドなアーキテクチャのベストプラクティスを取り入れている．CoreOSの特徴は大きく4つ挙げられる．
 ミニマルなデザイン 容易かつ安全なOSアップデート Dockerコンテナによるアプリケーションの起動 クラスタリング  CoreOSはとてもミニマルである．従来のLinuxディストリビューションが機能を追加することでその価値を高めていったのに対して，CoreOSは必要最低限まで機能を削ぎ落としていることに価値がある（&amp;ldquo;CoreOS の調査：足し算から引き算へと，Linux ディストリビューションを再編する&amp;rdquo;）．
CoreOSは安全かつ容易なOSアップデート機構を持っている．これにはOmahaというChromeOSやChromeの更新に利用されているUpdate Engineを使っており，RootFSを丸ごと入れ替えることでアップデートを行う．これによりShellShockのような脆弱性が発見されても，いちいちパッチを当てるといったことやらずに済む．
CoreOSは専用のパッケージマネージャーをもたない．またRubyやPythonといった言語のRuntimeも持たない．全てのアプリケーションをDockerコンテナとして動作させる．これによりプロセスの隔離と，安全なマシンリソースの共有，アプリケーションのポータビリティという恩恵を受けることができる．
CoreOSはクラスタリングの機構を標準で持っている．クラスタリングについては，先週来日していたCoreOSのKelsey氏は&amp;rdquo;Datacenter as a Computer&amp;rdquo;という言葉を使っていた．データセンターの大量のサーバー群からクラスタを構築してまるでそれが1つのコンピュータとして扱えるようにすることをゴールとしているといった説明をしていた．
CoreOSはクラウドネイティブなOSである．Amazon EC2，DigitalOcean，Rackspace，OpenStack，QEMU/KVMといったあらゆるプラットフォームが対応を始めている．1つのクラスタを異なる2つのクラウドサーバにまたがって構築することもできるし，クラウドと自社のベアメタルサーバーを使って構築することもできる．
CoreOSの特徴については，@mopemopeさんの &amp;ldquo;CoreOS入門 - Qiita&amp;rdquo;や，@yungsangさんの&amp;ldquo;CoreOS とその関連技術に関するここ半年間の私の活動まとめ&amp;rdquo;が詳しい．
CoreOSを支える技術 CoreOSを支える技術キーワードを挙げるとすれば以下の3つになる．
 Docker etcd fleet  これらについてざっと説明する．
Docker CoreOSは専用のパッケージマネージャーをもたない．またRubyやPythonといった言語のRuntimeも持たない．全てのアプリケーションをDockerコンテナとして動作させる．
https://coreos.com/assets/images/media/Host-Diagram.png
Dockerを使うことで上図のようにコンテナによるプロセスの隔離と，安全なマシンリソースの共有，アプリケーションのポータビリティという恩恵を受けることができる．
etcd CoreOSは複数のマシンからクラスタを形成する．クラスタを形成するために，CoreOSはetcdという分散Key-Valuesストアを使い，各種設定をノード間で共有する（etcdってのは&amp;rdquo;/etc distributed&amp;rdquo;という意味）．
https://coreos.com/assets/images/media/Three-Tier-Webapp.png
etcdはクラスタのサービスディスカバリーとしても利用される．クラスタのメンバーの状態などを共有し，共有情報に基づき動的にアプリケーションの設定を行う．これらを行うetcdのコアはRaftのコンセンサスアルゴリズムである．Raftについては，&amp;ldquo;Raft - The Secret Lives of Data&amp;rdquo;を見るとビジュアルにその動作を見ることができる．
etcdはlocksmithというクラスタの再起動時のリブートマネジャーにも使われている．
fleet コンテナによるサービスをクラスタ内のどのマシンで起動するかをいちいち人手で決めるわけにはいけない．クラスタ内のリソースの状態や動いているサービスに基づき，適切なマシンでコンテナを動かすスケジューリングの仕組みが必要になる．
このスケジューリングとコンテナの管理にCoreOSはfleetを用いる．fleetはクラスタ全体のinit systemとして，クラスタのプロセス管理を行う．fleetはこれを各マシンのsystemdを束ねることでこれを実現している．fleetで管理するサービスはsystemdのUnitファイルを改良したものを用いる．</description>
    </item>
    
  </channel>
</rss>