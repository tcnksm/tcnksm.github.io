<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker Serf on SOTA</title>
    <link>https://deeeet.com/categories/docker-serf/</link>
    <description>Recent content in Docker Serf on SOTA</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>Copyright (C) 2013-2015 Taichi Nakashima All Right Reserved.</copyright>
    <lastBuildDate>Sun, 11 May 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://deeeet.com/categories/docker-serf/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>DockerのHost networking機能</title>
      <link>https://deeeet.com/writing/2014/05/11/docker-host-networking/</link>
      <pubDate>Sun, 11 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://deeeet.com/writing/2014/05/11/docker-host-networking/</guid>
      <description>DOCKER 0.11 IS THE RELEASE CANDIDATE FOR 1.0
1.0のRCである0.11はいくつかの新機能が追加された．例えば，SELinuxのサポートや，Host networking機能，Link機能でのホスト名，Docker deamonへのpingなど．
この中でもHost networking機能がなかなか面白いので，実際に手を動かして検証してみた．事前知識として&amp;ldquo;Dockerのネットワークの基礎&amp;rdquo;も書きました．ネットワークに関して不安があるひとが先にみると，Host Networing機能の利点／欠点もわかりやすいと思います．
TL;DR Host networking機能を使うと，異なるホスト間のコンテナの連携がちょっぴりやりやすくなる．SerfやConsulのようなサービスディスカバリーツールとの相性も良さそう．
まだ出たばかりの機能で実際に使ってるひとがいないので，あくまで個人の実感．HNのコメントで同様の発言は見かけた．
ネットワークモード コンテナを起動するとき，--netオプションで4つのネットワークモードを選択することができる．
 --net=bridge：仮想ブリッジdocker0に対して新しくネットワークスタックを作成する（default） --net=container:&amp;lt;コンテナ名|コンテナID&amp;gt;：他のコンテナのネットワークスタックを再利用する --net=host：ホストのネットワークスタックをコンテナ内で利用する --net=none：ネットワークスタックを作成しない  bridge ブリッジモードはデフォルトの挙動で，ループバックのloと仮想インターフェースのeth1がつくられる．eth1はホストのveth（Virtual Ethernet）とパイプされる．このモードは外部のネットワークとは隔離される．
$ docker run --net=bridge ubuntu ifconfig eth0 Link encap:Ethernet HWaddr 96:e7:26:24:69:55 inet addr:172.17.0.2 Bcast:0.0.0.0 Mask:255.255.0.0 lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0  container コンテナモードでは既に起動しているコンテナのネットワークスタックが再利用される．以下の場合だと，あらかじめ起動したhelloコンテナで作成したネットワークスタックがそのまま利用される．つまり，helloコンテナを起動したときにホスト側でつくられたvethと仮想インターフェースeth0のパイプがそのまま利用される．
$ docker run -d --name hello ubuntu /bin/sh -c &amp;quot;while true; do echo hello world; sleep 1; done&amp;quot; $ docker run --net=container:hello ubuntu ifconfig eth0 Link encap:Ethernet HWaddr b2:f4:26:c4:17:16 inet addr:172.</description>
    </item>
    
    <item>
      <title>Docker&#43;Serf&#43;HAproxy (&#43;Supervisor)</title>
      <link>https://deeeet.com/writing/2014/04/08/docker-serf-haproxy/</link>
      <pubDate>Tue, 08 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://deeeet.com/writing/2014/04/08/docker-serf-haproxy/</guid>
      <description>SerfでDockerコンテナのクラスタを形成する SerfでHAProxyの更新 on Vagrant  でやったことを融合した．つまり，HAProxy（ロードバランサ）コンテナとWebサーバコンテナを立てて，Serfでそれらのクラスタを形成する．そしてWebサーバコンテナの増減に応じてHAProxyコンテナの設定を書き換えるということをやってみた．
基本的には，上でやったことをDockerのコンテナに移行するだけだが，Dockerは1コンテナで1プロセスが普通であるため，複数プロセス（サービス）をどう扱うかが問題になる．
Dockerで複数プロセスを扱うときには，Supervisorという選択肢がある．この方法は，公式で紹介されていたり，Foot Fightの&amp;ldquo;Docker in Practice&amp;rdquo;で言及されてたり，CenturyLink Labsが試みていたりする．
ということで，SupervisordとSerf，HAproxyによるDockerコンテナのディスカバリをやってみた．
tcnksm/docker-serf-haproxy
準備 OSX+boot2dockerで行う．あらかじめboot2docker-vmのport forwardingの設定だけしておく．
$ boot2docker init $ VBoxManage modifyvm &amp;quot;boot2docker-vm&amp;quot; --natpf1 &amp;quot;tcp-port8080,tcp,,8080,,8080&amp;quot; $ boot2docker up  HAProxy+Serfコンテナ Dockerfileは以下．
FROM ubuntu # Install serf RUN apt-get install -y unzip wget RUN wget --no-check-certificat https://dl.bintray.com/mitchellh/serf/0.5.0_linux_amd64.zip -O serf.zip RUN unzip serf.zip RUN chmod +x serf RUN mv serf /usr/bin/serf # Install HAProxy RUN apt-get -y install haproxy RUN sed -i -e &#39;s/ENABLED=0/ENABLED=1/&#39; /etc/default/haproxy # Install supervisor RUN apt-get install -qy supervisor # Install basic packages for ruby RUN apt-get -y update RUN apt-get install -y build-essential git RUN apt-get install -y zlib1g-dev libssl-dev libreadline-dev libyaml-dev libxml2-dev libxslt-dev RUN apt-get clean # Install ruby-build RUN git clone https://github.</description>
    </item>
    
    <item>
      <title>SerfでDockerコンテナのクラスタを形成する</title>
      <link>https://deeeet.com/writing/2014/03/31/docker-serf/</link>
      <pubDate>Mon, 31 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://deeeet.com/writing/2014/03/31/docker-serf/</guid>
      <description>&amp;ldquo;Serf虎の巻&amp;rdquo;書いたし，Serf使っていろいろやってみるかということで，Dockerコンテナのクラスタ形成をやってみた．SerfとDockerの組み合わせについては，すでに[shiba_yu36]()さんが試みている（&amp;ldquo;serfとDockerでクラスタを組んでみる&amp;rdquo;）ので，もう少し踏み込んでクラスタへのjoinの仕方を模索してみた．
tcnksm/sample-docker-serf
やってみたのは，Dockerコンテナのみでのクラスタの形成．
準備 Vagrant上で実行する．Vagrantfileは以下．
$script1 = &amp;lt;&amp;lt;SCRIPT echo Installing depedencies... sudo apt-get install -y unzip echo Fetching Serf... cd /tmp/ wget https://dl.bintray.com/mitchellh/serf/0.5.0_linux_amd64.zip -O serf.zip echo Installing Serf... unzip serf.zip sudo chmod +x serf sudo mv serf /usr/bin/serf SCRIPT Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.box = &amp;quot;precise64&amp;quot; config.vm.box_url = &amp;quot;http://files.vagrantup.com/precise64.box&amp;quot; config.vm.provision &amp;quot;shell&amp;quot;, inline: $script1 config.vm.network &amp;quot;private_network&amp;quot;, ip: &amp;quot;172.20.20.10&amp;quot; config.vm.provision :docker do |d| d.pull_images &amp;quot;ubuntu&amp;quot; end end  VagrantからもSerfを使いたいので事前にプロビジョニングでインストールしておく．またDockerプロビジョニングも有効にしておく．
次に，Dockerfileは以下．Serfをインストールするだけ．
FROM ubuntu RUN apt-get -y install unzip wget RUN cd /tmp/ RUN wget --no-check-certificat https://dl.</description>
    </item>
    
  </channel>
</rss>