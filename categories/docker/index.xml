<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on SOTA</title>
    <link>http://deeeet.com/categories/docker/</link>
    <description>Recent content in Docker on SOTA</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>Copyright (C) 2013-2015 Taichi Nakashima All Right Reserved.</copyright>
    <lastBuildDate>Mon, 01 Dec 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://deeeet.com/categories/docker/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dockerコンテナ接続パターン (2014年冬)</title>
      <link>http://deeeet.com/writing/2014/12/01/docker-link-pattern/</link>
      <pubDate>Mon, 01 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/12/01/docker-link-pattern/</guid>
      <description>本記事はDocker Advent Calendar 2014の1日目の記事です．
Dockerによるコンテナ化はリソース隔離として素晴らしい技術である．しかし，通常は1つのコンテナに全ての機能を詰め込むようなことはしない．マイクロサービス的にコンテナごとに役割を分け，それらを接続し，協調させ，全体として1つのサービスを作り上げるのが通常の使い方になっている．
コンテナ同士の接続と言っても，シングルホスト内ではどうするのか，マルチホストになったときにどうするのかなど様々なパターンが考えられる．Dockerが注目された2014年だけでも，とても多くの手法や考え方が登場している．
僕の観測範囲で全てを追いきれているかは分からないが，現状見られるDockerコンテナの接続パターンを実例と共にまとめておく．
なお今回利用するコードは全て以下のレポジトリをcloneして自分で試せるようになっている．
 tcnksm/docker-link-pattern  概要 本記事では以下について説明する．
 link機能（シングルホスト） fig（シングルホスト） Ambassadorパターン（マルチホスト） 動的Ambassadorパターン（マルチホスト） weaveによる独自ネットワークの構築（マルチホスト） Kubernetes（マルチホスト）  事前知識 事前知識として，Dockerがそのネットワークをどのように制御しているかを知っていると良い．それに関しては以下で書いた．
 Dockerのネットワークの基礎 | SOTA  利用する状況 以下ではすべてのパターンを，同じ状況で説明する．redisコンテナ（crosbymichael/redis）を立て．それにresdis-cliコンテナ（relateiq/redis-cli）で接続するという状況を考える．
link機能（シングルホスト） まず，基礎．DockerはLinksというコンテナ同士の連携を簡単に行う仕組みを標準でもっている．これは，--link &amp;lt;連携したいコンテナ名&amp;gt;:&amp;lt;エイリアス名&amp;gt;オプションで新しいコンテナを起動すると，そのコンテナ内で連携したいコンテナのポート番号やIPを環境変数として利用できるという機能である．
今回の例でいうと，まず，redisという名前でredisコンテナを立てておく．
$ docker run -d --name redis crosbymichael/redis  これに接続するには，以下のようにする．
$ docker run -it --rm --link redis:redis relateiq/redis-cli redis 172.17.0.42:6379&amp;gt; ping PONG  relateiq/redis-cliコンテナの起動スクリプトは以下のようになっている．
# !/bin/bash if [ $# -eq 0 ]; then /redis/src/redis-cli -h $REDIS_PORT_6379_TCP_ADDR -p $REDIS_PORT_6379_TCP_PORT else /redis/src/redis-cli &amp;quot;$@&amp;quot; fi  引数なしで起動すると，relateiq/redis-cliは環境変数， $REDIS_PORT_6379_TCP_ADDRに接続しようとする．--link redis:redisでこれを起動することで，この環境変数が設定され，接続できる．</description>
    </item>
    
    <item>
      <title>DockerHub公式の言語StackをCentOSに移植した</title>
      <link>http://deeeet.com/writing/2014/11/04/dockerfile-centos/</link>
      <pubDate>Tue, 04 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/11/04/dockerfile-centos/</guid>
      <description>DockerHub公式の言語Stackが出て非常に便利になった．が，これらは全てdebianベースである．やんごとなき理由でCentOSを使わざるを得ないこともあるので，公式言語Stackの一部をCentOSに移植した．
とりあえず，ruby，rails，perl，node，javaを作成した．すべて公式の言語Stackをフォークして作成しているので，公式と同様の使い方ができる．また全てAutomated Buildしているので，DockerHubからインストールしてすぐに使える．
上の全てのイメージは，HerokuのStack的なイメージであるtcnksm/dockerfile-centos-buildpack-depsをベースにしている．もし他の言語のイメージを作成したい場合も，これをベースにすることができる．
ただ，どうしもイメージの容量は大きくなってしまった．その辺は注意してください&amp;hellip; またCentOSは慣れてないのでおかしなところがあればIssueかtwitterで指摘してください．</description>
    </item>
    
    <item>
      <title>boot2dockerでのVolume問題が解決しそう</title>
      <link>http://deeeet.com/writing/2014/10/08/boot2docker-guest-additions/</link>
      <pubDate>Wed, 08 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/10/08/boot2docker-guest-additions/</guid>
      <description>（追記）Docker 1.3がリリースされた．boot2dockerはデフォルトでVirtualBox Guest Additionsをサポートし，boot2docker-cliはinitのときにホストのディレクトリをboot2docker-vm上にマウントするようになった（Docker 1.3: signed images, process injection, security options, Mac shared directories | Docker Blog）．
TL;DR OSXやWindowsでboot2dockerを使う場合に特別な操作をしなくても-vオプション（Volume）が使えるようになる．
背景 OSXやWindowsでboot2dockerを使うひとが最も不満に感じるのは-vオプション（Volume）が使えないことだと思う．例えば，以下のようにカレントディレクトリをマウントし，そのファイルを参照しようとしてもファイルはないなどと言われる．
$ echo &#39;hello from OSX&#39; &amp;gt; hello $ docker run -v &amp;quot;$(pwd)&amp;quot;:/osx busybox cat /osx/hello cat: can&#39;t open &#39;/osx/hello&#39;: No such file or directory  boot2dockerを使う場合，Dockerデーモンはboot2docker-vm上で動き，OSXやWindowsから叩くdockerコマンドはそれに対するリモートクライアントとして動作する．Dockerはリモートクライアントからのvolumeをまだサポートしていないため，上記のコマンドはboot2docker-vm内のディレクトリをマウントする．よって，ローカルにあるファイルは発見されない．
現時点でそれを解決するには，OSXやwindowsのディレクトリをboot2docker内にマウントするしかない．しかし，boot2dockerはVirtualBox Guest Additionsをサポートしていないため，独自スクリプトでisoイメージを1から作るか，他人がつくった非公式のisoを使うしかなかった（誰もが一度はググっていろいろ回った結果VBox guest additions #284にたどりついては面倒くせえと思っていたと思う）．
VirtualBox Guest Additionsをサポートが進まなかったのは，boot2dockerのシンプルさが失われること，またパフォーマンスへの危惧が大きい．
どうなるのか まず，そもそもDocker自体がリモートクライアントからのvolumeに対応しようとしている（FUSEが検討されている）．が，まだ議論が進んでいる．
 Proposal: Remote Shared Volumes #7249  その間の穴埋めをboot2dockerがすることになった．理由として，OSXやWindowsでDockerを使う場合には公式的にboot2dockerを使うことになっている以上，-vオプション（Volume）を使えないのはユーザビリティに影響があるため．
 VirtualBox Guest Additions #534 Add VirtualBox shared folders creation #258  上記のPull Requestにより，boot2docker-vmにはVirtualbox Guest Additionsがデフォルトでインストールされるようになった．かつ，boot2docker-cliはinitの際に，OSXの場合は/UsersをWindowsの場合は，/c/Usersを自動でマウントするようになった（オプションで無効にすることもできる）．</description>
    </item>
    
    <item>
      <title>認証付きのDocker Private registryを立てる</title>
      <link>http://deeeet.com/writing/2014/10/02/docker-private-registry-auth/</link>
      <pubDate>Thu, 02 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/10/02/docker-private-registry-auth/</guid>
      <description>DockerHub（Public registry）を使えない場合は，Private Registryを立てる必要がある．DockerはPrivate registry用のDockerイメージを提供しているため，コンテナを立てるだけですぐに使い始めることができる．
$ docker run -p 5000:5000 registry $ docker push docker-private.com:5000/test-image:latest  ただ，これだとURLを知っていれば誰でも好きにイメージをpushできてしまうので，認証を行う必要がある．認証には，Dockerクライアント（docker login）が対応しているBasic認証を利用する．Docker registryには認証機構がないため，nginxやApacheをリバースプロキシとして配置して，Basic認証を行う．
このとき，（当たり前だが）以下の2つの制限がある．
 DockerクライアントのBasic認証はSSLが必須である Dockerクライアントは証明書の正当性をちゃんとチェックする（無視できない）  気軽さを求めて自己署名証明書を使うと，いくつか面倒な部分があるのでまとめておく．環境としては，サーバーをUbuntu，リバースプロキシをnginx，クライアントをOSX+boot2dockerとする．
サーバー側の設定 サーバー側では以下の3つの設定を行う．
 nginxの設定 認証するユーザのパスワードの設定 自己署名証明書の作成  nginxの設定 リバースプロキシにはnginxを用いる．Docker registryはBasic認証を行うためのnginxの設定例を提供している（docker-registry/contrib/nginx）ので，それをそのまま利用する．
$ git clone https://github.com/docker/docker-registry $ cp docker-registry/contrib/nginx/nginx_1-3-9.conf /etc/nginx/conf.d/. $ cp docker-registry/contrib/nginx/docker-registry.conf /etc/nginx/.  パスワードの設定 Docker Registryを利用するユーザの設定を行う（apache2-utilsパッケージを利用する）．
$ htpasswd -bc /etc/nginx/docker-registry.htpasswd USERNAME PASSWORD  自己署名証明書の作成 自己署名（オレオレ）証明書を作る．まず，CAの秘密鍵と公開鍵を作成しておく．
$ echo 01 &amp;gt; ca.srl $ openssl genrsa -des3 -out ca-key.</description>
    </item>
    
    <item>
      <title>DockerHub公式の言語Stack</title>
      <link>http://deeeet.com/writing/2014/09/25/dockerhub-official-language-stacks/</link>
      <pubDate>Thu, 25 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/09/25/dockerhub-official-language-stacks/</guid>
      <description>DockerHub Official Repos: Announcing Language Stacks | Docker Blog
DockerHubには公式のレポジトリがある．そこにはUbuntuやCentos，MySQLやPostgres，MongoといったDockerイメージがコミュニティーベースで，つまりより汎用的に使える形で開発され集められており，ベースイメージとして簡単に使えるようになっている．
今までは，OSのディストリビューションや，Webサーバ，DBなどがメインだったが，公式として各種プログラミング言語のベースイメージも公開された．現状（2014年9月時点）では，c/c++(gcc)，clojure，golang，hylang，java，node，perl，PHP，python，rails，rubyがある．
特徴 この公式の言語stackには以下の3つの特徴がある．
 buildpack-depsイメージをベースにしている 各Versionをサポートしている ONBUILDをイメージもサポートしている  これらを簡単に説明する．
Buildpack-deps buildpack-depsイメージというのは，HerokuのStackのようなイメージで，各言語を動かすために必要な基本的な依存関係等がインストールされている．
Dockerfileは以下．
FROM debian:wheezy RUN apt-get update &amp;amp;&amp;amp; apt-get install -y \ autoconf \ build-essential \ imagemagick \ libbz2-dev \ libcurl4-openssl-dev \ libevent-dev \ libffi-dev \ libglib2.0-dev \ libjpeg-dev \ libmagickcore-dev \ libmagickwand-dev \ libmysqlclient-dev \ libncurses-dev \ libpq-dev \ libpq-dev \ libreadline-dev \ libsqlite3-dev \ libssl-dev \ libxml2-dev \ libxslt-dev \ libyaml-dev \ zlib1g-dev \ &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* RUN apt-get update &amp;amp;&amp;amp; apt-get install -y \ bzr \ cvs \ git \ mercurial \ subversion \ &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*  よく言語をインストールする際に依存で入れるべきものが揃っている．これを元に各言語スタックは作成されるので，これらの依存のインストールし忘れなどを防ぐことができる．</description>
    </item>
    
    <item>
      <title>Dockerの再起動オプション</title>
      <link>http://deeeet.com/writing/2014/09/17/docker-1-2-restart/</link>
      <pubDate>Wed, 17 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/09/17/docker-1-2-restart/</guid>
      <description>Announcing Docker 1.2.0 | Docker Blog
v1.2でもいくつかの面白い機能が追加された．例えば，今まで--privilegedオプションを使うと全権限を与えてしまっていたが--cap-addや--cap-dropオプションでそれを制限できるようになったり，–deviceオプションで利用したいデバイスを指定できたり，コンテナ起動時に/etc/hostsを編集できたり&amp;hellip;など．
中でも再起動オプションが良さげなので，実際に触ってみた．docker runを実行するときに--restartオプションに以下を指定するとコンテナの再起動の挙動を変更できる:
 no - 再起動しない（デフォルト） on-failure - 終了ステータスがnon-zeroの場合に再起動する on-failure:X - 終了ステータスがnon-zeroの場合にX回だけ再起動する always - 終了ステータスがなんであろうと再起動する  no これはデフォルトの挙動で，再起動は行わない．
$ docker run --restart=no busybox /bin/sh -c &#39;date; exit 1&#39; Wed Sep 17 08:13:15 UTC 2014  $ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e3389974b4ef busybox:latest &amp;quot;/bin/sh -c &#39;date; e 5 seconds ago Exited (1) 4 seconds ago jolly_hoover  on-failure これは終了ステータスがnon-zeroの場合に再起動し続ける．</description>
    </item>
    
    <item>
      <title>Dockerコンテナのおもしろい名前</title>
      <link>http://deeeet.com/writing/2014/07/15/docker-container-name/</link>
      <pubDate>Tue, 15 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/07/15/docker-container-name/</guid>
      <description>Dockerコンテナを立ち上げるときに，--nameオプションで名前を指定しないと勝手に名前がつけられる．
$ docker run -d dockerfile/nginx  $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1f29f753eaf6 dockerfile/nginx:latest nginx 2 days ago Up 11 hours 80/tcp, 443/tcp elegant_feynma  例えば，上ではelegant_feynmaという名前がつけられている．
で，これどうやってやってるのかなーと思ってソースを眺めていると，docker/pkg/namesgeneratorというパッケージが名前を生成していた．
名前の生成方法はとても単純で，49個の形容詞と68名の著名な科学者もしくはハッカーの名前をランダムに組み合せているだけ．ソースを見ると，科学者もしくはハッカーの名前と簡単な紹介文，wikipediaへのリンクがコメントに書かれている．
以下が，生成部分の実装．注意深くみると，異変に気づく．
func GetRandomName(retry int) string { rand.Seed(time.Now().UnixNano()) begin: name := fmt.Sprintf(&amp;quot;%s_%s&amp;quot;, left[rand.Intn(len(left))], right[rand.Intn(len(right))]) if name == &amp;quot;boring_wozniak&amp;quot; /* Steve Wozniak is not boring */ { goto begin } if retry &amp;gt; 0 { name = fmt.</description>
    </item>
    
    <item>
      <title>libswarmの現状と将来</title>
      <link>http://deeeet.com/writing/2014/07/14/libswarm/</link>
      <pubDate>Mon, 14 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/07/14/libswarm/</guid>
      <description>DockerCon14で新たに発表されたDockerによる新しいOSSであるlibswarmをざっと触ってみたので，現状何ができて，将来的にどういったことができそうになるかを簡単にまとめておく．
TL;DR libswarmを使うと複数ホストやサービス（自社サーバー，DigitalOcean，Amazon EC2，Orchardなど）に存在するDockerコンテナを，１つのホストに存在しているかのように扱うことができるようになる．Dockerがホストを抽象化したのに対して，libswarmは複数ホストを抽象化する．
libswarmを使ったswarmdコマンドを使って，UNIXのパイプのように複数ホストやサービスを連鎖的につなげる．
デモ libswarmで何ができるのかは，DockerCon14でのデモ動画&amp;ldquo;Orchard + libswarm demo from DockerCon&amp;rdquo;を観るのが一番わかりやすい．
ここでは，異なるホスト（ローカルホストとDigitalOcean，Orchard）に対して，swarmdを立ち上げるだけで，それらに個別にログインすることなく，同様のコマンドを発行してaanand/hello-worldコンテナを立ち上げ，かつそれら全てのコンテナの情報を一気に取得している様子が観られる．
libswarmの動作 libswarmのプロジェクトをみると，backendsというディレクトリがある．ここに，様々ななバックエンドサービス，例えば標準的なDocker server/clientやAmazon EC2，Orchardなど，が定義されており，libswarmはこれらのサービスの間の情報のやりとりを受け持つ．
例えば，一番単純なコマンドは以下のようになる．
$ swarmd &#39;dockerserver unix:///var/run/docker.sock&#39; &#39;dockerclient tcp://192.168.59.103:2375&#39;  これを立ち上げたまま，ローカルでDockerコマンドを実行すると，
 クライアントによるHTTPリクエストをdockerserverが受ける dockerserverはリクエストをdockerclientにフォワードする 193.168.59.103のDockerデーモンでコマンドが実行される  この動作は以下の図がわかりやすい．
Libswarm (in a nutshell) | Tech&amp;rsquo;d
上の例は最小限で感動はない．libswarmがすごいのは，例えばdockerclientバックエンドをorchardバックエンドに変えればorchardにコマンドが発行されるし，EC2バックエンドに変えればEC2にコマンドが発行されるところ．さらに，複数のバックエンドサービスを束ねて同時にそれらを扱えるところ．
デモの再現 とりあえず，DockerCon14のデモをOSX上で再現してみる．まず，インストールは以下．Goがインストールされている必要がある．
$ go get github.com/docker/libswarm/... $ go install github.com/docker/libswarm/swarmd  dockerclient まず，dockerclientにboot2dockerを指定してみる．
$ swarmd &#39;dockerserver tcp://localhost:4567&#39; &#39;debug&#39; &amp;quot;dockerclient tcp://:2375&amp;quot;  別のウィンドウを立ち上げて，DOCKER_HOSTをdockerserverで指定した値にして，コマンドを発行する．
$ export DOCKER_HOST=tcp://:4567 $ docker run -d -p 80:80 dockerfile/nginx  すると，nginxコンテナが立ち上がる．</description>
    </item>
    
    <item>
      <title>DockerによるマルチホストのPaaS flynnの概要とそのアーキテクチャー</title>
      <link>http://deeeet.com/writing/2014/07/07/flynn/</link>
      <pubDate>Mon, 07 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/07/07/flynn/</guid>
      <description>&amp;ldquo;flynnの時代&amp;rdquo;
&amp;ldquo;Docker meetup tokyo #3&amp;rdquo;で発表してきた．内容は，Dockerの応用の１つであるOSSでPaaSをつくるflynnというプロジェクトの概要とそのアーキテクチャーの紹介．このflynnというプロジェクトの中には，Dockerの面白い使い方がたくさん詰まってるため，今後Dockerを使う人が，その応用の際の参考になればという思いで紹介させてもらった．
今回の発表のために資料を集めまくり，理解できない部分は出来る限りコードも読んだ．発表スライドの補完にもなると思うので，そのメモ書き（一応体裁は整えた）を公開しておく．
デモ 以下は，簡単なデモ．
やっていることは以下．
 nodeのアプリケーションをデプロイ ルーティングの追加 スケール  コマンドを含めた詳しい解説は以下で解説する．
前提知識 (Herokuの動作) まず，前提知識としてPaaS (ここではHeroku) がどのように動作しているのかをそのワークフローとともにまとめておく．
$ heroku create   Stackと呼ばれるベースとなるOSを準備する  e.g., Cedar stack   $ git push heroku master   アプリケーションがデプロイされる slug compilerでアプリケーションをビルドしてslugを作成する  slug compiler  各言語のBuildpackの集合 依存関係のインストール  e.g., RubyならGemfileをもとにrubygemsをインストール   slug  ソースと依存ライブラリ，言語のランタイムを含んだ圧縮されたファイルシステム(SquashFS)   アプリケーションの実行環境（Dyno）を準備する  Dyno  LXCをベースにしたContainer環境   Dynoにslugをロードする Procfileをもとにアプリケーションを起動する  Procfile  プロセスの起動コマンドを記述  e.</description>
    </item>
    
    <item>
      <title>flynnの時代</title>
      <link>http://deeeet.com/talking/2014/07/07/docker-meetup-3/</link>
      <pubDate>Mon, 07 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/talking/2014/07/07/docker-meetup-3/</guid>
      <description>Docker meetup tokyo #3
内容は，Dockerの応用の１つであるOSSでPaaSをつくるflynnというプロジェクトの概要とそのアーキテクチャーの紹介．FlynnのアーキテクチャやDockerの使いかたは非常に面白く，これからDockerを使うときに参考になると思い発表した．
参考  &amp;ldquo;Flynn - Open source Platform as a Service powered by Docker&amp;rdquo; &amp;ldquo;The Start of the Age of Flynn&amp;rdquo; &amp;ldquo;Unveiling Flynn, a new PAAS based on Docker&amp;rdquo; &amp;ldquo;5by5 | The Changelog #99: Flynn, Tent, open source PaaSes and more with Jeff Lindsay and Jonathan Rudenberg&amp;rdquo; &amp;ldquo;5by5 | The Changelog #115: Flynn updates with Jonathan Rudenberg and Jeff Lindsay&amp;rdquo; &amp;ldquo;Container Independence&amp;rdquo; &amp;ldquo;Bazooka: Continuous Deployment at SoundCloud - Google Slides&amp;rdquo; &amp;ldquo;Deis: Evolution of a Docker PAAS&amp;rdquo; &amp;ldquo;Flynn vs.</description>
    </item>
    
    <item>
      <title>Proxy環境下でDockerを動かす</title>
      <link>http://deeeet.com/writing/2014/07/01/docker-behind-proxy/</link>
      <pubDate>Tue, 01 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/07/01/docker-behind-proxy/</guid>
      <description>Docker1.0がリリースされたことで，プロダクションレディ感もあり，企業でもDockerを使う機運が高まっている．でも，実際はまだまだ本番環境ではなく，テスト環境などで使われることが多い．
Dockerによるテスト環境構築でまず思い浮かぶのはdokku．dokkuはDockerを使ったbash実装のPaaS．プライベートPaaSを持たない，かつHerokuなどを気軽に使えない企業のテスト環境として今後使われる機会がありそう．
ただ，個人での利用とは違い企業などでDockerやdokkuを使う場合は，Proxyに阻まれることがある（というか今日阻まれた）．ので，Proxy環境下でのDocker，dokkuの使い方を簡単にまとめておく．まず，Docker全般に関して，次にdokku特有の問題についてProxyの問題を解決しなければならない状況とその解決方法を説明する．
Proxy環境下でのDocker Dockerを使う中で，外部ネットワークとのやりとりが必要になるのは，以下の3つの場合が考えられる．
 DockerHub（Docker Index）とのやりとり Dockerfile Dockerコンテナ  これらの解決方法をそれぞれ説明する．
DockerHub（Docker Index） まずは，DockerHub（Docker Index）とのやりとりを行う場合．例えば，docker pullなどでイメージを取得する場合など．
この場合は，dockerデーモンを起動する際にhttp_proxy環境変数を設定すればよい．例えば，Ubuntuの場合は，Upstartの設定ファイル/etc/default/dockerにexport http_proxy=&amp;lt;HTTP_PROXY&amp;gt;を記述すればよい．
Dockerfile 次に，Dockerfileで外部ネットワークとやりとりを行う場合．例えば，apt-getなどでパッケージをインストールする場合など．
この場合は，ENVコマンドを使ってDockerfile内で環境変数を設定すればよい．
FROM ubuntu:13.10 ENV http_proxy &amp;lt;HTTP_PROXY&amp;gt; ENV https_proxy &amp;lt;HTTPS_PROXY&amp;gt; RUN apt-get -y update  Dockerコンテナ 最後は，docker runでコンテナを起動した後に，コンテナ内から外部ネットワークとやりとりをする場合．例えば，サードパーティー製のDockerイメージをそのまま使う場合など．
この場合は，-eオプションを使ってhttp_proxy環境変数を設定してコンテナを起動すればよい．
$ docker run -d \ -e &amp;quot;http_proxy=&amp;lt;HTTP_PROXY&amp;gt;&amp;quot; \ progrium/buildstep /build/builder  Proxy環境下でのdokku dokkuのインストール以外で，dokkuが外部ネットワークとやりとりするのは以下の2カ所．
 dokku専用のDockerイメージprogrium/buildstepのpull Buildpackを使ったアプリケーションのビルド  1つ目は上記のDockerHubとのやりとりで示した方法で解決できる．2つ目は若干のハックが必要になる．
dokkuはHerokuと同様にアプリケーションのビルドにBuildpackを使用し，依存パッケージ等のインストールを行う．このビルドは，dokku専用のDockerイメージprogrium/buildstepを使い，そのコンテナ内で実行される．よって，そのときにProxyが設定されている必要がある．これは上記のDockerコンテナで示した方法で解決できる．
dokkuは，bash実装なので，/usr/local/bin/dokkuを直接編集してしまえばよい．編集するのは，build/builderコマンドと共にコンテナを起動するところ．そこで-eオプションを使って環境変数を設定すればよい．
具体的には，
id=$(docker run -d -v $CACHE_DIR:/cache $IMAGE /build/builder)  を以下のようにする．</description>
    </item>
    
    <item>
      <title>カーネル読書会 #111でLTしてきた&#43;Dockerによる次世代のPaaS</title>
      <link>http://deeeet.com/writing/2014/05/30/ylug-111/</link>
      <pubDate>Fri, 30 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/05/30/ylug-111/</guid>
      <description> &amp;ldquo;DockerでPaaSをつくる #ylug_111&amp;rdquo;
@hyoshiokさんにカーネル読書会でLTをする機会をいただいた．内容はDockerの応用の１つでOSSのPaaSをつくるというもの．Herokuの内部実装を説明しつつ，Dockerによりいかに簡単にPaaSを作れるようになったかを話した．
最後にちょっと話した，次世代のPaaSもしくはHeroku++を目指すFlynnは，野心的ですごく面白い．簡単にいうとFlynnはHerokuの簡便さとAmazon EC2のような自由度を兼ね備えたPaaSを目指している．Flynnは以下の2つのレイヤーで構成される．
 layer0：CoreOSのetcdによるサービスディスカバリー層 layor1：Herokuのようなアプリケーションのデプロイ+管理層  このプロジェクトにはdokkuの作者である@progriumさんも関わっている．dokkuは単にProof of conceptで，実際にこの辺のコミュニティが目指してるのはFlynnのような次世代のPaaSなんだろうなと思う（詳しくは&amp;ldquo;The Start of the Age of Flynn&amp;rdquo;を参考）．
Flynnについては最近いろいろ調べたりしているので，そのうちちゃんとまとめたい．とりあえず，参考文献だけ載せる．
 PaaSに何が起きているのか？ The Start of the Age of Flynn Flynn vs. Deis: The Tale of Two Docker Micro-PaaS Technologies | CenturyLink Labs Welcome to Flynn 5by5 | The Changelog #99: Flynn, Tent, open source PaaSes and more with Jeff Lindsay and Jonathan Rudenberg 5by5 | The Changelog #115: Flynn updates with Jonathan Rudenberg and Jeff Lindsay  </description>
    </item>
    
    <item>
      <title>Heroku Meetup #12でLTしてきた&#43;Heroku on Docker</title>
      <link>http://deeeet.com/writing/2014/05/23/heroku-meetup-12/</link>
      <pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/05/23/heroku-meetup-12/</guid>
      <description>&amp;ldquo;Go Web ApplicationをHerokuにデプロイ + Heroku on Docker #herokujp&amp;rdquo;
Heroku Meetup #12でLTをしてきた．MartiniをつかったGo Web ApplicationをHerokuにぶっ込んでみたという内容で，基本は&amp;ldquo;Martini(+Ginkgo)をWerckerでCIしてHerokuにデプロイ&amp;rdquo;が基になっている．
せっかく最近Dockerを使っているので，HerokuとDockerを絡めた話がしたいなと思い，&amp;ldquo;building&amp;rdquo;を使ってDocker Container上にHerokuと同じ環境を作るという話を追加した．以下はその補足．
Heroku on Docker Heroku on Docker | CenturyLink Labs
CenturyLink Labsが開発した&amp;ldquo;building&amp;rdquo;というツールを使えば，Herokuのbuildpackを使うアプケーション用のコンテナを簡単に立ち上げることができる．つまり，ローカルで気軽にHerokuと同様の環境をつくることができる．
似たようなツールに&amp;ldquo;dokku&amp;rdquo;というツールがある．dokkuはbuildpackとDockerを使ってmini Herokuを作ることができるツール．dokkuを立てたサーバに対してアプリケーションをgit pushすると，新しくDockerコンテナが起動し，アプリケーションのビルドが行われる（&amp;ldquo;Inside Dokku in 5 minutes&amp;rdquo;が詳しい）．
buildingは，dokkuをシンプルにしたツール．カレントディレクトリのアプリケーションをdokkuのbuildstepというスクリプトを使ってビルドしたDockerイメージをつくり，それを使ってコンテナを立ち上げるということをやってくれる．dokkuのようにサーバを立ててssh鍵を通すといった設定なしで使える．
buildingはdokkuをカジュアルに使えるようにしたツールであると言える．
buildingの使いどころ 以下のような場合に使える．
 ローカルにHerokuと同じ環境をつくりたい Cleanな環境でHerokuアプリケーションをビルドしたい buildpackのテストをしたい  buildingはHeroku同様にThird partyのbuildpackの追加も可能なので，それがちゃんと動作するかをテストすることもできる．
buildingを動かす まず，インストール．Rubygemsとして配布されている．
$ gem install building  あとは，動かしたHerokuアプリケーション（Rails，Node，HHVM，WordPress，Go）のディレクトリ内で以下を実行するだけ．
$ building -p 3000 tcnksm/app  -pで解放したいポート番号を指定する．tcnksm/appは作成したいDockerイメージ名．
これだけで，
 専用のDockerfileの作成 イメージのビルド コンテナの起動  をやってくれ，ローカルにHerokuと同じ環境でアプリケーションが立ち上がる．
buildingの動作 buildingがつくるDockerfileは以下のような感じ．</description>
    </item>
    
    <item>
      <title>logspoutでDockerコンテナのログの集約・ルーティング</title>
      <link>http://deeeet.com/writing/2014/05/14/logspout/</link>
      <pubDate>Wed, 14 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/05/14/logspout/</guid>
      <description>progrium/logspout
logspoutは，ホスト内で動かした全てのDockerコンテナの出力を集約して，好きなところに飛ばす（ルーティングする）ためのツール．開発者はDokkのJeff Lindsay．
以下の2つの特徴がある
 コンテナとして起動（ステートレス） HTTP APIによるルーティングの設定  ログを貯めて管理したり，検索するといったことはできない．コンテナのログをリアルタイムで好きなところに飛ばすだけ．
これだけだが，Dockerのログの問題をいい感じに解決してくれそう．
Dockerのログのしくみ まず，簡単にDockerのログのしくみを説明する．
現時点（2014年5月）でDockerはコンテナ内で吐き出されたstdout/stderrを取得することができる．コンテナのプロセスがstdoutとstderrにログを吐き出し，Dockerはそれをホストにjsonとして保存する．docker logコマンドを使うとそれを取得することができる．
これはシンプルだけど欠点でもある．いずれディスクが圧迫されるし，毎回docker logを叩くわけにもいかない．そのため，Dockerのログをどうするかってのはいろいろ試みられている．
Dockerのログ収集の試み Dockerコンテナのログ収集の試みは，大きく分けて3つある．
 コンテナの内部で収集する：コンテナ内でログ収集のプロセスを同時に走らせる（&amp;ldquo;dockerなら5分で動く！ nginxのログをfluentdで集めてnorikraでストリーム分析&amp;rdquo;，&amp;ldquo;How To Run Rsyslog in a Docker Container for Logging&amp;rdquo;） コンテナの外部で収集する：ホスト側でログ収集のエージェントを走らせて，コンテナのログの書き出し先をホストからマウントする，もしくはjsonを直接読む（&amp;ldquo;Docker Log Management Using Fluentd&amp;rdquo;） 収集および配信用のコンテナを立てる：logstash-forwarderのようなログの収集および配信を担うエージェントをコンテナ内に立てる．そして各コンテナが起動の際に--volumes-fromでそのコンテナを指定する（&amp;ldquo;Docker And Logstash: Smarter Log management For Your Containers&amp;rdquo;）  やりようはいろいろあるが，少なくともDocker的に良いのは，
 コンテナに複数プロセスを立てない　 ホストに多くを設定しない  これを満たすのは，3番目の専用のコンテナを立てる方式．ただ，現状の方法は立てるコンテナごとに--volumes-fromを駆使しなといけないなど，少しめんどくさい．
logsoutの良い点 専用のコンテナ（progrium/logspout）を立てるだけ使える．
つまり，現状動いている他のコンテナになんの設定もなしに使える．当然，ホスト側に特別な設定をする必要がない．
logsoutを使う まず，インストール（以下でdocker runすればインストールもされるので実際は必要ない）
$ docker pull progrium/logspout  例として，&amp;rdquo;hello world&amp;rdquo;を出力し続ける単純なコンテナを立てておく．
$ docker run -d --name hello1 busybox /bin/sh -c &amp;quot;while true; do echo hello world; sleep 1; done&amp;quot; $ docker run -d --name hello2 busybox /bin/sh -c &amp;quot;while true; do echo hello world; sleep 1; done&amp;quot;  これらに対してログを収集するには以下を実行する．</description>
    </item>
    
    <item>
      <title>Dockerのネットワークの基礎</title>
      <link>http://deeeet.com/writing/2014/05/11/docker-network/</link>
      <pubDate>Sun, 11 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/05/11/docker-network/</guid>
      <description>今までいろいろ触ってきて，Dockerネットワーク周りに関しては何となくは理解していたが，人に説明できるほど理解してなかったのでまとめておく．基本は，Advanced networking - Docker Documentationがベースになっている．
仮想ブリッジの仕組み Dockerのネットワークは，仮想ブリッジdocker0を通じて管理され，他のネットワークとは隔離された環境で動作する．
Dockerデーモンを起動すると，
 仮想ブリッジdocker0の作成 ホストの既存ルートからの空きのIPアドレス空間を検索 空きから特定の範囲のIPアドレス空間を取得 取得したIPアドレス空間をdocker0に割り当て  が行われる．
コンテナを起動すると，コンテナには以下が割り当てられる．
 docker0に紐づいたveth（Virtual Ethernet）インターフェース docker0に割り当てられたIPアドレス空間から専用のIPアドレス  そしてdocker0はコンテナのデフォルトのgatewayとして利用されるようになる．コンテナに付与されるvethは仮想NICで，コンテナ側からはeth0として見える．2つはチューブのように接続され，あらゆるやりとりはここを経由して行われるようになる．
実際にコンテナを起動して確認する．まず，インターフェースから．
$ brctl show bridge name bridge id STP enabled interfaces docker0 8000.000000000000 no  $ docker run -d ubuntu /bin/sh -c &amp;quot;while true; do echo hello world; sleep 1; done&amp;quot; b9ffb0800ca5  $ docker run -d ubuntu /bin/sh -c &amp;quot;while true; do echo hello world; sleep 1; done&amp;quot; 4c0d9b786e8f  $ brctl show bridge name bridge id STP enabled interfaces docker0 8000.</description>
    </item>
    
    <item>
      <title>Dockerとは何か？どこで使うべきか？</title>
      <link>http://deeeet.com/writing/2014/05/01/what-is-docker/</link>
      <pubDate>Thu, 01 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/05/01/what-is-docker/</guid>
      <description>この記事はDockerに関する実験的な記事や，Buildpackを使ってHeroku AppをDocker Containerとして使えるようにする&amp;ldquo;building&amp;rdquo;の開発などで知られるCenturyLink Labsの &amp;ldquo;What is Docker and When To Use It&amp;rdquo;の翻訳です． Dockerとは何か？Dockerをどこで使うべきか？についてよく見かける記事とは違った視点から説明されています． 翻訳は許可をとった上で行っています．
Dockerとは何でないか Dockerとは何かを説明する前に，Dockerは何でないかについて述べる．Dockerの否定形は何か？Dockerの制限は何か？Dockerが得意でないことは何か？
 DockerはLXCのようなLinux Containerではない DockerはLXCだけのラッパーではない（理論的には仮想マシンも管理できる） DockerはChefやPuppet，SaltStackのようなConfiguration toolの代替ではない DockerはPaaSではない Dockerは異なるホスト間での連携が得意ではない DockerはLXC同士を隔離するのが得意ではない  Dockerとは何か では，Dockerは何ができるのか？メリットはなにか？
 Dockerはインフラを管理することができる Dockerはイメージのビルドや，Docker Indexを通じたイメージの共有ができる DockerはChefやPuppetといったConfiguration toolによりビルドされたサーバのテンプレートにとって，イメージ配布の良いモデルである DockerはCopy-on-wirteのファイルシステムであるbtrfsを使っており，Gitのようにファイルシステムの差分を管理することができる Dockerはイメージのリモートレポジトリをもっているため，簡単にそれらを様々なOS上で動かすことができる  Dockerの代替は何か AmazonのAWS MarketplaceはDocker Indexに近い．ただし，AMIはAWS上でしか動かすことができないのに対して，Dockerイメージは，Dockerが動いているLinuxサーバであればどこでも動かすことができる．
Cloud FoundryのWardenはLXCの管理ツールであり，Dockerに近い．ただし，Docker Indexのような他人とイメージを共有する仕組みを持っていない．
Dockerをいつ使うべきか DockerはGitやJavaのような基本的な開発ツールになりうるものであり，日々の開発やオペレーションに導入し始めるべきである．
例えば，
 インフラのバージョン管理システムとして使う チームにアプケーション用のインフラを配布したいときに使う 稼働中のサーバーと同様の環境をラップトップ上に再現して，コードを実行したいときに使う（例えばbuildingを使う） 複数の開発フェーズ（dev，stg，prod，QA）が必要なときに使う ChefのCookbookやPuppetのManifestと使う  DockerとJavaはどこが似ているのか Javaには&amp;rdquo;Write Once. Run Anywhere（一度書けばどこでも実行できる）&amp;rdquo;という文言がある．
Dockerはそれに似ている．Dockerは，一度イメージをビルドすると，Dockerが動いているLinuxサーバであれば全く同じようにそれを動かすことができる（&amp;ldquo;Build Once．Run Anywhere&amp;rdquo;）．
Javaの場合，例えば以下のようなJavaコードがあるとする．
// HelloWorld.java class HelloWorldApp { public static void main(String[] args) { System.</description>
    </item>
    
    <item>
      <title>Docker Meetup Tokyo #2 でLTしてきた &#43; DigitalOceanとGCEでもDocker Applicationを動かしてみた</title>
      <link>http://deeeet.com/writing/2014/04/13/docker-meetup-2/</link>
      <pubDate>Sun, 13 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/04/13/docker-meetup-2/</guid>
      <description>&amp;ldquo;Docker ApplicationをDaaSにデプロイ #dockerjp // Speaker Deck&amp;rdquo;
Docker Meetup Tokyo #2でLTをしてきた．Docker as a Service (DaaS) でDocker Application（Rails）を動かしてみたという内容で，基本は&amp;ldquo;OrchardにDockerアプリケーションをデプロイ&amp;rdquo;に書いたことをプレゼンにした．
発表時間は5分だけで，当日までにいろいろ試したことすべてを話すことができなかったので少し追記しておく．
LTではDockerコンテナ専用のホスティングサービスの話をしたが，それ以外のホスティングサービスでもDockerのサポートがされ始めている．例えば，DigitalOceanやGoogle Compute Engineなどがある．これらでもDocker Applicationを動かしてみた．まさに[@naoya_ito]()さんが話してたような，Build Once, Run Anywhereをやってみた感じ．
概要 動かすDocker ApplicationはLTで話したのと同様にRailsコンテナ（tcnksm/rails）と，DBにPostgresqlのコンテナ（[orchard/postgresql]()）で，それぞれ立ち上げて連携する．なおどちらもDocker Registryにあらかじめpushしておく．
これをローカル環境，Docker as a Service（Orchard），DigitalOcean，Google Compute Engingeで動かしてみる．
ローカル環境 ローカル環境（OSX）では，boot2dockerを使う．
あらかじめ，Port Forwardingした上で，VMを立ち上げる．
$ boot2docker init $ VBoxManage modifyvm &amp;quot;boot2docker-vm&amp;quot; --natpf1 &amp;quot;tcp-port3000,tcp,,3000,,3000&amp;quot; $ boot2docker up  後は，以下でコンテナを起動するだけ．
$ docker run -d -p 5432:5432 -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker --name pg orchardup/postgresql $ docker run -d -p 3000:3000 --link pg:db --name web -t tcnksm/rails &#39;rake db:create &amp;amp;&amp;amp; rake db:migrate &amp;amp;&amp;amp; rails s&#39;  [http://localhost:3000]()でアクセスできる．</description>
    </item>
    
    <item>
      <title>Dockerを便利に使うためのaliasをつくった</title>
      <link>http://deeeet.com/writing/2014/03/30/docker-alias/</link>
      <pubDate>Sun, 30 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/03/30/docker-alias/</guid>
      <description>tcnksm/docker-alias
いろいろなひとのTipや，自分がやったやつの寄せ集めで作った．以下で使えるようになる．
$ curl -fsSL https://raw.github.com/tcnksm/docker-alias/master/zshrc &amp;gt;&amp;gt; ~/.zshrc &amp;amp;&amp;amp; source ~/.zshrc  コンテナの起動 インタラクティブモードでコンテナを起動する．
alias dki=&amp;quot;docker run -i -t -P&amp;quot;  $ dki base /bin/bash  デーモンモードでコンテナを起動する．
alias dkd=&amp;quot;docker run -d -P&amp;quot;  $ dkd base /bin/echo hello  コンテナの情報 最後に起動したコンテナのIDを取得する．
alias dl=&amp;quot;docker ps -l -q&amp;quot;  $ docker run -d ubuntu /bin/sh -c &amp;quot;while true; do echo hello world; sleep 1; done&amp;quot; $ dl 4b9aa02548ae  コンテナのIPを取得する．
alias dip=&amp;quot;docker inspect --format &#39;{{ .</description>
    </item>
    
    <item>
      <title>OrchardにDockerアプリケーションをデプロイ</title>
      <link>http://deeeet.com/writing/2014/03/22/docker-orchard/</link>
      <pubDate>Sat, 22 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/03/22/docker-orchard/</guid>
      <description>Orchardは，Docker as a ServiceなDocker専用のホスティングサービス．[DigitalOcean]()のように時間単位の課金で利用できる．DigitalOceanより若干高いが，512MB RAM/20GB SSDであれば，1時間1円/月1000円程度で利用できる．
同様のサービスには，StackDockがある．またDockerをサポートしているプラットフォームとしては，Google Compute EngineやDigitalOceanなどがある．これと比較してOrchardがよいと感じた理由は以下．
 シンプル．専用のコマンドラインラッパーを使って，いつも通りのDockerコマンドをローカルから発行するだけでbuild/runが実行できる（StackDockはWebコンソールにDockerfileを書く）． Figのサポート/開発を行っており，将来的に複数のDockerのコンテナ間のリンクなどがやりやすくなりそう．  ということで，実際にサンプルアプリケーションをデプロイしてみた．サンプルコードは全て以下にある．
 tcnksm/sample-docker-orchard  準備 OSX上で行う．まず，Dockerのインストール．
$ brew update $ brew tap homebrew/binary $ brew install docker  次に，Dockerのデーモンを動かすために，VirtualBoxとboot2dockerのインストール．
$ brew tap phinze/homebrew-cask $ brew cask install virtualbox $ brew install boot2docker  boot2dockerを立ち上げて，Docker hostの環境変数を設定する．
$ boot2docker init $ boot2docker up $ export DOCKER_HOST=tcp://localhost:4243  ローカルで，アプリケーションの実行確認をする場合は，upする前に，boot2docker-vmのPort forwardingの設定をしておく．
$ VBoxManage modifyvm &amp;quot;boot2docker-vm&amp;quot; --natpf1 &amp;quot;tcp-port3000,tcp,,3000,,3000&amp;quot;  最後に，Orchardでアカウントを作成し，Orchardのコマンドラインツールをインストールする．
$ curl -L https://github.</description>
    </item>
    
    <item>
      <title>DockerfileのONBUILD</title>
      <link>http://deeeet.com/writing/2014/03/21/docker-onbuild/</link>
      <pubDate>Fri, 21 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/03/21/docker-onbuild/</guid>
      <description>Docker 0.8においてONBUILDというDockerfile用のコマンドが導入された．0.8ではOSXのdocker clientが脚光を浴びたが，このONBUILDはかなり強力な機能．リリースノートはこちら．ONBUILDの公式ドキュメントはこちら．
ONBUILDを使うと，次のビルドで実行するコマンドをイメージに仕込むことができるようになる．つまり，ベースイメージにONBUILDによるコマンドを仕込み，別のDockerfileでそのベースイメージを読み込みビルドした際に，そのコマンドを実行させるということが可能になる．要するに，親DockerfileのDockerfileコマンドを子Dockerfileのビルド時に実行させることができる機能．
これは，アプリケーション用のイメージを作るときや，ユーザ特有の設定を組み込んだデーモン用のイメージを作るときなどに有用になる．また，オリジナルのHerokuのBuildpack的なものを作ることもできる．
言葉では伝えられないので簡単に動作例を示す．例えば，以下のようなDockerfile.baseを準備する．
# Docekerfile.base FROM ubuntu ONBUILD RUN echo &amp;quot;See you later&amp;quot;  これをtcnksm/echo_baseという名前でビルドする．
$ docker build -t tcnksm/echo_base - &amp;lt; Dockerfile.base Step 0 : FROM ubuntu Pulling repository ubuntu ... f323cf34fd77: Download complete ---&amp;gt; 9cd978db300e Step 1 : ONBUILD RUN echo &amp;quot;See you later&amp;quot; ---&amp;gt; Running in 9e42ede94d60 ---&amp;gt; e18fdd8d9fa8  RUN echoは実行されていない．
次に，このtcnksm/echo_baseを基にした別のイメージを作成するDockerfileを準備する．
FROM tcnksm/echo_base  tcnksm/echoという名前でビルドする．
$ docker build -t tcnksm/echo . Uploading context 3.</description>
    </item>
    
    <item>
      <title>Dockerコンテナ間のlink，database.ymlの書き方</title>
      <link>http://deeeet.com/writing/2014/03/20/docker-link-container/</link>
      <pubDate>Thu, 20 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/03/20/docker-link-container/</guid>
      <description>DockerはLinksというコンテナ同士の連携を簡単に行う仕組みをもつ． これは，DB用のコンテナとアプリケーション用のコンテナの連携を行いたいときなどに有用になる．
例えば，1337ポートがEXPOSEされたcontainer1という名前のコンテナとの連携を行いたいとする． このとき以下のように，-link 連携したいコンテナ名:エイリアス名で新しいコンテナを起動すると， そのコンテナ内に連携したいコンテナのポート番号やIPをもった環境変数が現れる．
docker run -d -link container1:alias user/sample bash root@48408a38c9b2:/# env ALIAS_PORT_5432_TCP_ADDR=172.17.0.2 ALIAS_PORT=tcp://172.17.0.2:5432 ALIAS_PORT_5432_TCP=tcp://172.17.0.2:5432 ALIAS_PORT_5432_TCP_PORT=5432 ...  この環境変数を使えば，コンテナからコンテナへのデータの送信などの連携が可能になる．これがLinksの機能．
PostgresqlコンテナとRailsコンテナの連携 例として，postgresqlコンテナとRailsコンテナを連携させてみる． postgresqlのイメージには，dockerコンテナのホスティングサービスであるOrchardが提供する[orchardup/postgresql]()が使いやすいのでそれを利用する．
まず，postgresqlコンテナをpgという名前で起動する．
$ docker run -d -p 5432:5432 -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -name pg orchardup/postgresql  Railsからこのコンテナのデータベースにアクセスするには，config/database.ymlを以下のようにしておく．
development: adapter: postgresql template: template0 encoding: unicode database: my_app_development pool: 5 username: docker password: docker host: &amp;lt;%= ENV.fetch(&#39;DB_PORT_5432_TCP_ADDR&#39;) %&amp;gt; port: &amp;lt;%= ENV.fetch(&#39;DB_PORT_5432_TCP_PORT&#39;) %&amp;gt;  あとは，エイリアス名をdbとして，Railsコンテナを起動する．
docker run -i -p 3000:3000 -link pg:db -name web -t tcnksm/rails &#39;rake db:create &amp;amp;&amp;amp; rake db:migrate &amp;amp;&amp;amp; rails s&#39;  参考</description>
    </item>
    
    <item>
      <title>Docker Share</title>
      <link>http://deeeet.com/writing/2014/03/12/docker-share/</link>
      <pubDate>Wed, 12 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/03/12/docker-share/</guid>
      <description>Vagrant Shareとngrok
Vagrant Share素晴らしい．外部ネットワークのマシンから，ローカルに立てた仮想マシンへのアクセスを実現している．
TL;DR ngrokを使えば，Dockerコンテナに対してVagrant Shareと同様のことができる．つまり，Dockerコンテナを外部ネットワークからアクセス可能にすることができる．
以下をやってみた．
 Apacheコンテナへのアクセス Railsコンテナへのアクセス  準備 OSX上で行った．dockerはboot2dockerで動かす．
$ brew install boot2docker  事前にboot2dockerにport forwardingの設定をしておく．
$ VBoxManage modifyvm &amp;quot;boot2docker-vm&amp;quot; --natpf1 &amp;quot;tcp-port8080,tcp,,8080,,8080&amp;quot;  設定が終わったらしたら，boot2dockerを起動しておく．
$ boot2docker start  また，ngrokをダウンロードして適切な場所に配置しておく．
Apacheコンテナ 以下のようなDockerfileを準備する．
FROM ubuntu:12.04 RUN apt-get update RUN apt-get install -y apache2 ENV APACHE_RUN_USER www-data ENV APACHE_RUN_GROUP www-data ENV APACHE_LOG_DIR /var/log/apache2 EXPOSE 80 ENTRYPOINT [&amp;quot;/usr/sbin/apache2&amp;quot;] CMD [&amp;quot;-D&amp;quot;, &amp;quot;FOREGROUND&amp;quot;]  イメージをビルドする．
$ docker build -t apache2 .</description>
    </item>
    
    <item>
      <title>rbdockというRuby/Rails/Sinatra用のDockerfileを生成するgemをつくった</title>
      <link>http://deeeet.com/writing/2014/03/06/rbdock/</link>
      <pubDate>Thu, 06 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/03/06/rbdock/</guid>
      <description>tcnksm/rbdock rbdock | RubyGems.org | your community gem host  実験的に作ってみた．RubyやRails，Sinatraアプリケーションを動かすためのDockerfileを生成する．
これを作った理由は，今まで自分でRuby/Rails/Sinatraのコンテナを作ってみたり，Web上のRuby+Docker関連の記事などを見ていると，どれも同じようなDockerfileを書いていたため．
さらに，Dockerの流れを見ていると，
 コンテナは必要なものだけを入れるようになりそう．つまり，RedisならRedisの，nginxならnginxの，RailsならRailsのコンテナをそれぞれ作るようになりそう． コンテナの起動やコンテナ間の連携はFigなどが受け持ってくれそう．  な雰囲気なので，Ruby/Rails/Sinatra用のコンテナをつくるためのDockerfileをつくるところに特化したツールを作ってみようと考えた．ちなみにDocker.ioには，あらかじめRubyがビルドされたイメージが上げられつつある．だから，それをそのまま使うのもありだけど，編集可能なDockerfileが手元にある方がよい．
インストール gemでインストールする．
$ gem install rbdock  インストールが完了するとrbdockというコマンドが使えるようになる．
$ rbdock --version rbdock 0.1.0  使い方（Rubyのみ） 使い方は以下．使いたいバージョンのRubyを指定するだけで，そのバージョンのRubyが使えるDockerfileが生成される．
$ rbdock &amp;lt;ruby-versions&amp;gt; [&amp;lt;args&amp;gt;]  例えば，ruby 2.1.0が使えるDockerfileを生成したい場合は以下のようにする．
$ rbdock 2.1.0  生成結果は以下．
FROM ubuntu # Install basic packages RUN apt-get update RUN apt-get install -y build-essential wget curl git RUN apt-get install -y zlib1g-dev libssl-dev libreadline-dev libyaml-dev libxml2-dev libxslt-dev RUN apt-get install -y sqlite3 libsqlite3-dev RUN apt-get clean # Install ruby-build RUN git clone https://github.</description>
    </item>
    
    <item>
      <title>OSXでboot2dockerを使う</title>
      <link>http://deeeet.com/writing/2014/01/28/boot2docker-osx/</link>
      <pubDate>Tue, 28 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/01/28/boot2docker-osx/</guid>
      <description>公式のDocker Client for OSXがリリースされて，OSXでDockerを使うのはちょっと楽になった．ただ，Docker自体はVritualBoxなどのVM上で実行する必要があり，VMの起動には時間がかかるので寿命が縮む．boot2dockerを使うと，他と比べて断然早くVMを起動でき，すぐにDockerが使える．
boot2dockerというのは，Tiny Core LinuxをベースにしたDocker実行のみに特化した軽量版のLinuxディストリビューション．特化しているため起動はとても速い．前からあるが，VirtualBoxをわざわざ起動する必要があったりなど，ちょっと使うのはめんどくさかった．
Vagrantの作者であるMitchell HashimotoさんがPackerを使ってboot2dockerのVagrant Boxを作ったため，Vagrant経由で簡単にboot2dockerを使うことができるようになった．
ということで，使ってみた．
tcnksm/boot2docker-osx
Vagrantfileは以下．
DOCKER_PORT = 5422 Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.box = &amp;quot;boot2docker-0.4.0&amp;quot; config.vm.box_url = &amp;quot;https://github.com/mitchellh/boot2docker-vagrant-box/releases/download/v0.4.0/boot2docker.box&amp;quot; config.vm.network &amp;quot;forwarded_port&amp;quot;, guest: DOCKER_PORT, host: DOCKER_PORT config.vm.provision :shell, :inline =&amp;gt; &amp;lt;&amp;lt;-PREPARE INITD=/usr/local/etc/init.d/docker sudo sed -i -e &#39;s/docker -d .* $EXPOSE_ALL/docker -d -H 0.0.0.0:#{DOCKER_PORT}/&#39; $INITD sudo $INITD restart PREPARE end  OSXのDockerクライアントを使うためにport fowardingの設定と，Docker deamonのバインドアドレスの変更のみをしている．
あとは起動（vagrant up）するだけ，大体20秒くらいで立ち上がる．例えば，Ubuntu precise 64 box+docker provisionと比べると，半分以下の時間で立ち上がる．
問題がないわけではなく，いくつかVagrantのprovisioningが使えない．例えば，自分が触った中では，private IPの設定やdocker provisioningなどが使えなかった．imageのビルドもちょっと遅い．それでも起動は速いので，とりあえず軽くコマンド叩きたいとか，で使うのが良さそう．がっつり開発するときは，普通のBox使ってる．
ちなみに，OSXからDockerを使うためのヘルパーはたくさん出てきている．例えば，docker-osxや，今回のboot2dockerを使ったdvmなどがある．でも，今回のように簡単なVagrantfileさえ準備できれば簡単に使えるから自分は使わないかなと．</description>
    </item>
    
    <item>
      <title>公式のDocker client for OSXがリリース</title>
      <link>http://deeeet.com/writing/2014/01/10/docker-from-osx/</link>
      <pubDate>Fri, 10 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/01/10/docker-from-osx/</guid>
      <description>2014.01.02にOSXのdocker clientがリリースされた．DockerはGoで書かれているので，OSX上で自分でビルドして使ってる人もいたが，今回は公式のバイナリリリース．さらに，Homebrewのhomebrew-binaryレポジトリにFormulaも追加され，すぐに使えるようになった．
clientなので，VMもしくはリモートに立てたDocker deamonに対してローカルからコマンドが叩けるようになったということ．とりあえず，ローカルにVM立てて触ってみた．
tcnksm/docker-osx
まず，dokcer clientのインストール．
$ brew update $ brew tap homebrew/binary $ brew install docker  Vagrantfileは以下のようにする（VagrantはDocker provisioningが有効な1.4以上を使うこと）．
#Vagrantfile DOCKER_URL = &amp;quot;192.168.50.4&amp;quot; DOCKER_PORT = 5422 Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.box = &amp;quot;precise64&amp;quot; config.vm.box_url = &amp;quot;http://files.vagrantup.com/precise64.box&amp;quot; config.vm.network :private_network, ip: DOCKER_URL config.vm.provision :docker do |d| d.pull_images &amp;quot;base&amp;quot; end config.vm.provision :shell, :inline =&amp;gt; &amp;lt;&amp;lt;-PREPARE sudo sed -i -e &#39;s/DOCKER_OPTS=/DOCKER_OPTS=\&amp;quot;-H 0.0.0.0:#{DOCKER_PORT}\&amp;quot;/g&#39; /etc/init/docker.conf sudo service docker stop sudo service docker start PREPARE end  やってることは以下．</description>
    </item>
    
    <item>
      <title>serverspecとdocker-apiでDockerfileをTDD</title>
      <link>http://deeeet.com/writing/2014/01/06/tdd-dockerfile/</link>
      <pubDate>Mon, 06 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2014/01/06/tdd-dockerfile/</guid>
      <description>いくつかDockerfileを書いてきた．今書いているDockerfileは短くてシンプルなものばかりだが，もっと長く複雑化した時に不安になりそうだ．不安を解消するにはテストしかない．さらにテスト駆動的にDockerイメージを開発できたら素敵だ．つまり，
 テストを書く Dockerイメージを作成して，テストの実行 -&amp;gt; RED Dockerfileの編集 Dockerイメージを作成して，テストの実行 -&amp;gt; GREEN テストを&amp;hellip;  の流れができるとよい．
ということで，RSpecを使ってTDDでDockerfileを開発するというのをやってみた，tcnksm/docker-rspec．今回実現したのは以下．
 Docker Remote APIでDockerfile特有のコマンド(e.g, CMDやEXPOSE)のRSpecテスト serverspecでパッケージのインストールのRSpecテスト  これらをOSX上からやれるようにした．これでDockerfileの記述内容は網羅的にテストできると思う．
準備 (Vagrant) 今回は，VagrantのVM上でDockerを動かす．OSはUbuntu12.04．Vagrantfileは以下．
Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.box = &amp;quot;precise64&amp;quot; config.vm.box_url = &amp;quot;http://files.vagrantup.com/precise64.box&amp;quot; config.vm.network :private_network, ip: &amp;quot;192.168.50.4&amp;quot; config.vm.provision :docker do |d| d.pull_images &amp;quot;base&amp;quot; end end  やっていることは以下
 Vagrant VMにIPアドレス&amp;rdquo;192.168.50.4&amp;rdquo;を割り当て Dockerのbaseイメージをpull  Vagrant VMはあらかじめ起動しておく．
vagrant up  また，Vagrant VMへのsshの設定を書き出しておく．
vagrant ssh-config --host docker-vm &amp;gt;&amp;gt; ~/.ssh/config  Docker Remote APIによるテスト まず，Docker Remote APIを使って，Dockerfile特有のテストをする．例えば，イメージが存在しているか，外部に向けたポートが設定されているか(EXPOSE)など．これは，主にExperimenting with test driven development for dockerを参考にした．</description>
    </item>
    
    <item>
      <title>Vagrant &#43; DockerでSinatraを動かす</title>
      <link>http://deeeet.com/writing/2013/12/27/sinatra-on-docker/</link>
      <pubDate>Fri, 27 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2013/12/27/sinatra-on-docker/</guid>
      <description>tcnksm/docker-sinatra
簡単なsinatraアプリケーションをDocker上で動かしてみた．
まずはsinatraアプリケーション．特別なことはなく，Procfileとconfig.ruを準備して，foremanで動かす．外部からのアクセスを有効にするため，ListenAddressを指定しておく．
#Procfile web: bundle exec rackup config.ru -p 4567 -s thin -o 0.0.0.0  次に，Vagrantの設定．VagrantはDockerのprovisioningが有効な1.4を利用する．vagrantのインストールは以下のBrewfileを準備して，brew bundleする．
tap phinze/homebrew-cask install brew-cask cask install virtualbox cask install vagrant  Vagrantfileは以下．
Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.box = &amp;quot;precise64&amp;quot; config.vm.network :forwarded_port, guest: 4567, host: 4567 config.vm.provision :docker do |d| d.pull_images &amp;quot;ubuntu&amp;quot; end end  Port fowardでホストからアクセス可能なポート番号を指定しておく．後は，dockerのprovisioningでubuntuイメージを取得しておく．
次に，Dockerイメージの作成．Dockerfileは以下．
FROM base # Install packages for building ruby RUN apt-get update RUN apt-get install -y --force-yes build-essential wget git RUN apt-get install -y --force-yes zlib1g-dev libssl-dev libreadline-dev libyaml-dev libxml2-dev libxslt-dev RUN apt-get clean # Install ruby RUN wget -P /root/src ftp://ftp.</description>
    </item>
    
    <item>
      <title>Dockerのイメージはどこにある?</title>
      <link>http://deeeet.com/writing/2013/12/16/where-are-docker-images-storede/</link>
      <pubDate>Mon, 16 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2013/12/16/where-are-docker-images-storede/</guid>
      <description>Where are Docker images stored?
非常にわかりやすいまとめ．ただ，自分の環境とはディレクトリ構造などが若干異なった (バージョンが異なる?) ので，自分で手を動かしながらまとめなおしてみた．
今回用いるDockerのバージョンは以下．
$ docker -v Docker version 0.7.2  ubuntuレポジトリを取得する
$ docker pull ubuntu  $ docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 12.04 8dbd9e392a96 8 months ago 128 MB ubuntu latest 8dbd9e392a96 8 months ago 128 MB ubuntu precise 8dbd9e392a96 8 months ago 128 MB ubuntu 12.10 b750fe79269d 8 months ago 175.3 MB ubuntu quantal b750fe79269d 8 months ago 175.</description>
    </item>
    
    <item>
      <title>Dockerで継続的インテグレーション</title>
      <link>http://deeeet.com/writing/2013/12/13/ci-with-docker/</link>
      <pubDate>Fri, 13 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2013/12/13/ci-with-docker/</guid>
      <description>Dockerで複数バージョンのrubyがインストールされたイメージを作るを使って，ローカルでTravis CI的なビルドテストを実現する方法を書く．
準備 (OS X) Vagrantを使う．バージョン1.4からはDockerのprovisioningに対応してるのでそれを使う． Download Vagrant - Vagrantより.dmgをダウンロードしてきてインストール.
インストールしたら，rubyプロジェクトに移動して以下を実行する．
vagrant init precise64 http://files.vagrantup.com/precise64.box  Vagrantfileを以下のように編集する．ここでは，docker-rbenvで作成した，複数バージョンのruby (1.8,7と1.9.3，2.0.0)とそれぞれにbundlerがインストールされたDockerイメージtcnksm/rbenv-rubygemsを用いる．
Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.box = &amp;quot;precise64&amp;quot; config.vm.provision :docker do |d| d.pull_images &amp;quot;tcnksm/rbenv&amp;quot; end end  あらかじめ仮想サーバを起動しておく．
vagrant up  Dockerの実行は仮想サーバーへのssh経由で行う．
vagrant ssh-config --host docker-host &amp;gt;&amp;gt; ~/.ssh/config  (注: Vagrant1.4のバグでsshの設定以外の出力をすることがあるので，適宜~/.ssh/configを編集してそれを消す)
実行したいテストの記述 プロジェクトのルートに実行したいテストをシェルスクリプトで記述する．
# docker.sh for v in 1.8.7-p371 1.9.3-p392 2.0.0-p353 do rbenv global $v bundle rspec done  記述しているのはバージョンをそれぞれ1.8.7，1.9.3，2.0.0と切り替えて，それぞれに対してrubygemsをインストールして，rspecテストを実行している．(毎回bunldeを実行するのがたるい場合は，あらかじめbundleを実行してそれをコミットしてイメージを作ってしまえばよい，例えば，Using Docker and Vagrant on Mac OS X with a Ruby on Rails applicationも同様のことをしている)</description>
    </item>
    
    <item>
      <title>Docker image with multiple versions of ruby</title>
      <link>http://deeeet.com/writing/2013/12/12/docker-rbenv-en/</link>
      <pubDate>Thu, 12 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2013/12/12/docker-rbenv-en/</guid>
      <description>tcnksm/docker-rbenv
This can generate Docker image which is installed multiple versions of ruby by rbenv.
The image is pushed at docker.io, tcnksm/rbenv, so you can use it soon.
$ docker pull tcnksm/rbenv  or in Dockerfile,
FROM tcnksm/rbenv  Dockerfile I will describe this Dockerfile and how to edit it for your own image.
FROM base MAINTAINER tcnksm &amp;quot;https://github.com/tcnksm&amp;quot; # Install packages for building ruby RUN apt-get update RUN apt-get install -y --force-yes build-essential curl git RUN apt-get install -y --force-yes zlib1g-dev libssl-dev libreadline-dev libyaml-dev libxml2-dev libxslt-dev RUN apt-get clean # Install rbenv and ruby-build RUN git clone https://github.</description>
    </item>
    
    <item>
      <title>Dockerで複数バージョンのrubyがインストールされたイメージを作る</title>
      <link>http://deeeet.com/writing/2013/12/12/docker-rbenv/</link>
      <pubDate>Thu, 12 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2013/12/12/docker-rbenv/</guid>
      <description>tcnksm/docker-rbenv
これにより，rbenvにより複数バージョンのrubyがインストールされたイメージをつくることができる．
イメージはdocker.ioに置いてある（tcnksm/rbenv）ためすぐに使うことができる．
$ docker pull tcnksm/rbenv  もしくはDockerfileで
FROM tcnksm/rbenv  とするだけ．
具体的な使い方は，Dockerで継続的インテグレーションに書いた．例えば，guardと連携して，複数バージョンに対するrspecテストをローカルで実現するなど．
Dockerfile 以下では，このイメージを作成するためのDockerfileの詳細な説明とオリジナルのイメージを作成する方法について書く．Dockerfileは以下．
FROM base MAINTAINER tcnksm &amp;quot;https://github.com/tcnksm&amp;quot; # Install packages for building ruby RUN apt-get update RUN apt-get install -y --force-yes build-essential curl git RUN apt-get install -y --force-yes zlib1g-dev libssl-dev libreadline-dev libyaml-dev libxml2-dev libxslt-dev RUN apt-get clean # Install rbenv and ruby-build RUN git clone https://github.com/sstephenson/rbenv.git /root/.rbenv RUN git clone https://github.com/sstephenson/ruby-build.git /root/.rbenv/plugins/ruby-build RUN ./root/.rbenv/plugins/ruby-build/install.sh ENV PATH /root/.</description>
    </item>
    
    <item>
      <title>10秒でDockerを起動する</title>
      <link>http://deeeet.com/writing/2013/12/09/fatest-docker-iso/</link>
      <pubDate>Mon, 09 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2013/12/09/fatest-docker-iso/</guid>
      <description>boot2docker
boot2dockerはDockerを実行することに特化した軽量版のLinuxディストリビューション．Tiny Core Linuxをベースにしている．isoイメージ自体もDockerから作られている．デモを観るとその起動速度がわかる．現在バージョン0.3．
wget https://github.com/steeve/boot2docker/releases/download/v0.3.0/boot2docker.iso  あとはVirtualboxなどから起動すればすぐにDockerを使える．
めちゃめちゃ軽量なので，普段使っているパッケージがなかったり，そもそもそのパッケージを入れるのが大変だったりする．今のところDockerのコマンドを試したりするに良さそう．
参考
 Boot Docker in 10 seconds on any VM or physical machine with this 30 MB ISO Tiny Core Linux, Micro Core Linux, 12MB Linux GUI Desktop, Live, Frugal, Extendable Install TinyCore Linux on VirtualBox  </description>
    </item>
    
    <item>
      <title>Docker cheat sheet with examples</title>
      <link>http://deeeet.com/writing/2013/12/08/docker-cheat-with-exmaple/</link>
      <pubDate>Sun, 08 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2013/12/08/docker-cheat-with-exmaple/</guid>
      <description>Docker Cheat Sheet is a nice documentation. It provides us Docker basic commands and system and It&amp;rsquo;s easy to understand. But there are less exaples, I reconstructed it with real examples. You should refer above document about installation.
Set up Pull a base image.
docker pull ubuntu  It&amp;rsquo;s annoy to restore Container ID, you may forget to restore. You can set below alias. With this, you can get the ID of the last-run Container (15 Docker tips in 5 minutes)</description>
    </item>
    
    <item>
      <title>すぐにDockerを試したい人のための基礎コマンド</title>
      <link>http://deeeet.com/writing/2013/12/08/docker-cheat/</link>
      <pubDate>Sun, 08 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>http://deeeet.com/writing/2013/12/08/docker-cheat/</guid>
      <description>Docker 虎の巻
Dockerの基礎のまとめが良かったので翻訳してみた．原典は，Docker Cheat Sheet．このまとめは説明は十分にあるが，例がほとんどない．実例を使って，コンテナとイメージに関する基礎コマンドをまとめてみる．
OS X で試したい Vagrantを使う．バージョン1.4からはDockerのprovisioningに対応してるのでそれを使う． Download Vagrant - Vagrantより.dmgをダウンロードしてきてインストール.
vagrant init precise64 http://files.vagrantup.com/precise64.box  Vagrantfileを以下のようにすれば，すぐにDockerを使える．
Vagrant.configure(&amp;quot;2&amp;quot;) do |config| config.vm.box = &amp;quot;precise64&amp;quot; config.vm.provision :docker do |d| d.pull_images &amp;quot;ubuntu&amp;quot; end end  ログイン
vagrant ssh  準備 コンテナのIDをいちいち保持しておくのは面倒，忘れるので，以下のaliasを設定しておくと直近に起動したコンテナのIDを呼び出すことができるようになる（15 Docker tips in 5 minutes）．
alias dl=&#39;docker ps -l -q&#39;  コンテナ コンテナを作成する．-dオプションでバックグラウンドで実行する．
docker run -d ubuntu /bin/sh -c &amp;quot;while true; do echo hello world; sleep 1; done&amp;quot;  コンテナを停止する．</description>
    </item>
    
  </channel>
</rss>