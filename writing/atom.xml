<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SOTA</title>
    <link>http://deeeet.com/</link>
    <description>Recent content on SOTA</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>Copyright (C) 2013-2015 Taichi Nakashima All Right Reserved.</copyright>
    <lastBuildDate>Fri, 22 Jul 2016 09:12:28 +0900</lastBuildDate>
    <atom:link href="http://deeeet.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go1.7のcontextパッケージ</title>
      <link>http://deeeet.com/writing/2016/07/22/context/</link>
      <pubDate>Fri, 22 Jul 2016 09:12:28 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/07/22/context/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://tip.golang.org/doc/go1.7&#34;&gt;Go1.7&lt;/a&gt;では&lt;a href=&#34;https://godoc.org/golang.org/x/net/context&#34;&gt;golang.org/x/net/context&lt;/a&gt;が&lt;code&gt;context&lt;/code&gt;パッケージとして標準パッケージに仲間入りする．そしていくつかの標準パッケージでは&lt;code&gt;context&lt;/code&gt;パッケージを使ったメソッド/関数も新たに登場する．&lt;code&gt;context&lt;/code&gt;パッケージは今後さらに重要な，Gopherは普通に扱うべき，パッケージになると考えられる．本記事ではそもそも&lt;code&gt;context&lt;/code&gt;パッケージとは何か？なぜ登場したのか？なぜ重要なのか？どのように使うべきか？についてまとめる．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;パッケージが初めて紹介されたのは2014年のThe Go Blogの記事 &lt;a href=&#34;https://blog.golang.org/context&#34;&gt;&amp;ldquo;Go Concurrency Patterns: Context&amp;rdquo;&lt;/a&gt;である．この記事ではなぜGoogleが&lt;code&gt;context&lt;/code&gt;パッケージを開発したのか，どのように使うのか具体的な検索タスクを例に解説されている．まだ読んだことがない人はそちらを先に読むと良い．&lt;/p&gt;

&lt;h2 id=&#34;contextパッケージとは何か&#34;&gt;contextパッケージとは何か&lt;/h2&gt;

&lt;p&gt;ここでは具体的な利用例から&lt;code&gt;context&lt;/code&gt;とは何かを説明する．&lt;/p&gt;

&lt;p&gt;例えばGoの典型的な利用例であるWebアプリケーションを考える．Goのサーバにおいてリクエストはそれぞれ個別のgoroutineで処理される．そしてリクエストHandlerは新たなgoroutineを生成しバックエンドのDBや別のサーバにリクエストを投げ結果を得てユーザに対してレスポンスを返す．&lt;/p&gt;

&lt;p&gt;このような別サーバへのリクエストのように時間のかかる処理をgoroutineで実行する場合どのようなことに注意する必要があるだろうか．まず最初に注意するべきはその処理に適切なTimeoutやDeadlineを設定して処理が停滞するのを防ぐことである．例えば別のサーバにリクエストを投げる場合にネットワークの問題でリクエストに時間がかかってしまうことは大いに考えられる．リクエストにTimeoutを設定して早めにレスポンスを返しリトライを促すべきである．&lt;/p&gt;

&lt;p&gt;次に注意するべきは生成したgoroutineを適切にキャンセルしリソースを解放することである．例えば別のサーバにリクエストを投げる場合に適切なキャンセル処理を行わないとTimeout後もネットワークリソースが使われ続けることになる（CPUやメモリを使い続けるかもしれない）．この場合&lt;code&gt;net/http&lt;/code&gt;パッケージレベルでリクエストをキャンセルするべきである．&lt;/p&gt;

&lt;p&gt;さらにそのgoroutineは別のgoroutineを呼び出しそれがまた別の&amp;hellip;と呼び出しの連鎖は深くなることが考えられる．その場合も親のTimeoutに合わせてその子は全て適切にキャンセルされリソースは解放されるべきである．．&lt;/p&gt;

&lt;p&gt;このようにキャンセル処理は重要である．&lt;code&gt;context&lt;/code&gt;パッケージはこのキャンセルのためのシグナルをAPIの境界を超えて受け渡すための仕組みである．ある関数から別の関数へと，親から子へと，キャンセルを伝搬させる．&lt;/p&gt;

&lt;p&gt;これは&lt;code&gt;context&lt;/code&gt;を使わなくても実現できる．しかし標準パッケージになったことで&lt;code&gt;context&lt;/code&gt;は「キャンセルのためのシグナルの受け渡しの標準的なインターフェース」として使える．この流れは別の標準パッケージに新たに追加された関数に見ることができる．&lt;/p&gt;

&lt;p&gt;（後述するが&lt;code&gt;context&lt;/code&gt;パッケージは限定されたスコープの値，例えば認証情報など，の受け渡しとしても利用できる．しかし筆者はこれは付随的な機能でありキャンセル機構としての&lt;code&gt;context&lt;/code&gt;の方が重要であると考えている）&lt;/p&gt;

&lt;h2 id=&#34;コードで追うcontextパッケージ&#34;&gt;コードで追うcontextパッケージ&lt;/h2&gt;

&lt;p&gt;言葉のみでは伝わりにくいので具体的なサンプルコードを使って&lt;code&gt;context&lt;/code&gt;パッケージの使いどころを説明する．&lt;/p&gt;

&lt;p&gt;以下のような単純なリクエストHandlerを考える．このHandlerはユーザからのリクエストを受けバックエンドのサービスにリクエストを投げる．そして得た結果をユーザに返す（具体的なレスポンスの書き込みなどは省略している）．リクエストは別のgoroutineで投げ，エラーをchannelで受け取る．このコードを改善していく．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    // 新たにgoroutineを生成してバックエンドにリクエストを投げる
    // 結果をerror channelに入れる
    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request()
    }()

    // error channelにリクエストの結果が返ってくるのを待つ
    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず現状のコードはネットワークの問題などで&lt;code&gt;request()&lt;/code&gt;に時間がかかりユーザへのレスポンスが停止してしまう可能性がある．これを防ぐためにはTimeoutを設定するべきである．&lt;code&gt;time&lt;/code&gt;パッケージの&lt;code&gt;time.After&lt;/code&gt;を使うと以下のようにTimeoutを設定することができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request()
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
        
    // Timeout（2秒）を設定する．
    // 例えばしばらく経ってから再度リクエストをするように
    // レスポンスを返す．
    case &amp;lt;-time.After(2 * time.Second):
        log.Println(&amp;quot;failed: timeout&amp;quot;)
        return
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでリクエストがネットワークなどの不調によりリクエストが停滞してしまう問題は解決できた．しかしこれでは不十分である．Timeoutでリクエストをユーザに返した後も&lt;code&gt;request&lt;/code&gt;は別のgoroutineで動き続ける．つまりサーバのリソースを使い続ける．少量であれば問題ないがリクエストが増えれば増えるほど問題になる．これを防ぐには&lt;code&gt;request()&lt;/code&gt;をキャンセル可能にリソースを解放するべきである．&lt;code&gt;context&lt;/code&gt;を使わない場合は，これは例えば以下のように実装できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    // handlerからrequestをキャンセルするためのchannelを準備する
    doneCh := make(chan struct{}, 1)
    
    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request(doneCh)
    }()

    // 別途goroutineを準備してTimeoutを設定する
    go func() {
        &amp;lt;-time.After(2 * time.Second)
        // Timeout後にdoneChをクローズする
        // 参考: https://blog.golang.org/pipelines
        close(doneCh)
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;request()&lt;/code&gt;は以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func request(doneCh chan struct{}) error {
    tr := &amp;amp;http.Transport{}
    client := &amp;amp;http.Client{Transport: tr}
    
    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, backendService, nil)
    if err != nil {
        return err
    }
　　
    // 新たにgoroutineを生成して実際のリクエストを行う
    // 結果はerror channelに投げる
    errCh := make(chan error, 1)
    go func() {
        _, err := client.Do(req)
        errCh &amp;lt;- err
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            return err
        }
    
    // doneChはhandlerからのキャンセル シグナル（close(doneCh)）
    // を待ち受ける
    case &amp;lt;-doneCh:
        // キャンセルが実行されたら適切にリクエストを停止して
        // エラーを返す．
        tr.CancelRequest(req)
        &amp;lt;-errCh
        return fmt.Errorf(&amp;quot;canceled&amp;quot;)
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;パッケージを使うとこれはより簡単に書くことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    // 2秒でTimeoutするcontextを生成する
    // cancelを実行することでTimeout前にキャンセルを実行することができる
    //     
    // また後述するようにGo1.7ではnet/httpパッケージでcontext
    // を扱えるようになる．例えば*http.Requestからそのリクエストの
    // contextを取得できる．
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request3(ctx)
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;request()&lt;/code&gt;は以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func request(ctx context.Context) error {
    tr := &amp;amp;http.Transport{}
    client := &amp;amp;http.Client{Transport: tr}
    
    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, backendService, nil)
    if err != nil {
        return err
    }

    // 新たにgoroutineを生成して実際のリクエストを行う
    // 結果はerror channelに投げる
    errCh := make(chan error, 1)
    go func() {
        _, err := client.Do(req)
        errCh &amp;lt;- err
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            return err
        }
    
    // Timeoutが発生する，もしくはCancelが実行されると
    // Channelが返る
    case &amp;lt;-ctx.Done():
        tr.CancelRequest(req)
        &amp;lt;-errCh
        return ctx.Err()
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;doneCh&lt;/code&gt;と比べると&lt;code&gt;context&lt;/code&gt;を使った場合はよりシンプルに書けているのがわかる．これだけではない．標準パッケージになるということは，今後はこの重要なキャンセル処理を統一的なインターフェースとして書くことができるということである．&lt;/p&gt;

&lt;h2 id=&#34;contextの契約&#34;&gt;contextの契約&lt;/h2&gt;

&lt;p&gt;具体的な使い方は&lt;a href=&#34;https://tip.golang.org/pkg/context/&#34;&gt;ドキュメント&lt;/a&gt;が詳しいのでそれを読むのが良い．大きなパッケージではないのですぐに読めると思う．以下では注意するべきことを簡単にまとめる．&lt;/p&gt;

&lt;p&gt;まず自分で&lt;code&gt;context&lt;/code&gt;を前提としたメソッド/関数を提供する場合は以下の形式を守る．必ずメソッド/関数の第一引数に&lt;code&gt;context.Context&lt;/code&gt;を渡せるようにする．structなどに埋め込んではいけない．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func DoSomething(ctx context.Context, arg Arg) error {
    // ... use ctx ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに&lt;code&gt;context&lt;/code&gt;をもつ関数は適切なキャンセル処理を実装するべきである．この関数を使う側は呼び出し側（つまり親&lt;code&gt;context&lt;/code&gt;）でTimeoutが発生した，もしくは&lt;code&gt;Cancel&lt;/code&gt;を実行した場合に適切にキャンセル処理・リソースの解放が実行されることを期待する．例えば，上のサンプルコードで示したようにHTTPリクエストであれば&lt;code&gt;CancelRequest&lt;/code&gt;を呼び確実に処理を終了させる必要がある．&lt;/p&gt;

&lt;p&gt;内部で別の関数を呼ぶ場合も&lt;code&gt;context&lt;/code&gt;を前提とし親&lt;code&gt;context&lt;/code&gt;からキャンセル可能にするべきである．標準パッケージで&lt;code&gt;context&lt;/code&gt;を前提としたメソッド/関数が実装され始めているのはこの理由によると思う．&lt;/p&gt;

&lt;p&gt;これらがGopherの間の&lt;code&gt;context&lt;/code&gt;の契約になると思う．&lt;/p&gt;

&lt;h2 id=&#34;valueの扱い&#34;&gt;Valueの扱い&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;パッケージは限定されたスコープの値，例えば認証情報など，の受け渡しとしても利用できる．しかしこれはキーと値を&lt;code&gt;interface{}&lt;/code&gt;型で指定するため利用には注意が必要である．ドキュメントにも利用するときの注意点がしっかり書かれている．例えば，値の取り出しには専用のメソッド/関数を準備してちゃんとした型として値を返すようにする，キーは公開しないなどである．&lt;/p&gt;

&lt;p&gt;またどのような値を渡すべきかに関しては&lt;a href=&#34;http://peter.bourgon.org/go-kit/&#34;&gt;go-kit&lt;/a&gt;の開発者である&lt;a href=&#34;https://twitter.com/peterbourgon&#34;&gt;Peter Bourgo&lt;/a&gt;氏のブログが非常に参考になる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://peter.bourgon.org/blog/2016/07/11/context.html&#34;&gt;context&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;標準パッケージの中のcontext&#34;&gt;標準パッケージの中のcontext&lt;/h2&gt;

&lt;p&gt;先にも述べたようにGo1.7ではいくつかの標準パッケージで&lt;code&gt;context&lt;/code&gt;パッケージを使ったメソッド/関数が実装された．実装されたのは&lt;code&gt;net&lt;/code&gt;と&lt;code&gt;net/http&lt;/code&gt;，そして&lt;code&gt;os/exec&lt;/code&gt;である．それぞれ簡単に紹介する．&lt;/p&gt;

&lt;h3 id=&#34;net&#34;&gt;net&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;net&lt;/code&gt;パッケージには&lt;code&gt;Dialer&lt;/code&gt;に新たに&lt;code&gt;DialContext()&lt;/code&gt;メソッドが追加された．これは既存の&lt;code&gt;Dial()&lt;/code&gt;メソッドに&lt;code&gt;context.Context&lt;/code&gt;を渡せるようにしたメソッドである．例えば以下のように使うことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
defer cancel()

var dialer net.Dialer
conn, err := dialer.DialContext(ctx, &amp;quot;tcp&amp;quot;, &amp;quot;google.com:80&amp;quot;)
if err != nil {
    log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;net-http&#34;&gt;net/http&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;net/http&lt;/code&gt;には&lt;code&gt;Request&lt;/code&gt;に新たに&lt;code&gt;Context()&lt;/code&gt;メソッドと&lt;code&gt;WithContext()&lt;/code&gt;メソッドが追加された．&lt;code&gt;Context()&lt;/code&gt;はそのリクエストにおける&lt;code&gt;context.Context&lt;/code&gt;を取得するために，&lt;code&gt;WithContext()&lt;/code&gt;は変更に用いる．&lt;/p&gt;

&lt;p&gt;Clientとしては以下のようにリクエストのキャンセルに使うことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;req, err := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;http://google.com&amp;quot;, nil)
if err != nil {
    log.Fatal(err)
}

ctx, cancel := context.WithTimeout(req.Context(), 100*time.Millisecond)
defer cancel()

req = req.WithContext(ctx)

client := http.DefaultClient
res, err := client.Do(req)
if err != nil {
    log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サーバーとしては以下のように&lt;code&gt;context.WithValue()&lt;/code&gt;を用いて各リクエストのスコープに限定した値の受け渡しなどに使うことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;const tokenKey = &amp;quot;tokenKey&amp;quot;

func withAuth(a Authorizer next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        auth := r.Header.Get(&amp;quot;Authorization&amp;quot;)
        token := a.Auth(auth)
        
        ctx := r.Context()
        ctx = context.WithValue(ctx, tokenKey, token)
        next.ServeHTTP(w, r.WithContext(ctx))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;またデフォルトで&lt;code&gt;ServerContextKey&lt;/code&gt;と&lt;code&gt;LocalAddrContextKey&lt;/code&gt;というキーでリクエストの&lt;code&gt;context.Context&lt;/code&gt;にそれぞれ&lt;code&gt;*http.Server&lt;/code&gt;と&lt;code&gt;net.Addr&lt;/code&gt;の値がセットされておりそれを使うこともできる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    srv := ctx.Value(ServerContextKey)
    ....
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;os-exec&#34;&gt;os/exec&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;os/exec&lt;/code&gt;には&lt;code&gt;CommandContext()&lt;/code&gt;関数が追加された．これは既存の&lt;code&gt;Command()&lt;/code&gt;関数に&lt;code&gt;context.Context&lt;/code&gt;を渡せるようにした関数である．例えば以下のように使うことができる&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;cmd := exec.CommandContext(ctx, &amp;quot;sleep&amp;quot;, &amp;quot;2&amp;quot;)
if err := cmd.Run(); err != nil {
    log.Fatal(err) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;context.Context&lt;/code&gt;が終了すると&lt;code&gt;os.Process.Kill&lt;/code&gt;が実行される．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;は&lt;code&gt;net&lt;/code&gt;関連で主に使われてきたが，そうではない場合であってもタスクにDeadlineやTimeout，Cancelを持たせるための標準的なインターフェースに利用可能であることを示す良い例である．&lt;/p&gt;

&lt;h2 id=&#34;context-leakを避ける&#34;&gt;Context leakを避ける&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;WithCancel&lt;/code&gt;や&lt;code&gt;WithTimeout&lt;/code&gt;，&lt;code&gt;WithDeadline&lt;/code&gt;で返される&lt;code&gt;cancel&lt;/code&gt;が呼ばれないと，その親&lt;code&gt;Context&lt;/code&gt;が&lt;code&gt;cancel&lt;/code&gt;されるまでその子&lt;code&gt;Context&lt;/code&gt;がLeakする（context leak）．Go1.7からの&lt;code&gt;go vet&lt;/code&gt;はそれを検出する（&lt;code&gt;-lostcancel&lt;/code&gt;）．例えば以下のような出力が得られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func leak() {
    var ctx, cancel = context.WithCancel() 
    // the cancel function is not used on all paths 
    // (possible context leak)
    
    // this return statement may be reached 
    // without using the cancel var defined on line x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://go-review.googlesource.com/#/c/24150/13/src/cmd/vet/testdata/lostcancel.go&#34;&gt;こちらの変更&lt;/a&gt;を見ると別の検出パターンもわかる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;どんどん使っていきましょう．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tip.golang.org/doc/go1.7&#34;&gt;Go 1.7 Release Notes DRAFT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dahernan.github.io/2015/02/04/context-and-cancellation-of-goroutines/&#34;&gt;Context and Cancellation of goroutines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://talks.golang.org/2014/gotham-context.slide#1&#34;&gt;Cancelation, Context, and Plumbing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39#.im1d1tr4r&#34;&gt;How to correctly use context.Context in Go 1.7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GopherCon 2016でLTした</title>
      <link>http://deeeet.com/writing/2016/07/12/gophercon2016-lt/</link>
      <pubDate>Tue, 12 Jul 2016 19:04:47 -0600</pubDate>
      
      <guid>http://deeeet.com/writing/2016/07/12/gophercon2016-lt/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://gophercon.com/&#34;&gt;GopherCon 2016&lt;/a&gt;でLTをした．&lt;a href=&#34;https://twitter.com/tenntenn&#34;&gt;@tenntenn&lt;/a&gt;さんがやった通常トーク（50分）はなかなかハードルが高いがLTは初めの一歩として良いと思う．来年もDenverで再び開催されることがアナウンスされているので来年以降に発表するひとのためにどんな感じだったかを簡単に書いておく．&lt;/p&gt;

&lt;h2 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/tcnksm/talks/2016/07/gophercon/gophercon.slide#1&#34;&gt;発表スライド&lt;/a&gt;を見てもらえばわかるが特に新しい話をしたわけではない．日本のミートアップなどで話したこと，ブログに書いたことを英語にしただけにすぎない（ただ実演デモをするという挑戦はした）．&lt;/p&gt;

&lt;p&gt;「大御所たちと同じステージで喋る機会を逃すのはもったいない」（ちなみに当日のLTは僕の次が&lt;a href=&#34;https://twitter.com/robertgriesemer&#34;&gt;Robert Griesemer&lt;/a&gt;氏でその次が&lt;a href=&#34;https://twitter.com/bradfitz&#34;&gt;Brad Fitzpatrick&lt;/a&gt;氏だった！），「日本のGo界隈にこんなやつおるでってのを知ってもらいたい」というモチベーションで発表した．あとなんとなく自分の中でここでぶっ込まないと一生逃げると思ったのもある（通常セッションにしろやって話だが50分喋る良いネタがなかった..）．&lt;/p&gt;

&lt;h2 id=&#34;流れ&#34;&gt;流れ&lt;/h2&gt;

&lt;p&gt;まずLTセッションの募集は会議開催の10日前ほどにアナウンスされた（&lt;a href=&#34;https://blog.gopheracademy.com/gophercon-2016/gophercon2016-lightning-announce/&#34;&gt;&amp;ldquo;GopherCon 2016 - Lightning Talk Annoucement&amp;rdquo;&lt;/a&gt;）．逃さないためにはtwitterの&lt;a href=&#34;https://twitter.com/gophercon&#34;&gt;@GopherCon&lt;/a&gt;や&lt;a href=&#34;https://invite.slack.golangbridge.org/&#34;&gt;Gophers slack&lt;/a&gt;をちゃんとウォッチしておくと良い．&lt;/p&gt;

&lt;p&gt;CFPは&lt;a href=&#34;https://www.papercall.io/gophercon-lightning-talks-2016&#34;&gt;PaperCall&lt;/a&gt;で行われた．タイトルや発表内容をちゃんと書く．&lt;/p&gt;

&lt;p&gt;結果の発表は開催前日に，発表日は通常会議の初日に，発表順は当日その場で発表された．そのため資料の準備と練習の時間はほとんどない．飛行機での移動中などに形だけ資料を完成させ会議の合間に練習するしかない．また事前にディスプレイの接続チェックなどはできないので特殊なことはしないほうがよい．&lt;/p&gt;

&lt;p&gt;発表場所は上の写真のメインルーム．発表時間は6分で，質疑応答は次の発表者の準備が完了するまで行われた．&lt;/p&gt;

&lt;p&gt;LTセッションは通常会議が行われた2日間両方で行われ，発表人数はそれぞれ12名だった．他の発表や自分の発表を考えると採択率は高いと感じた（直前なので申し込む人が少なかったのかもしれない）．&lt;/p&gt;

&lt;p&gt;この流れは来年変わるかもしれないし変わらないかもしれない．もし来年移行挑戦する人がいればぜひ参考にしてください．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;偉そうに書いたが採択されてからひたすら緊張し「聴衆として普通に楽しむだけにすればよかった」と何度も思った．ただ終わってみればやってよかったという気持ちしかない（&lt;a href=&#34;https://twitter.com/___leigh___/status/753005029993381896&#34;&gt;こういうリプライ&lt;/a&gt;もらえたり，終わった後に議論できて良かった）．機会があるひとはどんどん挑戦しましょう．&lt;/p&gt;

&lt;p&gt;ちなみに通常セッションのトークは以下が最高だったのでビデオが公開されたら全部観ましょう．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Understanding nil&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Navigating Unfamiliar Code with the Go Guru&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go for Data Science&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Visualizing Concurrency in Go&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go for Crypto Developers&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Inside the Map Implementation&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go Without the Operating System&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The Design of the Go Assembler&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;cgo: Safely Taming the Beast&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golangの新しいGCアルゴリズム Transaction Oriented Collector（TOC）</title>
      <link>http://deeeet.com/writing/2016/06/29/toc/</link>
      <pubDate>Wed, 29 Jun 2016 10:31:00 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/06/29/toc/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://golang.org/s/gctoc&#34;&gt;http://golang.org/s/gctoc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Goの新しいGCのProposalが出た．まだProposal段階であり具体的な実装はないが簡単にどのようなものであるかをまとめておく．&lt;/p&gt;

&lt;p&gt;GoのGCはGo1.5において単純なStop The World（STW）からConcurrent Mark &amp;amp; Sweepへと変更され大きな改善があった（詳しくは&lt;a href=&#34;http://deeeet.com/writing/2016/05/08/gogc-2016/&#34;&gt;&amp;ldquo;GolangのGCを追う&amp;rdquo;&lt;/a&gt;に書いた）．先の記事に書いたようにGo1.5におけるGCの改善は主にレイテンシ（最大停止時間）に重きが置かれいた．数値目標として10msが掲げられGo1.6においては大きなヒープサイズ（500GB）においてそれを達成していた．&lt;/p&gt;

&lt;p&gt;GCの評価項目はレイテンシのみではない．スループットやヒープの使用効率（断片化の対処）なども重要である．Go1.6までのGCではそれらについて大きく言及されていなかった（と思う）．例えばスループットに関してはハードウェアの進化がそれを改善するはずであるという前提が置かれていた（&lt;a href=&#34;https://blog.golang.org/go15gc&#34;&gt;&amp;ldquo;Go GC: Prioritizing low latency and simplicity&amp;rdquo;&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;今回提案されたTransaction Oriented Collector（TOC）アルゴリズムはGCのスループットを改善するものである．&lt;/p&gt;

&lt;h2 id=&#34;tocアルゴリズムの経験則&#34;&gt;TOCアルゴリズムの経験則&lt;/h2&gt;

&lt;p&gt;Transaction Oriented Collector（TOC）アルゴリズムは「あるTransactionで生成されたオブジェクトはTransactionが終了すると同時にすぐ死ぬことが多い」という経験則に基づくアルゴリズムである．ここでいうTransactionとはいわゆる&lt;a href=&#34;https://en.wikipedia.org/wiki/ACID&#34;&gt;ACID&lt;/a&gt;における不可分な処理単位ではなく，Webサービスなどでリクエスト受けてレスポンスを返すまでの一連の処理を示す．&lt;/p&gt;

&lt;p&gt;この仮定はGenerational GC（世代別GC）が利用している「多くのオブジェクトは生成されてすぐにゴミとなりわずかなオブジェクトだけが長く生き残る」という経験則に似ている．TOCアルゴリズムはこの経験則のGoなりの再解釈のようにも見える．&lt;/p&gt;

&lt;p&gt;このTOCアルゴリズムの経験則はどこから来たか? Goが多くサポートしているCloudアプリケーションである．このようなアプリーションは，他のネットワークや他のGoroutineからメッセージを受け，それをUnmarshalし，それを使い計算をし，結果をMarshalし，それを他のネットワークやGoroutineに投げる．そしてそのGoroutineは死ぬか他のリクエストを受けるために停止状態になる．&lt;/p&gt;

&lt;p&gt;リクエスト中での計算では大きなヒープからデータを読み込むことはあるかもしれないが典型的には書き込みは滅多に起きずヒープはTransaction間で一定になる．そしてGoroutine内で新たにアロケートしたオブジェクトは他のGoroutineに共有される（publish）かもしれないし共有されない（local）かもしれない．TOCアルゴリズムはこの共有されない場合の観測結果を使う，つまり「もしGoroutineがその中でアロケートしたオブジェクトを共有しない場合，そのオブジェクトはGC時に到達不可能になり関連するメモリ領域はすぐにアロケートできる」である．&lt;/p&gt;

&lt;p&gt;TOCアルゴリズムの恩恵を受けるのは&lt;code&gt;net/http#Server&lt;/code&gt;や&lt;code&gt;net/rpc#Server&lt;/code&gt;を使ったアプリケーションであると想像できる．&lt;/p&gt;

&lt;h2 id=&#34;tocアルゴリズムの実装の提案&#34;&gt;TOCアルゴリズムの実装の提案&lt;/h2&gt;

&lt;p&gt;TOCアルゴリズムの実装はProposalの&lt;a href=&#34;https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/edit#heading=h.aqj7hn20fsaw&#34;&gt;Examples&lt;/a&gt;をみるとわかりやすい．&lt;/p&gt;

&lt;p&gt;（まず前提としてGoのGCのMarkはBitmapで管理されている．BitmapはオブジェクトのヘッダにMarkbitを持たせるのではなく関連するメモリ領域をBitのテーブルとして別で集中管理する手法である．これはCopy-On-Writeとの相性が良いなどがある）．&lt;/p&gt;

&lt;p&gt;TOCアルゴリズムでは各Goroutineは2つのPointerをもつ．1つはCurrent Sweep Pointerである．このPointerはどこまでSweepを行ったか（Allocateしたか）を示す．もう1つはInitial Sweep Pointerである．これはそのGoroutine開始時のSweep Pointerを示す．この2つのPointerの間のオブジェクトはMarkされていようがMarkされていまいが「そのGoroutineで新たにアロケートされたオブジェクト」となる．そしてMarkされていないオブジェクトは共有されていない（Publishされていない）オブジェクトであるとする．&lt;/p&gt;

&lt;p&gt;これをどのように実現するか? ライトバリア（Write barrier）を使う．このライトバリアはそのGoroutine内で新たにアロケートされたオブジェクトがInvariantであることを保証する．つまりそのオブジェクトが他に共有されればMarkをつける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;10011110010100101010100001001011010010110100101001011101010111101
　　　　^                 &amp;lt;- before  ^  after -&amp;gt;
　　　　Initial Sweep Pointer        Current Sweep Pointer     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（Proposalの図を拝借させてもらった．1は前回のGCで到達可能であったオブジェクト，もしくはGoroutineで新たにアロケートされそしてPublishされたオブジェクトである．BeforeとInitialの間にある0はアロケートされたがPublishされていないオブジェクトである．Afterにある0はまだアロケートされていないオブジェクトである）&lt;/p&gt;

&lt;p&gt;あとはGoroutine終了時にCurrent Sweep PointerをInitial Sweep Pointerへと戻せば良い．新たにオブジェクトが生成されていようとそれが共有されていなければMarkは立っていないので，次回のGCサイクルを待たずに次回のSweepにおいてアロケートの対象になる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;簡単にGoの新たなGCのProposalを追ってみた．今後の実装とそれによる効果がどうなるかが楽しみである．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GolangでFlame Graphを描く</title>
      <link>http://deeeet.com/writing/2016/05/29/go-flame-graph/</link>
      <pubDate>Sun, 29 May 2016 14:22:17 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/05/29/go-flame-graph/</guid>
      <description>

&lt;p&gt;アプリケーションのパフォーマンス問題の解決やチューニングで大切なのは問題のコアやボトルネックに最短パスで到達することである．&lt;/p&gt;

&lt;p&gt;基本的なパフォーマンス分析の入り口はアプリケーションのスレッドがon-CPUで時間を消費しているかoff-CPUで時間を消費しているかを理解するところから始まる．on-CPUの場合はそれがuserモードかkernelモードかを特定し，さらにCPUプロファイリングによってどのcode pathがCPUを消費しているのかの分析に向かう．off-CPUの場合はI/OやLock，pagingといった問題の分析に向かう．&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;&gt;Flame Graph&lt;/a&gt;はon-CPUでのパフォーマンスの問題が発覚した時に行うCPUプロファイリングを助ける．どのcode pathがボトルネックになっているのかを1つのグラフ上で理解できる．本記事ではFlame Graphとは何か? なぜ必要なのか? を解説しGoのアプリケーションでそれを用いるために方法を解説する．&lt;/p&gt;

&lt;h2 id=&#34;flame-graphとは何か&#34;&gt;Flame Graphとは何か?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;&gt;Flame Graph&lt;/a&gt;はCPUプロファイリング結果をvisualizeしたグラフである．元Joyent，現Netflixの&lt;a href=&#34;http://www.brendangregg.com/index.html&#34;&gt;Brendan Gregg&lt;/a&gt;氏によって開発された．例えば以下はMySQLのCPUプロファイリング結果をFlame Graphで描画したものである．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.brendangregg.com/FlameGraphs/cpu-mysql-filt.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;cpu-プロファイリング&#34;&gt;CPU プロファイリング&lt;/h3&gt;

&lt;p&gt;CPUプロファイリングの共通のテクニックはStack traceのサンプリングである．Stack traceというのは関数コールのリストで，code pathの先祖を追うことができる．例えば，以下はGolangのstack traceで子から親へStackと辿ることができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;syscall.Syscall
syscall.write
syscall.Write
os.(*File).write
os.(*File).Write
log.(*Logger).Output
log.Printf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flame-graphの初期衝動&#34;&gt;Flame Graphの初期衝動&lt;/h3&gt;

&lt;p&gt;CPUプロファイリングの出力は往々にしてverboseである．例えば，Brendan Gregg氏がFlame GraphをつくるきっかけとなったプロダクションのMySQLのプロファイリングの出力は500,000行近くもあったという（&lt;a href=&#34;http://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs/16&#34;&gt;参考画像&lt;/a&gt;&amp;hellip;やばいw）．&lt;/p&gt;

&lt;p&gt;Flame Graphはそのような膨大なCPUプロファイリングを一つのグラフ上で直感的かつ簡単に理解するために開発された．&lt;/p&gt;

&lt;h3 id=&#34;flame-graphの読み方&#34;&gt;Flame Graphの読み方&lt;/h3&gt;

&lt;p&gt;以下はFlame Graphを単純化したものである．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliveryimages.acm.org/10.1145/2930000/2927301/gregg6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stack traceは長方形のボックスの列で表現される．1つ1つのボックスは関数（Stack frame）を示す&lt;/li&gt;
&lt;li&gt;y軸はStackの深さを示す．一番上のボックスはStack traceが収集された時にon-CPUであった関数であり，その下にあるボックスはすべて先祖になる．あるボックスの下にあるボックスはその関数の親である（高いほど悪いわけではない）&lt;/li&gt;
&lt;li&gt;x軸はその関数のSampleの割合を示す．&lt;strong&gt;時間ではない&lt;/strong&gt;．それぞれの関数はアルファベット順にソートされているだけ&lt;/li&gt;
&lt;li&gt;それぞれのボックスの幅はその関数の出現頻度を示す（長いほどStack trace中に多く登場したこと意味する）&lt;/li&gt;
&lt;li&gt;色には特に意味はない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ではこのFlame Graphからどのようなことがわかるか?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Q. 最もon-CPUだったのはどの関数か?

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;g()&lt;/code&gt;（グラフの一番上を見れば良い）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Q. なぜ&lt;code&gt;g()&lt;/code&gt;はon-CPUなのか?

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;a()&lt;/code&gt; -&amp;gt; &lt;code&gt;b()&lt;/code&gt; -&amp;gt; &lt;code&gt;c()&lt;/code&gt; -&amp;gt; &lt;code&gt;e()&lt;/code&gt; -&amp;gt; &lt;code&gt;f()&lt;/code&gt; -&amp;gt; &lt;code&gt;g()&lt;/code&gt;（y軸を見る）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Q. &lt;code&gt;b()&lt;/code&gt;と&lt;code&gt;h()&lt;/code&gt;を比べると?

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;b()&lt;/code&gt;は&lt;code&gt;h()&lt;/code&gt;より多く登場した（およそ5倍）（ボックスの幅を比較する）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Q. なぜ&lt;code&gt;g()&lt;/code&gt;を実行しているのか

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;a()&lt;/code&gt;が&lt;code&gt;b()&lt;/code&gt;を選択し，&lt;code&gt;d()&lt;/code&gt;が&lt;code&gt;f()&lt;/code&gt;を選択したため&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;goでflame-graphを描く&#34;&gt;GoでFlame Graphを描く&lt;/h2&gt;

&lt;p&gt;GoでFlame Graphを描くにはUberの&lt;a href=&#34;https://github.com/uber/go-torch&#34;&gt;go-torch&lt;/a&gt;を使えば良い．Gopherfest Sprint 2016の&lt;a href=&#34;https://github.com/prashantv&#34;&gt;Parashant&lt;/a&gt;氏の発表&lt;a href=&#34;https://www.youtube.com/watch?v=N3PWzBeLX2M&#34;&gt;&amp;ldquo;Profiling and Optimizing Go&amp;rdquo;&lt;/a&gt;でこの&lt;code&gt;go-torch&lt;/code&gt;を使ってパフォーマンスをチューニングする様子が観れる．ライブデモが華麗すぎて感動するので今すぐ観ると良い．&lt;/p&gt;

&lt;h3 id=&#34;goのプロファイリングの基礎&#34;&gt;Goのプロファイリングの基礎&lt;/h3&gt;

&lt;p&gt;Goにはプロファイリングのためのパッケージが標準で準備されている．Webサーバーであれば&lt;code&gt;net/http/pprof&lt;/code&gt;，通常のツールであれば&lt;code&gt;runtime/pprof&lt;/code&gt;を使う．&lt;code&gt;runtime/pprof&lt;/code&gt;についてはRuss Coss氏の&lt;a href=&#34;http://blog.golang.org/profiling-go-programs&#34;&gt;&amp;ldquo;Profiling Go Programs&amp;rdquo;&lt;/a&gt;を読むと良い．ここでは&lt;code&gt;net/http/pprof&lt;/code&gt;を使って解説をする．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;net/http/pprof&lt;/code&gt;を使ってプロファイリングを有効にするのは非常に簡単である．以下をコードに追加すればよい．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;import _ net/http/pprof 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけで&lt;code&gt;/debug/pprof&lt;/code&gt;というエンドポイントが新たに追加される．ここでは現在動いているgoroutineのStackやHeapの状態，GCの実行状況などを確認することができる．&lt;/p&gt;

&lt;p&gt;このエンドポイントを&lt;code&gt;go tool pprof&lt;/code&gt;で解析するには以下のようあコマンドを叩けば良い（&lt;code&gt;go-wrk&lt;/code&gt;などである程度ロードを与えておくと良い）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go tool pprof -seconds 5 http://localhost:9090/debug/pprof/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;するとインタラクティブなモードが始まり，以下のような専用のコマンドでプロファイリング結果を確認できるようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ (pprof) top10
3400ms of 3770ms total (90.19%)
Dropped 60 nodes (cum &amp;lt;= 18.85ms)
Showing top 10 nodes out of 98 (cum &amp;gt;= 30ms)
flat  flat%   sum%        cum   cum%
1680ms 44.56% 44.56%     1680ms 44.56%  syscall.Syscall
1030ms 27.32% 71.88%     1040ms 27.59%  syscall.Syscall6
190ms  5.04% 76.92%      190ms  5.04%  runtime.kevent
140ms  3.71% 80.64%      140ms  3.71%  runtime.indexbytebody
120ms  3.18% 83.82%      120ms  3.18%  runtime.usleep
70ms  1.86% 85.68%       70ms  1.86%  runtime.mach_semaphore_signal
70ms  1.86% 87.53%       70ms  1.86%  runtime.mach_semaphore_wait
50ms  1.33% 88.86%       50ms  1.33%  runtime.memclr
30ms   0.8% 89.66%       30ms   0.8%  net/http.(*ServeMux).match
20ms  0.53% 90.19%       30ms   0.8%  fmt.(*pp).doPrintf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テキストだけではなく，以下のコマンドでグラフ（&lt;code&gt;svg&lt;/code&gt;形式）でプロファイリング結果を表示することもできる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(pprof) web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/pprof.png&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;コードベースが小さければこれだけでも十分強力だが，コードが増えるほどグラフは複雑になり結果を直感的に理解するのが難しくなる．&lt;/p&gt;

&lt;h3 id=&#34;go-torchを使う&#34;&gt;go-torchを使う&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go-torch&lt;/code&gt;を使うには&lt;code&gt;net/http/pprof&lt;/code&gt;によるエンドポイントを有効にしておくだけで良い．そして&lt;code&gt;go tool pprof&lt;/code&gt;を使うのと同じように以下のようなコマンドを叩くだけで&lt;code&gt;.svg&lt;/code&gt;形式のFlame Graphが出力される（&lt;code&gt;go-torch&lt;/code&gt;に加えてBrendan Gregg氏のPerlスクリプト&lt;a href=&#34;https://github.com/brendangregg/FlameGraph&#34;&gt;brendangregg/FlameGraph&lt;/a&gt;をダウンロードして&lt;code&gt;PATH&lt;/code&gt;を通しておく必要がある）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-torch --time 5 --url http://localhost:9090/debug/pprof/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は以下．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/torch.svg&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;（例えば上は単純なWebサーバーの場合である．&lt;code&gt;logRequest&lt;/code&gt;という関数の&lt;code&gt;os.Hostname()&lt;/code&gt;が怪しいのがすぐわかる）&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;グラフの生成はとても簡単なので読み方さえわかればFlame Graphはとても強力である．Flame Graphで問題の原因の大まかなあたりを付け&lt;code&gt;go tool pprof&lt;/code&gt;で詳細な解析をするという流れが良いと思う．&lt;/p&gt;

&lt;p&gt;Flame GraphはJavaやNode，RubyといったVM言語でも使うことができる．またCPUだけではなくてMemoryやIOのプロファイルにも利用することができる．気になる人はいろいろ漁ってみると良さそう．&lt;/p&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/Systems-Performance-Enterprise-Brendan-Gregg-ebook/dp/B00FLYU9T2&#34;&gt;&amp;ldquo;Systems Performance: Enterprise and the Cloud&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://queue.acm.org/detail.cfm?id=2927301&#34;&gt;The Flame Graph - ACM Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs&#34;&gt;Blazing Performance with Flame Graphs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Known unknowns</title>
      <link>http://deeeet.com/writing/2016/05/24/known-unknowns/</link>
      <pubDate>Tue, 24 May 2016 08:07:56 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/05/24/known-unknowns/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.amazon.co.jp/Systems-Performance-Enterprise-Brendan-Gregg-ebook/dp/B00FLYU9T2&#34;&gt;&amp;ldquo;Systems Performance: Enterprise and the Cloud&amp;rdquo;&lt;/a&gt; をずっと読んでいる．この本はNetflixの&lt;a href=&#34;http://www.brendangregg.com/&#34;&gt;Brendan Gregg&lt;/a&gt;氏がJoyent時代に書いた本である．その名の通りLinux（とSolaris）のシステムのパフォーマンスの本である（とにかく一つ一つが丁寧かつ深く解説されておりページをめくるごとに学びしかないのでパフォーマンスに関わるひとは今すぐ読むと良い）．&lt;/p&gt;

&lt;p&gt;この本で一貫して現れてくる，通底するのが，known-knowns，known-unknownsそしてunknown-unknownsという概念である．元ネタは&lt;a href=&#34;https://en.wikipedia.org/wiki/Donald_Rumsfeld&#34;&gt;Donald Rumsfeld&lt;/a&gt; 氏の会見でのコメントだが（cf. &lt;a href=&#34;https://en.wikipedia.org/wiki/There_are_known_knowns&#34;&gt;There are known knowns&lt;/a&gt;），複雑なシステムのパフォーマンスの重要な原則を集約している．良い概念なので簡単に紹介する．&lt;/p&gt;

&lt;p&gt;それぞれをパフォーマンスの観点から説明すると以下のようになる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;known-knowns&lt;/strong&gt; - 知っていること．そのパフォーマンスのメトリクスをチェックするべきことを知っているし，現在の値も知っている．例えば，CPUの利用率をチェックするべきことを知っているし，その平均的な値が10%であることも知っている&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;known-unknowns&lt;/strong&gt; - 「知らないこと」を知っていること．そのパフォーマンスのメトリクスをチェックできること，そのようなサブシステムが存在してることを知っているが，まだそれらを観測したことがない（知らない）．例えば，profilingによって何がCPUを使いまくっているのかチェックできるのを知っているけどまだそれを実施してない．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unknown-unknowns&lt;/strong&gt; - 「知らないこと」を知らないこと．例えば，デバイス割り込みがCPUを多く消費することを知らず，そのためチェックしてないかもしれない．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;パフォーマンスというのは「知れば知るほど知らないことが増える」という分野である．システムについて学べば学ぶほど，unknown-unknownsに気づき，それはknown-unknownになり，次回からはそれをチェックできるようになる．&lt;/p&gt;

&lt;p&gt;そしてこれはパフォーマンスに限った話ではない．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GolangのGCを追う</title>
      <link>http://deeeet.com/writing/2016/05/08/gogc-2016/</link>
      <pubDate>Sun, 08 May 2016 23:01:06 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/05/08/gogc-2016/</guid>
      <description>

&lt;p&gt;Go1.5とGo1.6でGoのGCのレイテンシが大きく改善された．この変更について「ちゃんと」理解するため，アルゴリズムレベルでGoのGCについて追ってみた．&lt;/p&gt;

&lt;p&gt;まずGoのGCの現状をパフォーマンス（レイテンシ）の観点からまとめる．次に具体的なアルゴリズムについて，そして最後に実際の現場でのチューニングはどうすれば良いのかについて解説する．&lt;/p&gt;

&lt;h2 id=&#34;goのgcの今&#34;&gt;GoのGCの今&lt;/h2&gt;

&lt;p&gt;最初にGoのGCの最近の流れ（2016年5月まで）をまとめる．&lt;/p&gt;

&lt;p&gt;Go1.4までは単純なStop The World（STW）GCが実装されていたがGo1.5からは新たなGCアルゴリズムが導入された．導入の際に設定された数値目標は大きなヒープサイズにおいてもレイテンシを10ms以下に抑えることであった．Go1.5で新たなアルゴリムが実装されGo1.6で最適化が行われた．&lt;/p&gt;

&lt;p&gt;以下は公開されているベンチマーク．まずはGo1.5を見る．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.github.com/tcnksm/talks/master/2016/02/go1.6/img/go15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=aiv1JOfMjm0&#34;&gt;GopherCon 2015: Rick Hudson - Go GC: Solving the Latency Problem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;グラフの横軸はヒープサイズで縦軸はレイテンシである（小さいほどよい）．以前のバージョンと比較するとヒープの増加に伴ってレイテンシが3.0sを超えていたのがほぼ0sに抑えらているのがわかる．コミュニティからも以下のようなベンチマークが公開されている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/brianhatfield/status/634166123605331968&#34;&gt;https://twitter.com/brianhatfield/status/634166123605331968&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@robin.verlangen/billions-of-request-per-day-meet-go-1-5-362bfefa0911#.vyckzy74d&#34;&gt;Billions of request per day meet Go 1.5&lt;/a&gt; (The new version of Go reduces our 95-percentile garbage collector from 279 milliseconds down to just 10 ms)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次に以下はGo1.6のベンチマーク．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.github.com/tcnksm/talks/master/2016/02/go1.6/img/go16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/presentations/go-gc-performance&#34;&gt;QCon: Go GC: Prioritizing Low Latency and Simplicity&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;縦軸と横軸はGo1.5と同じ．まずGo1.5のグラフと比べると10倍のヒープサイズでベンチマークが行われているのがわかる．Go1.5が50GBに達する前にレイテンシが増大しているのに対してGo1.6は250GBのヒープに対しても10msのレイテンシで抑えらているのが確認できる．&lt;/p&gt;

&lt;p&gt;Go1.7のリリースが近いが，既に今までと同じくTwitterの&lt;a href=&#34;https://twitter.com/brianhatfield&#34;&gt;@brianhatfield&lt;/a&gt;氏がCanaryテストを行い，さらにGCのレイテンシが改善されたことが報告されている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-dev/n-D2RYU4nIs&#34;&gt;Go 1.7 observed performance changes (production canary@eeca3ba)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらのアップデートからGoにおいてGCのレイテンシは大規模プロダクション環境においても全く問題にならないレベルになっていることがわかる．つまりパフォーマンスに問題があったときに疑うべき場所としては優先度は低いと言える．&lt;/p&gt;

&lt;p&gt;以下ではこれらをどのように達成したのかを追っていく．&lt;/p&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;まず最初に筆者はGCに関してはほぼ初心者であった．GoのGCを少しでも「ちゃんと」理解したいがために勉強したにすぎない．そのためGCの知識は素人に毛が生えた程度でしかない．先に参考文献やリンクをまとめておくので，気になるひとは自分でそれらを追ってみるのが良い．&lt;/p&gt;

&lt;p&gt;まずGCの基礎については以下の書籍が勉強になった．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tatsu-zine.com/books/gcbook&#34;&gt;ガベージコレクションのアルゴリズムと実装&lt;/a&gt; - とにかく初心者はまずこれを読むのが良い．本書はアルゴリズム編と実装編に分かれている．アルゴリズム編では基本となるアルゴリズムが図解と疑似コードで丁寧に解説されておりGCの基礎を抑えることができる．中で述べられているようにGCの基本はGCが登場して50年たってもそれほど変わっていないのでこれらを抑えるだけでもだいぶ話に入っていける．実装編では実際のruntime例えばPythonやV8などをのコードを追っていく．これで「GCのコードの追い方」がなんとなくわかった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B01CYDGUT0&#34;&gt;ガベージコレクション&lt;/a&gt; - こちらは最近（2016年3月）発売されたばかりの本．先に上げた「ガベージコレクションのアルゴリズムと実装」がカジュアルな本であるのに対してこちらは膨大なGC研究がまとめられておりより硬派な本であると言える．基礎アルゴリズムから説明していくのは同じであるが本書は並列・並行処理/マルチコア時代のことが意識されているのが特徴的である．Goで採用されているConcurrent GCはこちらで学んだ．また参照局所性といったハードウェアに対する言及も多い&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次にGoのGCそのものについての解説は以下のRick Hudson氏の一連の発表及びブログ，デザインノートを見るとよい．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=aiv1JOfMjm0&#34;&gt;GopherCon 2015: Rick Hudson - Go GC: Solving the Latency Problem&lt;/a&gt; (&lt;a href=&#34;https://talks.golang.org/2015/go-gc.pdf&#34;&gt;slide&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/go15gc&#34;&gt;Go GC: Prioritizing low latency and simplicity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/16Y4IsnNRCN43Mx0NZc5YXZLovrHvvLhK_h0KN8woTO4&#34;&gt;Go 1.4+ Garbage Collection (GC) Plan and Roadmap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GopherConとQconの内容は基本的に同じだが後者はGo1.6に関するアップデートを幾つか含んでいる．&lt;/p&gt;

&lt;p&gt;以下の論文が参考として挙げられている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://research.microsoft.com/en-us/um/people/lamport/pubs/garbage.pdf&#34;&gt;On-the-Fly Garbage Collection: An Exercise in Cooperation&lt;/a&gt; - 基礎となったアルゴリズムについて述べた論文&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;ftp://ftp.cs.umass.edu/pub/osl/papers/sapphire-2003.pdf&#34;&gt;Sapphire: Copying GC Without Stopping the World&lt;/a&gt; - 上記のアルゴリズムの正確さと完全性，GCが「終了すること」を示した論文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また&lt;a href=&#34;https://golang.org/pkg/runtime/&#34;&gt;runtime package&lt;/a&gt;のソースコード（&lt;code&gt;mgc.go&lt;/code&gt;）にも具体的な実装の解説がコメントで書かれているので参考になる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/mgc.go&#34;&gt;https://golang.org/src/runtime/mgc.go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;またGo1.4以前のGCの歴史はstackovwerflowに良い回答があったのでそちらを見ると良い．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/7823725/what-kind-of-garbage-collection-does-go-use/7824353#7824353&#34;&gt;What kind of Garbage Collection does Go use?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下はこれらを自分の言葉で整理し直したものである．&lt;/p&gt;

&lt;h2 id=&#34;ハードウェアの進化とソフトウェアの進化&#34;&gt;ハードウェアの進化とソフトウェアの進化&lt;/h2&gt;

&lt;p&gt;Rick Hudson氏が発表でもブログでも述べていたことだが，GoのGCは現在だけではなくて10年後も使えるものを目指している．ハードウェアの進化を見据えてソフトウェアを改善している．&lt;/p&gt;

&lt;p&gt;今回のGoのGCの変更で仮定されているのは「将来のハードウェアがGCのスループットを改善する」である．そのためGCが目指したのはレイテンシの改善である（レイテンシのためにスループットを犠牲にされている）．&lt;/p&gt;

&lt;h2 id=&#34;goのgcアルゴリズム&#34;&gt;GoのGCアルゴリズム&lt;/h2&gt;

&lt;p&gt;Go1.5以降のGCアルゴリズムはConcurrent Mark &amp;amp; Sweepである．GC中のオブジェクトの状態の表現にはTri-color markig（三色マーキング）を用いている．&lt;/p&gt;

&lt;h3 id=&#34;mark-sweep&#34;&gt;Mark &amp;amp; Sweep&lt;/h3&gt;

&lt;p&gt;まずMark &amp;amp; Sweepについて説明する．Mark &amp;amp; Sweepは基礎中の基礎のGCアルゴリズムである．アルゴリズムはその名前の通りMarkとSweepという2つのフェーズに分けられる．まずMarkフェーズではルートを起点にポインタを辿りオブジェクトにマークをつけていく．次にSweepフェーズではマークが付けられていないオブジェクトをフリーリストに追加していく．フリーリストに追加された領域は次回のアロケーションで利用可能になる．&lt;/p&gt;

&lt;p&gt;つまりMark &amp;amp; Sweepではルートから到達可能なオブジェクトを生きているオブジェクトとし到達不可能なオブジェクトを死んでいると判別し回収する．オブジェクトがミューテータ（アプリケーション）に実際に使われているか?  といった判別は行わない（つまり全く使われていないにもかかわらずルートから到達できればオブジェクトは掃除されることはない）．&lt;/p&gt;

&lt;h3 id=&#34;gcはなぜ問題になるのか&#34;&gt;GCはなぜ問題になるのか?&lt;/h3&gt;

&lt;p&gt;こう見るとGCは非常に単純に見える．しかしGCは多くのアプリケーションで大きな問題になる．それはStop The World（STW），つまりミューテータの実行を止めること，が必要になるからである．なぜならミューテータはGCがオブジェクトが生きているか死んでいるかを判断している間にヒープのトポロジを変更してしまうからである．&lt;/p&gt;

&lt;p&gt;例えば，GCの途中にミューテータが新たにアロケーションを行ってしまった場合を考える．するとそのオブジェクトはマークされず，生きているのにもかかわらずSweepの対象になってしまうかもしれない．これは大きなバグになる．GCの正確さを保証するためにはミューテータとコレクタの動作を同期させる必要がある．&lt;/p&gt;

&lt;p&gt;この同期のための最も単純な戦略はGCを行っている間はミューテータを完全に止めてしまう方法である．しかしこれではアプリケーションはまともなサービスを提供できなくなる．例えばWebアプリケーションにおいてはしばらくレスポンスを返せないなどといった状況が発生してしまうかもしれない．GCの研究においてSTWをいかに短くするか，レイテンシをいかに小さくするか，もしくは避けるか，は大きな分野である（他には断片化をいかに少なくしてヒープの使用効率を良くするかといった方向もある）．&lt;/p&gt;

&lt;p&gt;Go1.4以前のGCはこの単純なSTWであり，レイテンシが大きな問題になっていた．以下で説明する，Tri-color markingやConcurrent GCはSTWを減らし，レイテンシを改善するための方法である．&lt;/p&gt;

&lt;h3 id=&#34;tri-color-marking&#34;&gt;Tri-color marking&lt;/h3&gt;

&lt;p&gt;一度にGCのプロセスを全て実行するのではなく，GCの実行を分割し，ミューテータと交互に実行させることでレイテンシを小さくすることができる．このように実行するGCをインクリメンタルGCと呼ぶ．Tri-color marking（三色マーキング）は，インクリメンタルGCを可能にするためのオブジェクトの抽象化である．&lt;/p&gt;

&lt;p&gt;Tri-color markingはその名の通りGC中のオブジェクトを状態に応じて以下の3種類に分類する．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;白 - まだ探索されていないオブジェクト&lt;/li&gt;
&lt;li&gt;グレー - 探索途中のオブジェクト&lt;/li&gt;
&lt;li&gt;黒 - 探索済みのオブジェクト&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mark &amp;amp; SweepをTri-color markingを使ってインクリメンタルに実行すると以下の3つのフェーズに分けることができる．GCの開始時点では全てのオブジェクトの色は白である．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ルートスキャンフェーズ - ルートから直接参照可能なオブジェクトをグレーに塗る&lt;/li&gt;
&lt;li&gt;マークフェーズ - グレーのオブジェクトを取り出し，その子オブジェクトをグレーに塗る．全ての子オブジェクトがグレーに塗られたらそのオブジェクトは黒に塗られる&lt;/li&gt;
&lt;li&gt;スイープフェーズ - ヒープ領域をスキャンし白いオブジェクトを死んでいるオブジェクトであると判別してフリーリストに連結する．また黒いオブジェクトは白色に戻す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ルートスキャンフェーズはGCの開始時に一度だけ実行される．マークフェーズでは，全てのグレーオブジェクトを一度に全て処理するのではなく，一定個数だけ処理して中断し，ミューテータの実行を再開する．これを繰り返しグレーのオブジェクトがなくなるまでこのフェーズを続ける．スイープフェーズもヒープを一括でスキャンするのではなく順次スキャンする．ミューテーターは，ルートスキャンフェーズとマークフェーズの間，マークフェーズの間，そしてスイープフェーズの間に実行が再開される．&lt;/p&gt;

&lt;h3 id=&#34;ライトバリア&#34;&gt;ライトバリア&lt;/h3&gt;

&lt;p&gt;マークフェーズを中断しミューテータを再開する場合を考える．この時に何も考慮しないと問題が発生する．&lt;/p&gt;

&lt;p&gt;例えば，ミューテータを再開した際に，グレーのオブジェクトAから参照された白いオブジェクトBがあるとする．ミューテータがこのオブジェクトBを別の黒いオブジェクトCから参照するようにポインタを更新し，かつオブジェクトAからの参照を削除してしまったとする．このままマークフェーズが再開するとどうなるか? 黒いオブジェクトCは「探索済み」である．よってオブジェクトCは再びスキャンされることはない．新たに参照された白いオブジェクトBもスキャンされることはなく「マーク漏れ」が発生する．つまり生きいるのに回収されるという大きな問題が発生してしまう．&lt;/p&gt;

&lt;p&gt;この「マーク漏れ」（オブジェクトの迷子）が発生するのは以下の2つの条件が成立する時である．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ミューテータが白いオブジェクトへのポインタを黒いオブジェクトに書き込む&lt;/li&gt;
&lt;li&gt;すべてのグレーのオブジェクトから，その白いオブジェクトへの経路が削除される&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを防ぐのがライトバリアである．ライトバリアはGenerational GC（世代別GC）などでも使われる手法である．インクリメンタルGCのライトバリアはいくつか提案されている．Dijkstraによって提案された手法では「新たに参照されるオブジェクトが白いオブジェクトであればそれをグレーとする」．上の例だと，白いオブジェクトBを黒いオブジェクトCから参照するときにオブジェクトBをグレーにする．こうすることでBの「マーク漏れ」を防ぐことができる．&lt;/p&gt;

&lt;p&gt;インクリメンタルGCによりミューテータの実行を長時間妨げることはなくなり，レイテンシは大きく改善できる．しかし，このライトバリアによってオーバーヘッドを避けることができない．よってスループットを犠牲にする必要がある．&lt;/p&gt;

&lt;h3 id=&#34;concurrent-mark-sweep&#34;&gt;Concurrent Mark &amp;amp; Sweep&lt;/h3&gt;

&lt;p&gt;これらをConcurentに実行しているのがGoのGCである．並行への移行は単純なステップである．新たに加わる困難はコレクタとミューテータが適切に同期してヒープの一貫したビューを維持することである．&lt;/p&gt;

&lt;p&gt;GoはそれぞれのOSスレッド上にスケジューリングのコンテキストを持つ．このコンテキストはGoroutineのためのローカルのスケジューラであるとみなせ，&lt;code&gt;runtime&lt;/code&gt;のコードではPと呼ばれる（詳しくは&lt;a href=&#34;https://morsmachine.dk/go-scheduler&#34;&gt;&amp;ldquo;The Go scheduler&amp;rdquo;&lt;/a&gt; がわかりやすい）．GCにおいては，フェーズ（スキャンフェーズなど）が変わるたびに，すべてのPからのackを待つことで複数のスレッド間の同期を行っている．&lt;/p&gt;

&lt;p&gt;GCは終了することが重要である．Concurrent GCではミューテータがGCプロセスと同時に動くためオブジェクトは次々に新たにアロケートされていく．このためマークフェーズが収束しない可能性がある．これを解決するためにGoではマークフェーズ後に&lt;code&gt;marktermination&lt;/code&gt;フェーズが存在する．ここでは新たなオブジェクトは全て黒色でアロケートされる．これによりGCは収束に向かう．&lt;/p&gt;

&lt;h2 id=&#34;gogc-goのgcをチューニングする&#34;&gt;GOGC（GOのGCをチューニングする）&lt;/h2&gt;

&lt;p&gt;GCというとJavaのようなたくさんのチューニングパラメーター（&lt;code&gt;xms&lt;/code&gt;や&lt;code&gt;xmx&lt;/code&gt;）を思い浮かべる．Goにはただ1つの&lt;code&gt;GOGC&lt;/code&gt;という環境変数がGCをチューニングするパラメーターとして提供されている．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GOGC&lt;/code&gt;はGoにおける最も古い環境変数の1つである（&lt;a href=&#34;http://dave.cheney.net/2015/11/29/a-whirlwind-tour-of-gos-runtime-environment-variables&#34;&gt;A whirlwind tour of Go&amp;rsquo;s runtime environment variables&lt;/a&gt;）．この環境変数はGCのAggressivenessを決める．&lt;/p&gt;

&lt;p&gt;デフォルト値は&lt;code&gt;100&lt;/code&gt;である．これはある時点でのGC完了後に到達可能であったオブジェクトのサイズよりも100%，つまり2倍大きなヒープサイズが消費されたら次のGCを実行するという意味である．&lt;/p&gt;

&lt;p&gt;どのようにチューニングするか? まずより大きな値，例えば&lt;code&gt;200&lt;/code&gt;をセットする．これはある時点でのGC完了後に到達可能であったあったオブジェクトのサイズよりも200%，つまり3倍のヒープサイズが消費されたら次のGCを実行するという意味である．つまりGCの実行を遅らせることができる．RAMに余裕がありGCに使われる合計時間を減らしたい（スループットを向上させたい）場合は大きな値を設定する．．&lt;/p&gt;

&lt;p&gt;次により小さな値を設定するとGCの実行間隔が短くなる．メモリの使用量を少なくしたい場合は小さな値を設定する（&lt;code&gt;off&lt;/code&gt;を設定するとGCは実行されなくなる）．&lt;/p&gt;

&lt;p&gt;GoのGCはハードウェアの進化が考慮されているのであった．もしハードウェアが進化してRAMの容量が2倍なったらどうするか．&lt;code&gt;GOGC&lt;/code&gt;の値を2倍にすればGCのサイクルを半分にすることができ，チューニングなしでアプリケーションを簡単にスケールさせることができる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;GoのGCの変更について追ってみた．追ってみて他の言語と比べてもシンプルなGCが実装されているなあと感じた．そのためアルゴリズムなどを理解するのは容易だった．シンプルさの思想がGCにもあるのは良いなあと感じた．&lt;/p&gt;

&lt;p&gt;GCにはレイテンシやスループット以外にも解決するべき問題がある．例えばGoの場合は断片化の問題などは考慮されていない．今後その他の問題にどのように対処していくのかも楽しみになった．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golangのエラー処理とpkg/errors</title>
      <link>http://deeeet.com/writing/2016/04/25/go-pkg-errors/</link>
      <pubDate>Mon, 25 Apr 2016 09:00:22 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/04/25/go-pkg-errors/</guid>
      <description>

&lt;p&gt;GoConでは毎回エラー処理について面白い知見が得られる．&lt;a href=&#34;http://gocon.connpass.com/event/9748/&#34;&gt;Go Conference 2014 autumn&lt;/a&gt; においては（実際のトークではないが）居酒屋にて&lt;a href=&#34;https://twitter.com/jxck_&#34;&gt;@Jxck&lt;/a&gt;さんがRob Pike氏から以下のようなテクニックを紹介してもらっていた．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;Errors are values - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/golang-error-handling-lesson-by-rob-pike&#34;&gt;Golang Error Handling lesson by Rob Pike&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これはWrite（やRead）のエラー処理が複数続く場合に&lt;code&gt;errWriter&lt;/code&gt; を定義して複数のエラー処理を一箇所にまとめてコードをすっきりとさせるテクニックであった．&lt;/p&gt;

&lt;p&gt;そして今回の &lt;a href=&#34;http://gocon.connpass.com/event/27521/&#34;&gt;Go Conference 2016 spring&lt;/a&gt; のkeynoteにおいてもDave Cheney氏から（僕にとっては）新たなエラー処理テクニックが紹介された．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dave.cheney.net/paste/gocon-spring-2016.pdf&#34;&gt;Gocon Spring 2016&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際に使ってみて/コードを読んでみて（飲み会でもコードとともにいろいろ教えてもらった）自分の抱えている問題を解決できそうで使ってみたいと思えた．&lt;/p&gt;

&lt;p&gt;本記事では現在のエラー処理の問題と発表で紹介された&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;pkg/errors&lt;/a&gt;についてまとめる．なお上記のスライドにはトークノートも書かれているので具体的な内容はそちらを見るのが良い．&lt;/p&gt;

&lt;h2 id=&#34;問題&#34;&gt;問題&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/jxck_&#34;&gt;@Jxck&lt;/a&gt;さんのケースは1つの関数において複数のエラーハンドリングが煩雑になる，言わば縦方向のエラー処理の問題であった．Dave氏のトークで語られているのは深さ方向のエラー処理の問題である．大きく分けて2つの問題がある．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最終的に表示されるエラーメッセージ&lt;/li&gt;
&lt;li&gt;特定のエラーに対する分岐処理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下ではそれらを具体的に説明する．&lt;/p&gt;

&lt;h3 id=&#34;エラーメッセージ&#34;&gt;エラーメッセージ&lt;/h3&gt;

&lt;p&gt;まずはエラーメッセージについて．以下は基本的なGoのエラー処理である．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Foo() error {
    conf, err := ReadConf()
    if err != nil {
        return err
    }
    ...
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Foo()&lt;/code&gt;が&lt;code&gt;ReadConf()&lt;/code&gt;を呼び，&lt;code&gt;ReadConf()&lt;/code&gt;がエラーを返せばそれを&lt;code&gt;err&lt;/code&gt;として返し，そうでなければ&lt;code&gt;conf&lt;/code&gt;をつかった処理を続行し問題がなければ&lt;code&gt;nil&lt;/code&gt;を返す．&lt;/p&gt;

&lt;p&gt;大きなパッケージやツールになるとこの定型的な処理はどんどん連なり深くなる．例えばこの例の場合は&lt;code&gt;ReadConf()&lt;/code&gt;がさらに&lt;code&gt;Write()&lt;/code&gt;といった標準パッケージの関数を呼びそのエラーを返すかもしれないし，&lt;code&gt;Foo()&lt;/code&gt;は別の関数から呼ばれその中でエラーが処理されるかもしれない．&lt;/p&gt;

&lt;p&gt;これらの一連のエラーは最終的にどうなるか? コマンドラインツールやWebサーバーの&lt;code&gt;main()&lt;/code&gt;に戻り以下のように&lt;code&gt;fmt.Printf()&lt;/code&gt;（や&lt;code&gt;log&lt;/code&gt;）を使って適切なエラーメッセージとしてユーザに表示する（&amp;rdquo;べき&amp;rdquo;である）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Printf(&amp;quot;Failed Foo: %s&amp;quot;,err)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この単純な&lt;code&gt;return err&lt;/code&gt;の連鎖は問題を起こす．最終的にユーザに表示されるエラーメッセージにはその後のデバッグに対してなんの情報も提示できないことがある．つまりどの関数のどこでエラーが発生したのか追えなくなる．例えば発表でも触れられていたように&lt;code&gt;no such file or directory&lt;/code&gt;のみ表示されるケースに出会った人は多いと思う．他にもGoのツールだとTLSに関わるエラーなどで困ったひとは多いと思う（これはググるとDockerのGithub Issueが最初に現れるw）．&lt;/p&gt;

&lt;p&gt;この問題に対してできることは&lt;code&gt;fmt.Errorf()&lt;/code&gt;を使って具体的なエラーの状況を付加することである．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Foo() error {
    conf, err := ReadConf()
    if err != nil {
        return fmt.Errorf(&amp;quot;failed to read configuration file: %s&amp;quot;)
    }
    ...
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはよくPR reviewで指摘することだと思う．これで最終的に提示されるエラーはよりデバッグのしやすいものになる．&lt;/p&gt;

&lt;p&gt;しかし&lt;code&gt;fmt.Errorf()&lt;/code&gt;は&lt;code&gt;error&lt;/code&gt;を別の&lt;code&gt;string&lt;/code&gt;に結合して別の&lt;code&gt;error&lt;/code&gt;をつくり出す．原因となったエラーが特定の型を持っていた場合にそれを隠蔽してしまう．これにより&lt;code&gt;fmt.Errorf()&lt;/code&gt;は次に説明する呼び出し元での分岐処理を難しくする．&lt;/p&gt;

&lt;h3 id=&#34;分岐処理&#34;&gt;分岐処理&lt;/h3&gt;

&lt;p&gt;次に特定のエラーに対する呼び出し元での分岐処理の問題について説明する．関数の呼び元において特定のエラーが返ってきたときに単純にそれを返す，もしくはユーザに表示するのではなく，別の処理をしたいという場合がある．例えばリトライ処理を行うなど．&lt;/p&gt;

&lt;p&gt;これは様々な方法がある．が，以下は避けるべきである．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;error.Error()&lt;/code&gt;して中身をみて&lt;code&gt;string&lt;/code&gt;として使う&lt;/li&gt;
&lt;li&gt;Sentinel error（&lt;code&gt;io.EOF&lt;/code&gt;など）を使う&lt;/li&gt;
&lt;li&gt;自分でError typeを定義してType assertionする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1つ目は初心者がやりがちだが最も避けるべき方法である．他の2つを避ける理由は呼び出しに別の依存をもたらすことになるのが大きな理由（スライドにはもっと詳しい例があるのでそちらを見るとよい）．無駄なCouplingは避ける．基本的には単純な&lt;code&gt;error&lt;/code&gt;を返すというパッケージ間のContractを破るべきではない．&lt;/p&gt;

&lt;p&gt;ではどうするのが良いか? 型ではなくインターフェースを考える（Assert errors for behaviour, not type）．以下のようにする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type temporary interface {
    Temporary() bool 
}

func IsTemporary(err error) bool { 
   te, ok := err.(temporary) 
   return ok &amp;amp;&amp;amp; te.Temporary() 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;err&lt;/code&gt;が&lt;code&gt;temporary&lt;/code&gt;インターフェースを実装していれば&lt;code&gt;Temporary()&lt;/code&gt;関数で特別な分岐処理をするべきか（例えばリトライするべきか）どうかを判別して返す．していなければ無関係なエラーとして単純に&lt;code&gt;false&lt;/code&gt;を返し特別な処理分岐をスキップする．これは無駄な依存やCouplingを避けることができる．&lt;/p&gt;

&lt;p&gt;しかしこの方法と上述した&lt;code&gt;fmt.Errorf()&lt;/code&gt;によるエラーメッセージ問題を同時に解決することはできない．&lt;code&gt;fmt.Errorf()&lt;/code&gt;がエラーを作り直してしまうからである（元のエラーがインターフェースを持っていたか追えなくなる）．&lt;/p&gt;

&lt;h2 id=&#34;errorsを使う&#34;&gt;errorsを使う&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;errors&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;errors&lt;/code&gt;は上記で説明したエラーメッセージ問題を良い感じに解決しつつ処理分岐にも対応する．&lt;code&gt;errors&lt;/code&gt; パッケージは以下のような関数を持つ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Wrap(cause error, message string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Cause(err error) error
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wrap&#34;&gt;Wrap()&lt;/h3&gt;

&lt;p&gt;まず&lt;code&gt;Wrap()&lt;/code&gt;はオリジナルの&lt;code&gt;error&lt;/code&gt;を具体的なエラーの状況（&lt;code&gt;message&lt;/code&gt;）とともにラップした新たな&lt;code&gt;error&lt;/code&gt;を返す．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;conf, err := ReadConf()
if err != nil {
    return errors.Wrap(err, &amp;quot;failed to read configuration file&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この&lt;code&gt;Error()&lt;/code&gt;の結果は以下の&lt;code&gt;error&lt;/code&gt;と同じである．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Errorf(&amp;quot;failed to read configuration file: %s&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数のインターフェースとしてそのエラーのコンテキスト（annotation）を要求するのがよい．最終的に出力されるエラーメッセージは&lt;code&gt;fmt.Errorf()&lt;/code&gt;と同じ結果になりエラー処理の方法も変わらない．&lt;/p&gt;

&lt;p&gt;これだけではなく&lt;code&gt;Wrap()&lt;/code&gt;は呼ばれたファイルとその行数も同時に内部に記録する．同パッケージの&lt;code&gt;Print&lt;/code&gt;（&lt;code&gt;Fprint&lt;/code&gt;）を使うと以下のような詳細なエラーメッセージを表示することができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;err := fn()
errors.Fprint(os.Stderr, err)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;read.go:3: A.conf is not exist
conf.go:35: failed to read configuration
main.go:100: Failed to run fn()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは単純に&lt;code&gt;fmt.Errorf&lt;/code&gt;を使うより便利なので移行の理由になる．&lt;/p&gt;

&lt;h3 id=&#34;cause&#34;&gt;Cause()&lt;/h3&gt;

&lt;p&gt;次に&lt;code&gt;Cause()&lt;/code&gt;は元となったエラーをそのまま取り出す．&lt;code&gt;fmt.Errorf&lt;/code&gt;はコンテキストを付与できる一方で新しいエラーを返してしまうために呼び出し元での処理の分岐がやりにくくなってしまった．&lt;code&gt;Cause()&lt;/code&gt;は以下のインターフェースを&lt;code&gt;error&lt;/code&gt;に持たせることで元となった&lt;code&gt;error&lt;/code&gt;を取り出す関数である．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Causer interface {
    Cause() error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを使うと上記の&lt;code&gt;temporary&lt;/code&gt;インターフェースの例は以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func IsTemporary(err error) bool { 
    te, ok := errors.Cause(err).(temporary)
    return ok &amp;amp;&amp;amp; te.Temporary() 
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん&lt;code&gt;Wrap()&lt;/code&gt;はデフォルトで元の&lt;code&gt;error&lt;/code&gt;を保持し，かつ&lt;code&gt;Causer&lt;/code&gt;インターフェースを満たすので&lt;code&gt;Cause()&lt;/code&gt;をそのまま使える．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;errors&lt;/a&gt;を使うとエラーにコンテキストを付与しつつ，オリジナルのエラーを保持し呼び出し元において処理の分岐を行うことができる．かつ&lt;code&gt;error&lt;/code&gt;を介すので標準的なContractから外れることもない．&lt;/p&gt;

&lt;p&gt;Canonicalのいくつかのツールでも使われている（&lt;code&gt;juju&lt;/code&gt;も似たパッケージ&lt;a href=&#34;https://github.com/juju/errors&#34;&gt;juju/errors&lt;/a&gt;を使っている）らしい．そして&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;errors&lt;/a&gt;はそれらのシンプル版とのこと．&lt;/p&gt;

&lt;p&gt;こういう標準パッケージに則した薄いライブラリはとても好きなので使っていきたい．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年振り返り</title>
      <link>http://deeeet.com/writing/2015/12/31/2015/</link>
      <pubDate>Thu, 31 Dec 2015 23:19:18 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/12/31/2015/</guid>
      <description>

&lt;p&gt;2015年の振り返りとして自分が好きだったもの，影響を受けたものを雑多にまとめる．それに合わせて自分の活動についても振り返り，2016年の展望を書く（&lt;a href=&#34;http://blog.fogus.me/&#34;&gt;fogus: Send More Paramedics&lt;/a&gt;の形式が良かったのでそれを真似ている）．&lt;/p&gt;

&lt;h2 id=&#34;blog-posts-read&#34;&gt;Blog posts read&lt;/h2&gt;

&lt;p&gt;今年読んで印象に残った，影響を受けたブログ記事．順不同．&lt;/p&gt;

&lt;h3 id=&#34;japanese&#34;&gt;Japanese&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.sigbus.info/2015/01/p1.html&#34;&gt;コードを書くことは無限の可能性を捨てて一つのやり方を選ぶということ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.kengo-toda.jp/entry/2015/03/22/215005&#34;&gt;7年働いた時点での私の仕事の極意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.jockinsey.com/settingalowbar&#34;&gt;志低く&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://myfinder.hatenablog.com/entry/2015/03/27/141416&#34;&gt;ソフトウェアエンジニアだけでサービス運用できる環境を作って失業した話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mrorii.github.io/blog/2015/04/04/language-of-food/&#34;&gt;食べログの口コミに見る人間心理 -麻薬と性とトラウマと-&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.livedoor.jp/sonots/archives/44075238.html&#34;&gt;運用を楽にするためのアプリケーションコードを書くということ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hb.matsumoto-r.jp/entry/2015/04/20/151743&#34;&gt;Webオペレーションエンジニアのアウトプットと開発力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hail2u.net/blog/software/patience-time.html&#34;&gt;我慢の期間&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yuuki.hatenablog.com/entry/2015-webserver-architecture&#34;&gt;2015年Webサーバアーキテクチャ序論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://anemone.dodgson.org/2015/07/13/a-million-hello-worlds/&#34;&gt;A Million Hello Worlds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hb.matsumoto-r.jp/entry/2015/08/23/220153&#34;&gt;技術者が研究者のように論文を書くメリットはあるか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://t-wada.hatenablog.jp/entry/active-oss-development-vs-simplicity&#34;&gt;OSS開発の活発さの維持と良いソフトウェア設計の間には緊張関係があるのだろうか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.twitter.com/ja/2015/buttons&#34;&gt;持続的なプラットフォームのための難しい決断&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://anond.hatelabo.jp/20151117013422&#34;&gt;翻訳は/誰がやっても/間違える&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://steps.dodgson.org/b/2012/12/30/code-review-from-lowland/&#34;&gt;下から目線のコードレビュー&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;english&#34;&gt;English&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.linux.com/news/featured-blogs/200-libby-clark/806347-collaboration-summit-keynote-alex-polvi-coreos&#34;&gt;CoreOS Co-Founder Alex Polvi Talks Containers, Rocket vs. Docker, and More&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mnot.net/blog/2015/02/18/http2&#34;&gt;HTTP/2 is Done&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.shubhro.com/2014/12/27/software-engineers-should-write/&#34;&gt;Software engineers should write&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@darrenrush/after-docker-unikernels-and-immutable-infrastructure-93d5a91c849e#.7x8i5lfvt&#34;&gt;After Docker: Unikernels and Immutable Infrastructure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/199PqyG3UsyXlwieHaqbGiWVa8eMWi8zzAn0YfcApr8Q/edit&#34;&gt;My Philosophy on Alerting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://thenewstack.io/new-stack-mitchell-hashimoto-containers-no-containers-one-question-2015&#34;&gt;Mitchell Hashimoto: Containers or No Containers? That is One Question for 2015&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://coreos.com/blog/cluster-osi-model/&#34;&gt;What makes a cluster a cluster?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pl-enthusiast.net/2015/03/25/interview-with-gos-russ-cox-and-sameer-ajmani/&#34;&gt;Interview with Go’s Russ Cox and Sameer Ajmani&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.toolshed.com/2015/05/the-failure-of-agile.html&#34;&gt;The Failure of Agile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http/&#34;&gt;Deprecating Non-Secure HTTP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://influxdb.com/blog/2015/06/03/InfluxDB_clustering_design.html&#34;&gt;InfluxDB Clustering Design - neither strictly CP or AP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.circleci.com/its-the-future/&#34;&gt;It&amp;rsquo;s The Future&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mkremins.github.io/blog/unix-not-acceptable-unix/&#34;&gt;Unix is not an acceptable Unix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.parse.com/learn/how-we-moved-our-api-from-ruby-to-go-and-saved-our-sanity/&#34;&gt;How We Moved Our API From Ruby to Go and Saved Our Sanity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mitchellh.com/apple-the-key-to-my-success&#34;&gt;APPLE: My Key to Success&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jmoiron.net/blog/thoughts-on-timeseries-databases/&#34;&gt;Thoughts on Time-series Databases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kismatic.com/company/qa-with-malte-schwarzkopf-on-distributed-systems-orchestration-in-the-modern-data-center/&#34;&gt;Omega, and what it means for Kubernetes: a Q&amp;amp;A about cluster scheduling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boxfuse.com/blog/no-ssh.html&#34;&gt;Immutable Infrastructure: No SSH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mitchellh.com/automation-obsessed&#34;&gt;Automation Obsessed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jvns.ca/blog/2015/11/21/why-you-should-understand-a-little-about-tcp/&#34;&gt;Why you should understand (a little) about TCP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://misfra.me/2015/07/20/time-series-databases-discussion-notes/&#34;&gt;Time Series Databases Discussion Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dave.cheney.net/2015/11/05/lets-talk-about-logging&#34;&gt;Let&amp;rsquo;s talk about logging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://http2.cloudflare.com/the-story-of-one-latency-spike/&#34;&gt;The story of one latency spike&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html&#34;&gt;Linux Performance Analysis in 60,000 Milliseconds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.cloudflare.com/introducing-http2/&#34;&gt;HTTP/2 is here! Goodbye SPDY? Not quite yet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://composition.al/blog/2015/12/29/refactoring-as-a-way-to-understand-code/&#34;&gt;Refactoring as a way to understand code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.agner.org/optimize/blog/read.php?i=417&#34;&gt;Moores law hits the roof&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;blog-posts-by-me&#34;&gt;Blog posts by me&lt;/h2&gt;

&lt;p&gt;今年は30本の記事を書いた．大体月2-3本くらい．ほとんどが技術関連の記事だったが，趣味のCoffeeに関するものも2本ほど書いた．年間のPVは &lt;strong&gt;275,966&lt;/strong&gt; viewsだった．特に読まれたのは以下の記事．順番はPV順．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/02/17/docker-bad-points/&#34;&gt;Dockerの諸問題とRocket登場の経緯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/09/01/apache-kafka/&#34;&gt;Apache Kafkaに入門した&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/06/26/golang-dependency-vendoring/&#34;&gt;Go言語のDependency/Vendoringの問題と今後．gbあるいはGo1.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/03/17/serverspec-for-automation/&#34;&gt;デプロイ自動化とServerspec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/10/04/otto/&#34;&gt;Hashicorp Ottoを読む&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;特にある分野の現状の問題を整理した記事がよく読まれたと思う．このような記事は自分の頭も書くことで整理されたので良かった．&lt;/p&gt;

&lt;p&gt;2015年は後半になるにつれて長文の記事を書いてしまう傾向があった．2016年はダラダラと書くのではなく短くシンプルな記事を目指していきたい（&lt;a href=&#34;https://twitter.com/omo2009&#34;&gt;@omo2009&lt;/a&gt;さんの記事くらいの長さが目標）．2015年は1本だけ英語の記事を書いた（cf. &lt;a href=&#34;http://deeeet.com/writing/2015/05/11/gox-server/&#34;&gt;Golang Cross Compiler on Heroku (with Docker)&lt;/a&gt;）．2016年は英語の記事の量も増やしていきたい．&lt;/p&gt;

&lt;h2 id=&#34;presentations&#34;&gt;Presentations&lt;/h2&gt;

&lt;p&gt;今年印象に残った，影響を受けた発表．実際にカンファレンスで観れたもの，参加できなくて後日スライドのみを観たものを含む．順不同．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/yutakakinjyo/hackerscample-lt-49900119&#34;&gt;一度死んだ話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/kelseyhightower/cfgmgmtcamp-2015/slides/coreos-kubernetes.slide#1&#34;&gt;Managing Containers at Scale with CoreOS and Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/hayabusa333/ss-16114338&#34;&gt;漏れのある抽象化の法則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://talks.golang.org/2015/gogo.slide#1&#34;&gt;Go in Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/benbjohnson/raft-the-understandable-distributed-consensus-protocol&#34;&gt;Raft: The Understandable Distributed Consensus Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/pirhilton/how-to-name-things-the-hardest-problem-in-programming&#34;&gt;How to name things: the hardest problem in programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/a_matsuda/the-recipe-for-the-worlds-largest-rails-monolith&#34;&gt;he Recipe for the World&amp;rsquo;s Largest Rails Monolith&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/mirakui/developer-productivity-in-cookpad&#34;&gt;Developer Productivity in Cookpad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/taijitsuchiya5/ss-47398248&#34;&gt;なぜネットワーク運用自動化が進まないのか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/jacopen/openpaas-paas&#34;&gt;ひしめき合うOpen PaaSを徹底解剖！ PaaSの今と未来&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://techblog.netflix.com/2015/08/netflix-at-velocity-2015-linux.html&#34;&gt;Velocity 2015 linux perf tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hitode909.hatenablog.com/entry/2015/08/21/165932&#34;&gt;Perlの上にも三年 〜 ずっとイケてるサービスを作り続ける技術 〜&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chibicode.com/sf-hell/&#34;&gt;#地獄のサンフランシスコ by @chibicode / 上杉周作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;presentations-by-me&#34;&gt;Presentations by me&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tcnksm/talks&#34;&gt;github.com/tcnksm/talks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今年は9回発表をした．以下がスライド．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/coreoskurasutanidockerkontenawodepuroi-number-dockerjp&#34;&gt;&amp;ldquo;Deploy Docker Containers on CoreOS Cluster&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://connpass.com/event/10318/&#34;&gt;Docker Meetup Tokyo #4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/coreoskurasutafalsedockerkontenafalsejian-shi-number-monitoringcasual&#34;&gt;&amp;ldquo;Monitor Docker Containers on CoreOS Cluster&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://www.zusaar.com/event/9807003&#34;&gt;Monitoring Casual Talks #7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/aruruo-shou-inhuraenziniafalsexian-zhuang-que-ren-number-wakateinfra&#34;&gt;&amp;ldquo;A wakete infra engineer&amp;rdquo;&lt;/a&gt; at Wakate Infra meetup&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/introduction-of-coreos-at-coreos-meetup-tokyo-number-1-number-coreosjp&#34;&gt;&amp;ldquo;Introduction of CoreOS&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://coreos-meetup-tokyo.connpass.com/event/12596/&#34;&gt;CoreOS meetup Tokyo #1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/what-i-talk-about-when-i-talk-about-cli-tool-by-golang-number-gocon&#34;&gt;&amp;ldquo;What I Talk About When I Talk About CLI Tool By Golang #gocon&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://gocon.connpass.com/event/14063/&#34;&gt;Go Conference 2015 Summer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/how-to-dev-and-ops-internal-paas&#34;&gt;&amp;ldquo;How to Dev&amp;amp;Ops Internal PaaS&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://www.zusaar.com/event/9057007&#34;&gt;Hosting Casual #2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/tcnksm/talks/2015/07/jtf2015.Slide#1&#34;&gt;&amp;ldquo;若手インフラエンジニアたちが語る技術トレンドと数年後の未来&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://2015.techfesta.jp/&#34;&gt;JTF2015&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/tcnksm/talks/2015/08/hashicorp-meetup.slide#1&#34;&gt;&amp;ldquo;Go pakcages from Hashicorp&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://engineer.wantedly.com/2015/08/06/hashicorp-product-meetup.html&#34;&gt;Hashicorp Meetup&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今年は特に&lt;a href=&#34;https://twitter.com/hashtag/wakateinfra&#34;&gt;#wakateinfra&lt;/a&gt;として同年代の人と知り合いになれたのがとても良かった．&lt;/p&gt;

&lt;h2 id=&#34;podcasts&#34;&gt;Podcasts&lt;/h2&gt;

&lt;p&gt;好きだったPodcastエピソード．順不同．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mozaic.fm/post/133930208998/20-browser&#34;&gt;#20 Browser | mozaic.fm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://changelog.com/180/&#34;&gt;#180: Otto, Vagrant, and Automation with Mitchell Hashimoto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://changelog.com/168/&#34;&gt;#168: Prometheus and Service Monitoring with Julius Volz from SoundCloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://changelog.com/151/&#34;&gt;#151: Rust with Steve Klabnik and Yehuda Katz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/101/&#34;&gt;Rebuild: 101: Before And After Refactoring (Dice)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/99/&#34;&gt;Rebuild: 99: The Next Generation Of HTTP (kazuho)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/91/&#34;&gt;Rebuild: 91: The PHP Way (Naoya Ito)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/81/&#34;&gt;Rebuild: 81: Enable The Broken Web (Hajime Morrita)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通勤時間が短くなった影響もあり以前よりも多くを聴けなくなった．2016年は運動をもう少し増やしてその間に聴こうという作戦がある．&lt;/p&gt;

&lt;h2 id=&#34;podcasts-by-me&#34;&gt;Podcasts by me&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/83/&#34;&gt;Rebuild: 83: Living In A Container&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2015年の最大のイベントは&lt;a href=&#34;http://rebuild.fm/&#34;&gt;rebuild.fm&lt;/a&gt;に出演したことだと思う．普段やっているプレゼンとは勝手が違いとにかく喋るのは難しかった（NaoyaさんにPodcastでうまく喋る方法をブログに書いてもらいたい）．2016年は自分でもPodcastを始めてみたいという妄想はしている．そういうので喋りを鍛えたい．&lt;/p&gt;

&lt;h2 id=&#34;papers-read&#34;&gt;Papers read&lt;/h2&gt;

&lt;p&gt;今年読んだ論文．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sites.computer.org/debull/A12june/pipeline.pdf&#34;&gt;Building LinkedIn&amp;rsquo;s Real-time Activity Data Pipeline&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ざっと目を通すのはいくつもあったがちゃんと読み込んだのは1本（これをまとめたのが&lt;a href=&#34;http://deeeet.com/writing/2015/09/01/apache-kafka/&#34;&gt;&amp;ldquo;Apache Kafkaに入門した&amp;rdquo;&lt;/a&gt;）．来年はもっと論文のインプットを増やしたい．とりあえず抑えるべき会議を抑え，読む習慣をつけたい．&lt;/p&gt;

&lt;h2 id=&#34;books-read&#34;&gt;Books read&lt;/h2&gt;

&lt;p&gt;今年読んだ本で良かったものをランキングで．&lt;/p&gt;

&lt;h3 id=&#34;tech&#34;&gt;Tech&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B0184N7WWS&#34;&gt;The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4254127057&#34;&gt;オペレーティングシステムの仕組み&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4797382228&#34;&gt;暗号技術入門 第3版 秘密の国のアリス&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;non-tech&#34;&gt;Non-tech&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/425500613X&#34;&gt;暇と退屈の倫理学&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4403120245&#34;&gt;スクリプトドクターの脚本教室・初級篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4576151142&#34;&gt;１４歳からの哲学入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4884184432&#34;&gt;職業としての小説家&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4344026241&#34;&gt;僕がコントや演劇のために考えていること&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;とにかく読書量が少なかった．2016年はアウトプットよりもインプットを重視したい．&lt;/p&gt;

&lt;h2 id=&#34;music&#34;&gt;Music&lt;/h2&gt;

&lt;p&gt;今年好きだった音楽をランキングで．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Oneohtrix Point Never - &lt;a href=&#34;https://www.youtube.com/watch?v=jt5tRaV3iY0&#34;&gt;&amp;ldquo;Garden of Delete&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Swindle - &lt;a href=&#34;http://peaceloveandmusic.info/&#34;&gt;&amp;ldquo;Peace, Love &amp;amp; Music&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Slack - &lt;a href=&#34;https://www.youtube.com/watch?v=OD7s62BTy9M&#34;&gt;&amp;ldquo;My Space&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kamasi Washington - &lt;a href=&#34;https://www.youtube.com/watch?v=NtQRBzSN9Vw&#34;&gt;&amp;ldquo;The Epic&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jam City - &lt;a href=&#34;https://www.youtube.com/watch?v=CiFbb6Waj_A&#34;&gt;&amp;ldquo;Dream A Garden&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Floating Points - &lt;a href=&#34;https://www.youtube.com/watch?v=5ntcVE3AQsg&#34;&gt;&amp;ldquo;Elaenia&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clap! Clap! - &lt;a href=&#34;https://www.youtube.com/watch?v=5etsDAlRTdg&#34;&gt;&amp;ldquo;Simple&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Battles - &lt;a href=&#34;https://www.youtube.com/watch?v=bkhLzHuUYmo&#34;&gt;&amp;ldquo;La Di Da Di&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jamie xx - &lt;a href=&#34;https://www.youtube.com/watch?v=TP9luRtEqjc&#34;&gt;&amp;ldquo;In Colour&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kitty, Daisy &amp;amp; Lewvis - &lt;a href=&#34;https://www.youtube.com/watch?v=9ASLWuIPXGc&#34;&gt;&amp;ldquo;The third&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;過去&#34;&gt;過去&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/12/31/music-2014/&#34;&gt;Best Music 2014&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2013/12/31/music-2013/&#34;&gt;Best Music 2013&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2012/12/31/music-2012/&#34;&gt;Best Music 2012&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;movie&#34;&gt;Movie&lt;/h2&gt;

&lt;p&gt;今年観て好きだった映画をランキングで．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;George Miller - &lt;a href=&#34;http://www.madmaxmovie.com/&#34;&gt;&amp;ldquo;MAD MAX: FURY ROAD&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;是枝裕和 - &lt;a href=&#34;http://umimachi.gaga.ne.jp/&#34;&gt;&amp;ldquo;海街diary&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Paul Thomas Anderson - &lt;a href=&#34;http://wwws.warnerbros.co.jp/inherent-vice/&#34;&gt;&amp;ldquo;Inherent Vice&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dan Gilroy - &lt;a href=&#34;http://nightcrawler.gaga.ne.jp/&#34;&gt;&amp;ldquo;Nightcrawler&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;J.J. Abrams - &lt;a href=&#34;http://www.starwars.com/the-force-awakens/&#34;&gt;&amp;ldquo;Star Wars: The Force Awakens&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Go言語でファジング</title>
      <link>http://deeeet.com/writing/2015/12/21/go-fuzz/</link>
      <pubDate>Mon, 21 Dec 2015 00:25:30 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/12/21/go-fuzz/</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/go&#34;&gt;Go Advent Calendar 2015&lt;/a&gt;の21日目の記事です．&lt;/p&gt;

&lt;p&gt;今年もGoコミュニティーから多くのツールが登場した．その中でも異彩を放っていたのがGoogleのDynamic testing toolsチームの&lt;a href=&#34;https://twitter.com/dvyukov&#34;&gt;@dvyukov&lt;/a&gt;氏による&lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;go-fuzz&lt;/a&gt;である．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go-fuzz&lt;/code&gt;はGo関数のファジングを行うツールである．このツールはとても強力で標準パッケージで100以上，&lt;a href=&#34;golang.org/x/&#34;&gt;golang.org/x/&lt;/a&gt;パッケージで40以上，その他を含めると300以上のバグを発見するという実績を残している（cf. &lt;a href=&#34;https://github.com/dvyukov/go-fuzz#trophies&#34;&gt;Trophies&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;本記事ではこの&lt;code&gt;go-fuzz&lt;/code&gt;の紹介を行う．&lt;/p&gt;

&lt;h2 id=&#34;ファジングとは&#34;&gt;ファジングとは?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fuzz_testing&#34;&gt;Fuzz testing - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/dev/feature/01/fuzzing&#34;&gt;ソフトウェアの脆弱性検出におけるファジングの活用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;「ファジング」とはソフトウェアのテスト手法である．テスト対象となるソフトウェアにランダムなデータを大量に入力し意図しない挙動を検出する．&lt;/p&gt;

&lt;p&gt;普通のソフトウェアは予期しないデータを受けても適切な処理，例えばエラーを返すなど，を行う．そしてそれはテストされる．しかし予期しない入力をすべてテストすることは難しい．適切に処理しているつもりであっても予期しないデータによりソフトウェアがクラッシュしてしまうことはありうる．このようなテストでファジングは光る．大量のランダムデータを入力し予期しないクラッシュを見つける．&lt;/p&gt;

&lt;p&gt;ファジングの利点に以下が挙げられる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;チープである&lt;/li&gt;
&lt;li&gt;バイアスがない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まずファジングは単純にランダムなデータを放り込むだけなので非常にチープな手法である．使うだけなら特別な知識は必要ない．次にランダムであるためテスターのバイアスがない．そのソフトウェアをつくっているひとほど思い込みが強くなってしまう（と思う）が，そのようなバイアスを排除することができる．&lt;/p&gt;

&lt;p&gt;ファジングで入力となるデータは「ファズ」と呼ばれる．コマンドラインツールであれば引数や環境変数，ウェブサーバーであればHTTPリクエストである．ファジングではこのファズをいかに生成するのかが重要になる．完全にランダムにする，指定の範囲内で連続に値を変化させる，正常なデータの一部を変更させる．ある特定の制御文字列を対象にするといった手法がある．&lt;/p&gt;

&lt;h2 id=&#34;go-fuzzとは&#34;&gt;go-fuzzとは?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;dvyukov/go-fuzz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=a9xrxRsIbSU&#34;&gt;GopherCon 2015: Dmitry Vyukov - Go Dynamic Tools&lt;/a&gt; (&lt;a href=&#34;https://talks.golang.org/2015/dynamic-tools.slide#1&#34;&gt;Slide&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go言語の関数に対してファジングを行うために開発されたのが&lt;code&gt;go-fuzz&lt;/code&gt;である．&lt;code&gt;go-fuzz&lt;/code&gt;はC/C++の&lt;a href=&#34;http://lcamtuf.coredump.cx/afl/&#34;&gt;afl-fuzz&lt;/a&gt;がベースになっている．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go-fuzz&lt;/code&gt;は完全にランダムなデータを入力するのではなく，正常なデータの一部を変更させランダムなデータを生成する．これにより単純にランダムな値で盲目的にテストをするのではなく，ある程度「ありそうな」データでテストを行うことができる．このためのデータセットをcorpusと呼び，&lt;code&gt;go-fuzz&lt;/code&gt;はテストを繰り返しながらこのcorpusを成長させていく．&lt;/p&gt;

&lt;p&gt;corpusはどのように成長するのか? &lt;code&gt;go-fuzz&lt;/code&gt;は&lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;AST&lt;/a&gt;を使い対象関数のテストのカバレッジ情報を取得する．カバレッジを上げるような入力が得られればそれをcorpusに登録する．これによりテストはより網羅的になる．&lt;/p&gt;

&lt;p&gt;corpusは事前に与えることもできる．例えば対象とする関数の入力が画像データである場合は事前に幾つかの画像データを与えることができる．もしくはユニットテストなどで既にテストしている値を使うこともできる．&lt;/p&gt;

&lt;p&gt;入力を繰り返し意図しない挙動が得られる（例えばpanicが起こる）と&lt;code&gt;go-fuzz&lt;/code&gt;はそれを引き起こした入力とスタックトレースをファイルとして保存する．開発者はその結果をもとに新たにユニットテストを追加しコードを修正していく．&lt;/p&gt;

&lt;h3 id=&#34;使いかた&#34;&gt;使いかた&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go-fuzz&lt;/code&gt;によるファジングには以下の2つが必要である&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fuzz()&lt;/code&gt;関数の準備&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go-fuzz-buid&lt;/code&gt;と&lt;code&gt;go-fuzz&lt;/code&gt;の実行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まず&lt;code&gt;Fuzz()&lt;/code&gt;関数は以下のような関数である．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Fuzz(data []byte) int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;data&lt;/code&gt;は&lt;code&gt;go-fuzz&lt;/code&gt;によって与えられるランダムな値である（ほとんどはinvalidな値である）．そしてこの値をテストしたい関数に入力として与える．&lt;code&gt;go-fuzz&lt;/code&gt;はこの入力で関数が&lt;code&gt;panic&lt;/code&gt;したりクラッシュしたり，メモリを割り当てすぎてhangしないかを監視する．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Fuzz()&lt;/code&gt;の返り値はcorpusの作成に使われる．以下の3つの値のうちどれかを返す．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt;- 入力がふさわしいデータであると考えられる場合（例えば関数がエラーを返さずに正常に処理された場合その入力はその関数にとってふさわしい入力であると考えることができる．ここから新たなランダムな値を生成すれば新たなエラーを発見できる可能性が高い）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-1&lt;/code&gt; - 入力がカバレッジを上げるようなふさわしい入力であると考えられてもcorpusには追加したくない場合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; - 上記以外の場合（例えばエラーが返った場合）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;関数が書けたら以下で専用のバイナリをつくる．&lt;code&gt;zip&lt;/code&gt;形式で出力される．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-fuzz-build pkg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして以下でテストを実行する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-fuzz -bin=pkg_fuzz.zip -workdir=dir 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-bin&lt;/code&gt;に上で生成したバイナリを指定する．テストは止めるまで無限に実行される．corpusやテストの結果は&lt;code&gt;-workdir&lt;/code&gt;で指定するディレクトリに出力される．例えばプログラムをクラッシュさせるような入力が得られた場合は&lt;code&gt;crashers/&lt;/code&gt;ディレクトリ内にその値とスタックトレースがファイルとして出力される．&lt;/p&gt;

&lt;p&gt;ちなみに作成されたcorpusはバージョン管理システムに保存するべきである．そうすれば他の人もそれを再利用することができる．&lt;/p&gt;

&lt;h2 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h2&gt;

&lt;p&gt;言葉だけでは分かり難いので実際に使ってみる．例えば以下のような関数をテストしてみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func CoolFunc(str string) error {

if len(str) &amp;lt; 1 {
    return fmt.Errorf(&amp;quot;Input must not be empty&amp;quot;)
}

if str[0] != &#39;A&#39; {
    return fmt.Errorf(&amp;quot;Input must start with A&amp;quot;)
}

// Super cool processing.

// Bug hard to find !
if str == &amp;quot;ABCD&amp;quot; {
    panic(&amp;quot;input must not be ABCD&amp;quot;)
}

return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この関数は文字列を受け取ってめちゃめちゃクールな処理を行う．長さ0の文字列の入力は許容しない．また&lt;code&gt;A&lt;/code&gt;で始まる文字列ではエラーが発生することまではわかっていおり適切にハンドルがされている．そして&lt;code&gt;ABCD&lt;/code&gt;という値が入力されたときのみなぜか関数がクラッシュするというバグが混入しているとする．以下ではこのバグをファジングで発見する（当たり前だが普通はそもそもこのようなバグがあることは事前にわからない）．&lt;/p&gt;

&lt;p&gt;まず&lt;code&gt;Fuzz()&lt;/code&gt;は以下のようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// +build gofuzz

func Fuzz(data []byte) int {
    if err := CoolFunc(string(data)); err != nil {
        return 0
    }
    return 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーのときはすでにそれは適切にハンドルされているので&lt;code&gt;0&lt;/code&gt;を返す．正常に動作した場合は&lt;code&gt;1&lt;/code&gt;を返してcorpusの生成に利用するようにする．&lt;/p&gt;

&lt;p&gt;ビルドしてファジングを実行する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-fuzz-build github.com/tcnksm-sample/go-fuzz
$ go-fuzz -bin=pkg-fuzz.zip -workdir=workdir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行すると以下のような出力が得られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2015/12/20 21:23:54 slaves: 4, corpus: 3 (2s ago), crashers: 1, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;crashers:　1&lt;/code&gt;とあり関数をクラッシュさせるような入力が得られたことがわかる．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;workdir/crashers&lt;/code&gt;をみると以下のようなファイルが生成されている．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;workdir/crashers
├── fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6
├── fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6.output
└── fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6.quoted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず拡張子がないファイルは具体的に関数をクラッシュさせた入力が含まれている（&lt;code&gt;.quoted&lt;/code&gt;はその入力を&amp;rdquo;&amp;ldquo;で囲ったもの）．この場合は&lt;code&gt;ABCD&lt;/code&gt;が得られる．そして&lt;code&gt;.output&lt;/code&gt;ファイルにはその際のスタックトレースが出力される．今回は以下のような出力が得られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat workdir/crashers/fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6.output
panic: input must not be ABCD

goroutine 1 [running]:
github.com/tcnksm-sample/go-fuzz.CoolFunc(0x820267e78, 0x4, 0x0, 0x0)
....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クラッシュが得られたどうするか? まずユニットテストにその入力を追加する．そしてコードを修正し適切にハンドルされるようにする．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;自分のつくっているいくつかのツールでも試してみたが残念ながら面白いバグを発見することはできなかった（特に複雑なことをしていないというものあるが..）．&lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/go-fuzz/&#34;&gt;ユーザの入力を受けるソフトウェアはすべてファジングするべき&lt;/a&gt;という意見もある．会社で書いているソフトウェアにもファジングを導入していきたいと思う．ファジングはとにかく簡単なので導入は容易だと思う．&lt;/p&gt;

&lt;p&gt;OSSのツールに対してファジングでバグを発見してコミットを行う実践的な方法は&lt;a href=&#34;https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c#.2s399y3sg&#34;&gt;&amp;ldquo;go-fuzz github.com/arolek/ase&amp;rdquo;&lt;/a&gt;が詳しい．&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;dvyukov/go-fuzz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fuzz_testing&#34;&gt;Fuzz testing - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/dev/feature/01/fuzzing&#34;&gt;ソフトウェアの脆弱性検出におけるファジングの活用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=a9xrxRsIbSU&#34;&gt;GopherCon 2015: Dmitry Vyukov - Go Dynamic Tools&lt;/a&gt; (&lt;a href=&#34;https://talks.golang.org/2015/dynamic-tools.slide#1&#34;&gt;Slide&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lcamtuf.coredump.cx/afl/&#34;&gt;american fuzzy lop (1.96b)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.cloudflare.com/dns-parser-meet-go-fuzzer/&#34;&gt;DNS parser, meet Go fuzzer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/filosottile/automated-testing-with-go-fuzz&#34;&gt;Automated Testing with go-fuzz // Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c#.2s399y3sg&#34;&gt;go-fuzz github.com/arolek/ase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/go-fuzz/&#34;&gt;Go Fuzz&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>自宅で美味いコーヒーを淹れる</title>
      <link>http://deeeet.com/writing/2015/12/17/coffee-2015/</link>
      <pubDate>Thu, 17 Dec 2015 00:35:03 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/12/17/coffee-2015/</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/895&#34;&gt;コーヒー Advent Calendar 2015&lt;/a&gt;の17日目の記事です．&lt;/p&gt;

&lt;p&gt;コーヒーを淹れること，豆を買いに行くこと，コーヒー器具を集めること，コーヒー関連の本を読むことが好きだ．コーヒーは趣味といっても過言でなない．自宅で美味しいコーヒーを淹れるために今までいろいろ試行錯誤してきたが，最近ある程度固まってきたのでその環境についてまとめてみる．&lt;/p&gt;

&lt;h2 id=&#34;過去&#34;&gt;過去&lt;/h2&gt;

&lt;p&gt;最初に自分とコーヒーとの馴れ初めをつらつらと．&lt;/p&gt;

&lt;p&gt;親がコーヒー好きなので実家では当たり前のように毎日コーヒーが淹れられていた．そのため家で自分でコーヒーを淹れて飲むのは当たり前のものとして育った．実家ではドリップマシンが使われていた．特にこだわりはなく出されるものをそのまま飲んでいたと思う．&lt;/p&gt;

&lt;p&gt;自分でコーヒーを淹れるようになったのは大学生で一人暮らしを始めてから．最初は実家にあった使われていないドリッパー（確か&lt;a href=&#34;http://www.hario.com/&#34;&gt;HARIO&lt;/a&gt;）と近所のスーパーの安い豆でドリップを始めた．見よう見まねでなんとなくやっていたと思う．大学生にもなるとカフェなどでまともなコーヒーを飲むようになり，自分で淹れるコーヒーがあまり美味しくないと感じ始めた．&lt;/p&gt;

&lt;p&gt;どうやら自分で豆を挽くと美味いということを聞きつけ&lt;a href=&#34;http://www.amazon.co.jp/dp/B0002JZCF2&#34;&gt;ポーレックスのコーヒーミル&lt;/a&gt;を買い，近所の&lt;a href=&#34;http://kaldi-online.com/&#34;&gt;KALDI&lt;/a&gt;で豆を買い，手挽きによる豆とドリップを始めた．&lt;/p&gt;

&lt;p&gt;こうなってくると良いドリッパーも欲しくなる．いろいろ探して&lt;a href=&#34;http://www.chemexcoffeemaker.com/&#34;&gt;Chemex&lt;/a&gt;を買った．Chemexは未だに使っているので5年以上の付き合いになる（よくおしゃれインテリア的な感じで使ってるやついるけどああいうやつはフィルターが買えなくなって最終的に花瓶として使い始める．映画&lt;a href=&#34;http://wwws.warnerbros.co.jp/interstellar/&#34;&gt;&amp;ldquo;インターステラー&amp;rdquo;&lt;/a&gt;では水飲み用のデキャンタとして使われていて映画の評価に響いた）．&lt;/p&gt;

&lt;p&gt;手挽きはとにかく失敗した．特にグラインドが粗すぎて青臭くなってしまうことが多かった．また手挽きは時間がかかるため平日は厳しくて週末しかできないとう問題があった．そのため在学中は平日はお店で挽いてもらった豆でドリップし，週末に手挽きでドリップをした．ドリップは自己流でやっていて日によってばらつきがあるもののある程度まともなものが淹れられるようにはなった&lt;/p&gt;

&lt;h2 id=&#34;現在&#34;&gt;現在&lt;/h2&gt;

&lt;p&gt;過去のコーヒー環境には以下の問題があった．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;手挽きをしていたため平日に自分で豆を挽くことができないこと&lt;/li&gt;
&lt;li&gt;自己流ドリップで同じ豆でも味が固定されないこと&lt;/li&gt;
&lt;li&gt;良質な豆を使っていないこと&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まず1つ目は社会人になり財力で解決した．必要なのは良質な電動グライダー．コーヒーは一生付き合うと思い&lt;a href=&#34;http://www.amazon.co.jp/dp/B000NJDT9M&#34;&gt;Kalitaのナイスカットミル&lt;/a&gt;を購入した．これは最高でグラインドは綺麗に均等になるしあらゆる淹れ方（ドリップ，エスプレッソ，フレンチプレス）にあったグラインドに簡単に調整できる．何より速い．忙しい朝でも新鮮な豆を挽くことができる．&lt;/p&gt;

&lt;p&gt;2つ目の再現性の問題．これは本を読み，またサードウェーブの流れに触れることで多くを学び解決した．これについては以下で詳しく書く．&lt;/p&gt;

&lt;p&gt;3つ目の問題はそもそも問題と認識できていなかった．これもサードウェーブの文化に触れることで学んだ．東京にもサードウェーブの流れを汲んだカフェはたくさんある（cf. &lt;a href=&#34;http://deeeet.com/writing/2014/01/21/third-wave-tokyo/&#34;&gt;東京サードウェーブコーヒー&lt;/a&gt;）．KALDIの豆は今でも買う（特にリッチブレンドが大好き）が時間があればロースターに行き新鮮な豆を買うようになった．サードウェーブの原点であるオークランドが対岸にあるサンフランシスコを訪れたときは時間があればロースターに行き，コーヒーを飲み，豆を買うなどした（cf. &lt;a href=&#34;http://deeeet.com/writing/2015/06/07/sf-coffee/&#34;&gt;サンフランシスコでたくさんコーヒー飲んだ&lt;/a&gt;）．&lt;/p&gt;

&lt;h3 id=&#34;良い豆&#34;&gt;良い豆?&lt;/h3&gt;

&lt;p&gt;ちょっと脱線するが，良い豆って何? あるいはサードウェーブと今までの豆の違いって何? という話を．&lt;/p&gt;

&lt;p&gt;昔ながらのコーヒーに深煎りのものが多い．それは昔は豆が熟度など不完全なものしか入ってこなくてその欠点を焙煎で消そうとしていたため．&lt;/p&gt;

&lt;p&gt;近年はクオリティの高い豆が流通するようになった．特にサードウェーブってのは豆そのもの味を楽しもうって流れで浅煎が多い．そして素材そのものを楽しむのをよしとする．同じ農園の豆の味でも年ごとに違うし，同じ品種でもテロワール（生産地の地理/地勢/気候/土壌などの特徴）で異なってくる．今まではそれを隠そうとしたが，今はそれを楽しもうとしている．&lt;/p&gt;

&lt;p&gt;農家に対する配慮に関してもよく語られる．これはコーヒーの美味しさは実が果実として完熟しているかどうかで決まるため．かつそれは木になっているときにしか判断できないから．良好な関係を築くことでより良い栽培/収穫方法のループを回せるようにする．スタバとかが批判されるのは同じ味を世界中で実現するために農家無視で大量生産してるから．&lt;/p&gt;

&lt;p&gt;もちろん今でも昔ながらの深煎りも好きで全然飲むけど．&lt;/p&gt;

&lt;p&gt;以下では最近はどのような器具を使っているのか? 再現性を高めるにはどうしているのか? などについて書く．&lt;/p&gt;

&lt;h2 id=&#34;器具&#34;&gt;器具&lt;/h2&gt;

&lt;p&gt;もともとドリップ至上主義でコーヒーはドリップ，ドリップ以外は認めない，ドリップ以外は飲むに値しないという過激な立場を取ってきた．しかし豆にはその豆にあった淹れ方があることを知り，今ではこの考えを改めていろいろな抽出方法を使うようになった（メインはドリップだが）．&lt;/p&gt;

&lt;p&gt;簡単に現在使っている器具を紹介する．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/coffee-set.JPG&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;左から順番に&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.chemexcoffeemaker.com/&#34;&gt;Chemex&lt;/a&gt; - Chemexを愛して5年．これからも使い続けると思う．Chemexは専用のフィルターが必要でそれによってChemexっぽい味が出る．KALDIの豆によく使う．最近は人に淹れることもあるので6カップの購入も考えている．&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dodrip.net/detail.html&#34;&gt;Donuts Dripper&lt;/a&gt; - Chemex以外のドリップもしようと2年ほど前に購入．しっかり濃いのに重くないスッキリした飲み心地になるようにデザインされており実際そんな感じになる．市販の安いフィルターが使えるもの良い．&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B0000AN3QI&#34;&gt;BIALETTI モカポット&lt;/a&gt; - エスプレッソマシンなど買えない．圧力はマシンに及ばないがそれに近しいものは淹れることができる．ど濃いコーヒーを飲みたい時に良い．イタリアにはどの家庭にもあるらしい．&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aerobie.com/product/aeropress/&#34;&gt;AeroPress&lt;/a&gt; - 素早く淹れられて洗うのも簡単．使い方次第でいろいろな淹れ方ができて面白い（大会もあるとか）．これは買ったばかりでまだうまく使えていないのでこれからもっとうまくなりたい．&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B0092UDYLQ&#34;&gt;HARIO フレンチプレス&lt;/a&gt; - なかなか難しいが面白い味のコーヒーを作れる．友人からプレゼントしてもらった．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ちなみにカップは&lt;a href=&#34;http://fourbarrelcoffee.com/&#34;&gt;Four Barrel Coffee&lt;/a&gt;のもの．ここで飲んだコーヒーが今まで飲んだなかで一番美味しかった．&lt;/p&gt;

&lt;h2 id=&#34;再現性&#34;&gt;再現性&lt;/h2&gt;

&lt;p&gt;過去の自分のコーヒーの淹れ方には同じ豆を使っているのに再現性がないという問題があった．それもそもはずで計測などしないで感覚でやっていたのが原因．再現性への回答は計測すること．&lt;/p&gt;

&lt;p&gt;抽出の味のファクターは豆の量，グラインドの細かさ，抽出時間，お湯の量，お湯の温度である．&lt;a href=&#34;http://www.amazon.co.jp/dp/B009GPJMOU&#34;&gt;HARIOのドリップスケール&lt;/a&gt;にははかりとタイマーが付いている．これは最高のツールで豆の量とお湯の量，抽出時間を計測しながらコーヒーを抽出することができる．これを導入したことで再現性は飛躍的に高まった．&lt;/p&gt;

&lt;p&gt;使い方を簡単に説明する．まず以下のように豆の量を測る．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/coffee-beans.JPG&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;次に抽出．以下はChemexを使った例．抽出しながら，時間とお湯の量を測ることができる（温度計は別途購入した）．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/coffee-brew1.JPG&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/coffee-brew2.JPG&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;豆の量や抽出時間はどこから知るのか? サードウェーブ系のロースターでは豆を買う時に聞けば大抵どこでも教えてくれる．場所によっては豆のグラインドのサンプルもくれる．簡単な説明書みたなのを準備してるところもある．新鮮な豆とそれを淹れるためのレシピを聞けば自宅でそれを再現することは容易い（しかもロースターで飲むと1杯500円くらいする．豆は100gあたり800円-1000円の価格帯になる．1杯あたりは10-15gの豆を使うので自分で淹れれば1杯100-150円程度になる．つまり自分で淹れたほうが断然良い）．&lt;/p&gt;

&lt;p&gt;この手法でドリップであれば5分程度で最高の味を再現できるようになった．&lt;/p&gt;

&lt;h2 id=&#34;課題&#34;&gt;課題&lt;/h2&gt;

&lt;p&gt;だいぶ良い感じに美味しいコーヒーを淹れることができるようになったが，まだまだ課題がある．&lt;/p&gt;

&lt;h3 id=&#34;言語&#34;&gt;言語&lt;/h3&gt;

&lt;p&gt;まだうまく豆を買えない．とにかく味の表現が複雑すぎる．昔ながらの苦味/酸味だけではなくなっている．例えば&lt;a href=&#34;http://www.allianceforcoffeeexcellence.org/en/&#34;&gt;Cup of excellence&lt;/a&gt;の評価項目にはSweetness，Acidity，Mouth Feel，Flavour，Aftertasteがある．店に行ってもダークチェリーだのオレンジだのチョコレートだのたくさんの表現が並んでいて混乱する．&lt;/p&gt;

&lt;p&gt;これは新しいプログラミング言語を学ぶときに大変なのと同じかなと思う．新しい言語は宇宙語に感じてしまう．とにかく量をこなして身につけていくしかない．&lt;/p&gt;

&lt;h3 id=&#34;場所&#34;&gt;場所&lt;/h3&gt;

&lt;p&gt;今は自宅でしかちゃんとしたものを淹れることができない．&lt;a href=&#34;https://david-smith.org/blog/2014/05/22/my-travel-coffee-kit/&#34;&gt;My Travel Coffee Kit&lt;/a&gt;にあるように出張先でも最高のコーヒーを淹れられるようになりたい．&lt;/p&gt;

&lt;h2 id=&#34;書籍&#34;&gt;書籍&lt;/h2&gt;

&lt;p&gt;最後に面白かった書籍をいくつか．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B00CQW6XLK&#34;&gt;サードウェーブ！：サンフランシスコ周辺で体験した最新コーヒーカルチャー&lt;/a&gt; - サードウェーブ系の文化を学ぶ入り口としてとても良い．&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4388251143&#34;&gt;コーヒー「こつ」の科学 - コーヒーを正しく知るため&lt;/a&gt; - コーヒーの基礎知識を科学的な視点から説明している書籍（例えば酸味成分と苦味成分がどのように抽出されるのか，それはなぜかを知れたりする）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp//dp/483872540X&#34;&gt;美味しいコーヒーって何だ?&lt;/a&gt; - ロースターたちが最近のサードウェーブの流れを含めて焙煎についてあれこれ語る本．特に鹿児島のVOILAの井ノ上達也さんの話はとても面白い．昔のコーヒーの問題と今の状況がすごくクリアになった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fuglentyo.thebase.in/items/2027086&#34;&gt;COFFEE WITH TIM WENDELBOE&lt;/a&gt; - バリスタチャンピオンによる自宅での美味しいコーヒーの淹れ方．一番今っぽい淹れ方を丁寧に書いている本だと思う．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://bluebottlecoffee.com/store/blue-bottle-craft-of-coffee&#34;&gt;Blue Bottle本&lt;/a&gt;は読まないといけないなあと思いつつ積んでいる．年末年始にでも読もうと思う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go言語でLet&#39;s EncryptのACMEを理解する</title>
      <link>http://deeeet.com/writing/2015/12/01/go-letsencrypt-acme/</link>
      <pubDate>Tue, 01 Dec 2015 23:18:42 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/12/01/go-letsencrypt-acme/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://letsencrypt.org/&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s EncryptのベースのプロトコルであるACMEを理解する．&lt;/p&gt;

&lt;p&gt;まずACMEをベースとしたCAである&lt;a href=&#34;https://github.com/letsencrypt/boulder/&#34;&gt;boulder&lt;/a&gt;をローカルで動かす．次にACMEのGo言語クライアントライブラリである&lt;a href=&#34;https://github.com/ericchiang/letsencrypt&#34;&gt;ericchiang/letsencrypt&lt;/a&gt;（非公式）を使い実際にboulderと喋りながら証明書発行を行い，コードとともにACMEが具体的にどのようなものなのかを追う．&lt;/p&gt;

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;証明書というのは面倒なもの，少なくともカジュアルなものではない，というイメージが強い．それは有料であることや自動化しにくいなどといったことに起因している（と思う）．そのようなイメージに反して近年登場する最新の技術/プロトコルはTLSを前提にしているものが少なくない（e.g., HTTP2）．&lt;/p&gt;

&lt;p&gt;このような背景の中で登場したのがLet&amp;rsquo;s Encryptと呼ばれるCAである．Let&amp;rsquo;s Encryptは上で挙げたような問題（煩雑さ）を解決しようとしており，無料・自動・オープンを掲げている（cf. &lt;a href=&#34;http://jxck.hatenablog.com/entry/letsencrypt-acme&#34;&gt;&amp;ldquo;Let&amp;rsquo;s Encrypt を支える ACME プロトコル&amp;rdquo;&lt;/a&gt;）．最近（2015年12月3日）Public Betaが&lt;a href=&#34;https://letsencrypt.org/2015/12/03/entering-public-beta.html&#34;&gt;アナウンスされ&lt;/a&gt;すでに1日に70kの証明証が発行され始めており（cf. &lt;a href=&#34;https://letsencrypt.org/stats/&#34;&gt;Let&amp;rsquo;s Encrypt Stats&lt;/a&gt;）大きな期待が寄せられている．特に自分は仕事で多くのドメインを扱うのでLet&amp;rsquo;s Encryptは使ってくぞ！という意識がある．&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s EncryptはDV証明書を発行することができるCAである．DV証明書とはドメインの所有を確認して発行されるタイプの証明書である．Let&amp;rsquo;s Encryptの大きな特徴の1つに自動化が挙げられる．申請からドメインの所有の確認，証明書発行までは全てコマンドラインで完結させることができる．そしてこのフローはLet&amp;rsquo;s Encrypt以外のCAでも利用できるように&lt;a href=&#34;https://github.com/ietf-wg-acme/acme/&#34;&gt;標準化が進められている&lt;/a&gt;．これはAutomated Certificate Management Environment（ACME）プロトコルと呼ばれる（ちなみにLet&amp;rsquo;s encryptの証明証の有効期限は90日である．これはセキュリティ強化の面もあるが自動化の促進という面もある（cf. &lt;a href=&#34;https://letsencrypt.org/2015/11/09/why-90-days.html&#34;&gt;Why ninety-day lifetimes for certificates?&lt;/a&gt;））．&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s Encryptは専用のACMEクライアントを提供している（&lt;a href=&#34;https://github.com/letsencrypt/letsencrypt&#34;&gt;letsencrypt&lt;/a&gt;）．基本はこれを使えば証明書の発行や，Apacheやnginxの設定ファイルの書き換え(!)などができる（やりすぎ感が気にくわないと感じるひとが多いようでsimple alternativeがいくつか登場している&amp;hellip;）．&lt;/p&gt;

&lt;p&gt;それだけではなくACMEベースのCA（つまりLet&amp;rsquo;s encrypt）は&lt;a href=&#34;https://github.com/letsencrypt/boulder/&#34;&gt;Boulder&lt;/a&gt;とう名前でOSSベースで開発されている（Go言語で実装されている）．つまりBoulderを使えば誰でもACMEをサポートしたCAになることができる．&lt;/p&gt;

&lt;p&gt;本記事ではおそらく将来的には意識しないでよくなる（であろう）ACMEプロトコルがどのようなものかを理解する．boulderをローカルで動かし（&lt;code&gt;Dockerfile&lt;/code&gt;が提供されている），非公式であるがGo言語のACMEクライアント&lt;a href=&#34;https://github.com/ericchiang/letsencrypt&#34;&gt;ericchiang/letsencrypt&lt;/a&gt;を使ってACMEを喋ってみる．&lt;/p&gt;

&lt;p&gt;なおACMEはまだ仕様策定中なので以下の説明は変更される可能性がある．&lt;/p&gt;

&lt;h2 id=&#34;boulderを動かす&#34;&gt;boulderを動かす&lt;/h2&gt;

&lt;p&gt;まず準備としてboulderを動かす．今回は例として&lt;code&gt;example.org&lt;/code&gt;の証明証を発行する．ローカルでこれを実行するためには以下の準備が必要になる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cmd/policy-loader/base-rules.json&lt;/code&gt;のブラックリストから&lt;code&gt;example.org&lt;/code&gt;を外す&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/hosts&lt;/code&gt;を編集して&lt;code&gt;example.org&lt;/code&gt;を&lt;code&gt;127.0.0.1&lt;/code&gt;に向ける&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完了したらboulderコンテナを起動する．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/letsencrypt/boulder/
$ ./test/run-docker.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;acmeの概要&#34;&gt;ACMEの概要&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ietf-wg-acme/acme/&#34;&gt;ACME spec draft&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ACMEとは「クライアントのドメインの所有を確認して証明書を発行する」ためのプロトコルであった．これをさらに細かくブレイクダウンすると以下の操作から構成される．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;各操作を行うためのURIを知る（directory）&lt;/li&gt;
&lt;li&gt;クライアントの登録を行う（new-registration）&lt;/li&gt;
&lt;li&gt;認証（ドメイン所有の確認）を行う（new-authorization）&lt;/li&gt;
&lt;li&gt;証明書（Certification）を発行する（new-certificate）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ACMEはこれらのリソースを持ったRESTアプリケーションであるとみなすこともできる．各リソースはその上のリソースに依存しており，上から順番にリクエストをこなしていくことで最後の証明書の発行に到達することになる．&lt;/p&gt;

&lt;p&gt;以下ではこれらのリソースをさらに細かく見ていく．&lt;/p&gt;

&lt;h2 id=&#34;directory&#34;&gt;directory&lt;/h2&gt;

&lt;p&gt;directoryは他の各種リソースのURIをクライアントに提示する．クライアントはまずここにリクエストしその後の操作でリクエストするべきendpointを知る．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ericchiang/letsencrypt&lt;/code&gt;を使うと以下のようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;client, err := letsencrypt.NewClient(&amp;quot;http://localhost:4000/directory&amp;quot;)
if err != nil {
    log.Fatal(err)
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NewClient&lt;/code&gt;はdirectoryにリクエストを投げ以下の操作で必要なendopointを保持した&lt;code&gt;client&lt;/code&gt;を作成する．&lt;/p&gt;

&lt;h2 id=&#34;new-registration&#34;&gt;new-registration&lt;/h2&gt;

&lt;p&gt;new-registrationはクライアントの登録を行う．具体的にはRSAもしくはECDSAの公開鍵を登録する．ここで登録した鍵は以後のすべてのリクエストで利用する．ここではRSAを利用する．以下で事前に生成しておく．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ssh-keygen -t rsa -b 4096 -C &amp;quot;tcnksm@mail.com&amp;quot; -f letsencrypt-test -N &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コードは以下のようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;client, err := letsencrypt.NewClient(&amp;quot;http://localhost:4000/directory&amp;quot;)
if err != nil {
    log.Fatal(err)
}

data, err := ioutil.ReadFile(&amp;quot;letsencrypt-test&amp;quot;)
if err != nil {
    log.Fatal(err)
}

block, _ := pem.Decode(data)
key, err := x509.ParsePKCS1PrivateKey(block.Bytes)
if err != nil {
    log.Fatal(err)
}

if _, err := client.NewRegistration(key); err != nil {
    log.Fatal(err)
}

log.Println(&amp;quot;Registered&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事前に生成した鍵ファイルを読み込みデコードして&lt;code&gt;NewRegistration&lt;/code&gt;を呼ぶ（cf. &lt;a href=&#34;http://deeeet.com/writing/2015/11/10/go-crypto/&#34;&gt;Go言語と暗号技術（AESからTLS）&lt;/a&gt;に書いた）．これで登録が完了する．&lt;/p&gt;

&lt;p&gt;この鍵はnew-registrationだけではなくこの後の各リクエストの署名とその検証にも利用される．具体的にはクライアントはリクエストするJSONをJWSという仕様に基づき署名する．そしてサーバーはリクエストを受けると処理を始める前にそのJWSによる署名の検証を行う．&lt;/p&gt;

&lt;p&gt;ちなみに公開鍵はどのようにサーバーに送られるのか? これにはJWKという仕様がありそれに基づき送信される（JWSやJWKといったJWxの技術に関しては&lt;a href=&#34;https://twitter.com/lestrrat&#34;&gt;@lestrrat&lt;/a&gt;さんのブログ記事&lt;a href=&#34;http://hde-advent-2015.hatenadiary.jp/entry/2015/12/02/095643&#34;&gt;&amp;ldquo;GoでOAuth2/OpenIDとJOSE (JWA/JWT/JWK/JWS/JWE)&amp;rdquo;&lt;/a&gt;が詳しい）．&lt;/p&gt;

&lt;h2 id=&#34;new-authorization&#34;&gt;new-authorization&lt;/h2&gt;

&lt;p&gt;new-authorizationではドメインの所有の確認を行い認証を行う．具体的にそのドメインの所有をどのように確認するのか? それにはドメインの所有者にしかできない特定の操作を行わせることで確認を行う．ACMEではこの操作を&lt;strong&gt;Challenge&lt;/strong&gt;と呼ぶ．&lt;/p&gt;

&lt;p&gt;現在（2015年12月）Challengeには&lt;code&gt;http-01&lt;/code&gt;や&lt;code&gt;tls-sni-01&lt;/code&gt;といったものがある．例えば&lt;code&gt;http-01&lt;/code&gt;はクライアントのサーバー上の特定のパスに指定された内容のテキストファイルを配置させ，そこにアクセスし予期するファイルが配置されているかで確認を行う．&lt;/p&gt;

&lt;p&gt;認証は以下のような流れで行われる．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;クライアントはnew-authorizationリソースにPOSTリクエストを送る（POSTリクエストのBodyにはJWSが含まれていなけばならない）&lt;/li&gt;
&lt;li&gt;サーバーは利用可能なChallengeとそのうち達成するべき組み合わせ（複数のChallengeの達成を要求することもできる）を返答する&lt;/li&gt;
&lt;li&gt;クライアントはChallengeに応える&lt;/li&gt;
&lt;li&gt;サーバーはChallengeの達成を確認する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;コードで書くと以下のようになる．まずChallengeの取得を行う（&lt;code&gt;client&lt;/code&gt;の初期化と&lt;code&gt;key&lt;/code&gt;の読み込みは完了しているとする）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;auth, _, err := client.NewAuthorization(key, &amp;quot;dns&amp;quot;, &amp;quot;example.org&amp;quot;)
if err != nil {
    log.Fatal(err)
}

log.Println(&amp;quot;[INFO] Challenges:&amp;quot;)
for _, challenge := range auth.Challenges {
    log.Println(&amp;quot;  &amp;quot;, challenge.Type, challenge.URI)
}

var combs string
for _, comb := range auth.Combs {
    combs += fmt.Sprintf(&amp;quot;%v &amp;quot;, comb)
}
log.Println(&amp;quot;[INFO] Combinations:&amp;quot;, combs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると以下のような結果が得られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2015/12/05 17:16:44 [INFO] Challenges:
  dns-01 http://127.0.0.1:4000/acme/challenge/FQ01uZjCoY13Z5Jak7..
  tls-sni-01 http://127.0.0.1:4000/acme/challenge/FQ01uZjCoY13Z5..
  dvsni http://127.0.0.1:4000/acme/challenge/FQ01uZjCoY13Z5Jak7H..
  http-01 http://127.0.0.1:4000/acme/challenge/FQ01uZjCoY13Z5Jak..
  simpleHttp http://127.0.0.1:4000/acme/challenge/FQ01uZjCoY13Z5..
  
2015/12/05 17:16:44 [INFO] Combinations: [0] [1] [2] [3] [4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在の&lt;code&gt;boulder&lt;/code&gt;のdevモードは4つのChallengeを返す（&lt;code&gt;simpleHttp&lt;/code&gt;と&lt;code&gt;dvsni&lt;/code&gt;はdeprecatedなので無視してもよい &lt;a href=&#34;https://github.com/letsencrypt/acme-spec/issues/231&#34;&gt;#231&lt;/a&gt;）．&lt;code&gt;challenge.URI&lt;/code&gt;は具体的なChallengeに必要となる情報（例えば&lt;code&gt;http-01&lt;/code&gt;の場合はサーバーにアクセスさせるためのパスとそこに配置するリソース）を取得するためのendpointである．そして組み合わせ（&lt;code&gt;Combs&lt;/code&gt;）は指定されておらずどれか1つでも達成すればよい．&lt;/p&gt;

&lt;p&gt;次に実際にChallengeを達成する．ここでは&lt;code&gt;http-01&lt;/code&gt;を達成する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;auth, _, err := client.NewAuthorization(key, &amp;quot;dns&amp;quot;, &amp;quot;example.org&amp;quot;)
if err != nil {
    log.Fatal(err)
}

var httpChallengeURI string
for _, challenge := range auth.Challenges {
    if challenge.Type == &amp;quot;http-01&amp;quot; {
        log.Println(&amp;quot;[INFO]&amp;quot;, challenge.Type, challenge.URI)
        httpChallengeURI = challenge.URI
    }
}

if httpChallengeURI == &amp;quot;&amp;quot; {
    log.Fatal(&amp;quot;httpChallengeURI should not be empty&amp;quot;)
}

challenge, err := client.Challenge(httpChallengeURI)
if err != nil {
    log.Fatal(err)
}

b, err := json.MarshalIndent(&amp;amp;challenge, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
if err != nil {
    log.Fatal(err)
}
log.Println(&amp;quot;[INFO]&amp;quot;, string(b))

path, resource, err := challenge.HTTP(key)
if err != nil {
    log.Fatal(err)
}

go func() {
    http.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {
        io.WriteString(w, resource)
    })

    // The test Let&#39;s Encrypt server uses port 5002 instead of 80.
    if err := http.ListenAndServe(&amp;quot;:5002&amp;quot;, nil); err != nil {
        log.Fatal(err)
    }
}()

if err := client.ChallengeReady(key, challenge); err != nil {
    log.Fatal(err)
}

log.Println(&amp;quot;[INFO] Complete challenge!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のようなことをしている．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;サーバーが受け付け可能なChallengeをリクエストする（&lt;code&gt;NewAuthorization&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http-01&lt;/code&gt;を選択し具体的なアクションのために必要となる情報をリクエストする（&lt;code&gt;Challenge&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;上のレスポンスから&lt;code&gt;http-01&lt;/code&gt;に必要なサーバーからリクエストされる&lt;code&gt;path&lt;/code&gt;とその&lt;code&gt;resource&lt;/code&gt;を取得する（&lt;code&gt;HTTP&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt;にて&lt;code&gt;resource&lt;/code&gt;をserveするようにサーバーを起動する（goroutine）&lt;/li&gt;
&lt;li&gt;Challgenが準備できたことをサーバーに伝えValidateしてもらう（&lt;code&gt;ChallengeReady&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これで認証は完了する．あとは&lt;code&gt;csr&lt;/code&gt;を送れば証明書を取得することができる．&lt;/p&gt;

&lt;h2 id=&#34;new-certification&#34;&gt;new-certification&lt;/h2&gt;

&lt;p&gt;new-certificationは新しい証明書の発行を行う．&lt;/p&gt;

&lt;p&gt;まず&lt;code&gt;.csr&lt;/code&gt;ファイルを作成する．&lt;code&gt;.csr&lt;/code&gt;の作成は&lt;code&gt;openssl&lt;/code&gt;コマンドなどでも可能だがここではGo言語で作成する．Go言語で証明書を操作するには&lt;code&gt;x509&lt;/code&gt;パッケージを使えばよい（詳しくは&lt;a href=&#34;http://deeeet.com/writing/2015/11/10/go-crypto/&#34;&gt;Go言語と暗号技術（AESからTLS）&lt;/a&gt;）．コードは以下．RSAを使う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;certKey, err := rsa.GenerateKey(rand.Reader, 2048)
if err != nil {
    log.Fatal(err)
}

template := x509.CertificateRequest{
    SignatureAlgorithm: x509.SHA256WithRSA,
    PublicKeyAlgorithm: x509.RSA,
    PublicKey:          &amp;amp;certKey.PublicKey,
    Subject:            pkix.Name{CommonName: &amp;quot;example.org&amp;quot;},
    DNSNames:           []string{&amp;quot;example.org&amp;quot;},
}

if err != nil {
    log.Fatal(err)
}

csrOut, err := os.Create(&amp;quot;example.org.csr&amp;quot;)
if err != nil {
    log.Fatal(err)
}
defer csrOut.Close()

if err := pem.Encode(csrOut, &amp;amp;pem.Block{
    Type:  &amp;quot;CERTIFICATE REQUEST&amp;quot;,
    Bytes: csrDerByte,
}); err != nil {
    log.Fatal(err)
}

keyOut, err := os.Create(&amp;quot;example.org.key&amp;quot;)
if err != nil {
    log.Fatal(err)
}

if err := pem.Encode(keyOut, &amp;amp;pem.Block{
    Type:  &amp;quot;RSA PRIVATE KEY&amp;quot;,
    Bytes: x509.MarshalPKCS1PrivateKey(certKey),
}); err != nil {
    log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;example.org.csr&lt;/code&gt;と&lt;code&gt;example.org.key&lt;/code&gt;が生成できる．&lt;/p&gt;

&lt;p&gt;次に証明書の発行を行う．コードは以下（&lt;code&gt;client&lt;/code&gt;の初期化と&lt;code&gt;key&lt;/code&gt;の読み込みは完了しているとする）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;csrData, err := ioutil.ReadFile(&amp;quot;example.org.csr&amp;quot;)
if err != nil {
    log.Fatal(err)
}

csrBlock, _ := pem.Decode(csrData)
csr, err := x509.ParseCertificateRequest(csrBlock.Bytes)
if err != nil {
    log.Fatal(err)
}

cert, err := client.NewCertificate(key, csr)
if err != nil {
    log.Fatal(err)
}

certOut, err := os.Create(&amp;quot;example.org.crt&amp;quot;)
if err != nil {
    log.Fatal(err)
}

if err := pem.Encode(certOut, &amp;amp;pem.Block{
    Type:  &amp;quot;CERTIFICATE&amp;quot;,
    Bytes: cert.Raw,
}); err != nil {
    log.Fatal(err)
}

log.Println(&amp;quot;[INFO] Successfully issued&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上で生成した&lt;code&gt;.csr&lt;/code&gt;を読み込み&lt;code&gt;NewCertificate&lt;/code&gt;を呼ぶだけ．簡単．&lt;/p&gt;

&lt;h2 id=&#34;証明書の検証&#34;&gt;証明書の検証&lt;/h2&gt;

&lt;p&gt;最後に証明書の検証を行う．Go言語で証明書の検証は以下のように書ける（&lt;code&gt;boulder&lt;/code&gt;のDevモードの場合は&lt;code&gt;test&lt;/code&gt;ディレクトリ以下に&lt;code&gt;test-ca.pem&lt;/code&gt;があるのでそれを使う）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;caData, err := ioutil.ReadFile(&amp;quot;./test-ca.pem&amp;quot;)
roots := x509.NewCertPool()
if ok := roots.AppendCertsFromPEM(caData); !ok {
    log.Fatal(&amp;quot;Failed to parse ca pem&amp;quot;)
}

certData, err := ioutil.ReadFile(&amp;quot;./example.org.crt&amp;quot;)
certBlock, _ := pem.Decode(certData)
cert, err := x509.ParseCertificate(certBlock.Bytes)
if err != nil {
    log.Fatal(err)
}

opts := x509.VerifyOptions{
    DNSName: &amp;quot;example.org&amp;quot;,
    Roots:   roots,
}

if _, err := cert.Verify(opts); err != nil {
    log.Fatal(err)
}

log.Println(&amp;quot;[INFO] Verified !&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;本記事ではACMEをベースとしたCAであるboulderをローカルで動かし，ACMEのGo言語クライアントライブラリを使いながらACMEの詳細を追ってみた．Webの基本の技術を組み合わせているだけなので特に複雑ではない．200行のpythonで書かれたACMEツールなどもある（cf. &lt;a href=&#34;https://github.com/diafygi/acme-tiny&#34;&gt;diafygi/acme-tiny&lt;/a&gt;）のでいろいろ探ってみたら面白いと思う．&lt;/p&gt;

&lt;p&gt;どんどんTLSにしていくぞ！&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ietf-wg-acme/acme/&#34;&gt;ACME spec draft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://letsencrypt.org/stats/&#34;&gt;Let&amp;rsquo;s Encrypt Stats&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/letsencrypt/boulder&#34;&gt;boulder: An ACME-based CA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/letsencrypt/boulder/blob/master/DESIGN.md&#34;&gt;Boulder flow diagrams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://letsencrypt.org/2015/11/12/public-beta-timing.html&#34;&gt;Public Beta: December 3, 2015&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://letsencrypt.org/2015/10/19/lets-encrypt-is-trusted.html&#34;&gt;Let&amp;rsquo;s Encrypt is Trusted&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://letsencrypt.org/2015/11/09/why-90-days.html&#34;&gt;Why ninety-day lifetimes for certificates?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/letsencrypt-acme&#34;&gt;Let&amp;rsquo;s Encrypt を支える ACME プロトコル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hlandau/acme&#34;&gt;hlandau/acme&lt;/a&gt;, &lt;a href=&#34;https://github.com/xenolf/lego&#34;&gt;xenolf/lego&lt;/a&gt;, &lt;a href=&#34;https://github.com/diafygi/acme-tiny&#34;&gt;diafygi/acme-tiny&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ericchiang.github.io/go/tls/lets/encrypt/letsencrypt/2015/11/13/a-letsencrypt-client-for-go.html&#34;&gt;A Let&amp;rsquo;s Encrypt Client for Go&lt;/a&gt; (&lt;a href=&#34;https://github.com/ericchiang/letsencrypt&#34;&gt;ericchiang/letsencrypt&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/rrreeeyyy/lets-encrypt-and-acme-overview-hbstyle-2015-1112&#34;&gt;Let&amp;rsquo;s Encrypt &amp;amp; ACME Overview (hbstyle-2015-1112)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lolware.net/2015/10/27/letsencrypt_go_live.html&#34;&gt;Using Lets Encrypt&lt;/a&gt; (RubyでACMEを喋りたい場合に参考になる)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.kazuhooku.com/2015/12/using-h2o-with-lets-encrypt.html&#34;&gt;Using H2O with Let&amp;rsquo;s Encrypt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hde-advent-2015.hatenadiary.jp/entry/2015/12/02/095643&#34;&gt;GoでOAuth2/OpenIDとJOSE (JWA/JWT/JWK/JWS/JWE)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go言語とHTTP2</title>
      <link>http://deeeet.com/writing/2015/11/19/go-http2/</link>
      <pubDate>Thu, 19 Nov 2015 01:30:18 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/11/19/go-http2/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://golang.org/s/http2iscoming&#34;&gt;http2 in Go 1.6; dotGo 2015 - Google スライド&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2015年の5月に&lt;a href=&#34;http://www.rfc-editor.org/rfc/rfc7540.txt&#34;&gt;RFC&lt;/a&gt;が出たばかりのHTTP2が2016年の2月に&lt;a href=&#34;https://github.com/golang/go/milestones&#34;&gt;リリース予定&lt;/a&gt;のGo1.6で早くも利用可能になることになっている．HTTP2の勉強も兼ねてGo言語におけるHTTP2実装を追ってみる．&lt;/p&gt;

&lt;p&gt;以下ではまず実際にHTTP2サーバを動かしChromeで接続してみる．次に現状コードがどのように管理されているかを追う．最後に実際にコードを動かしながらHTTP2の各種機能を追う．なお参照するコードはすべて以下のバージョンを利用している（まだWIPなのでコードなどは今後変わる可能性があるので注意）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go version
go version devel +9b299c1  darwin/amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;http2とは&#34;&gt;HTTP2とは?&lt;/h2&gt;

&lt;p&gt;HTTP/2に関してはスライドやブログ記事，Podcastなど非常に豊富な情報がインターネット上に存在する．そもそもHTTP2とは何か?なぜ必要なのか?などを理解したい場合は&lt;a href=&#34;#cf&#34;&gt;参考&lt;/a&gt;に挙げた記事などを参照するのがよい．&lt;/p&gt;

&lt;h2 id=&#34;実際に使ってみる&#34;&gt;実際に使ってみる&lt;/h2&gt;

&lt;p&gt;最小限のコードでHTTP2サーバーを起動しChromeで接続してみる．&lt;/p&gt;

&lt;p&gt;まず最新のGoをソースからビルドする（ビルドにはGo1.5.1を利用する）．以下では2015年11月16日時点の最新を利用した．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone --depth=1 https://go.googlesource.com/go ~/.go/latest
$ export GOROOT_BOOTSTRAP=~/.go/1.5.1
$ cd ~/.go/latest/src &amp;amp;&amp;amp; ./make.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現時点でGoにおけるHTTP2はover TLSが前提になっている．そのためサーバー証明書と鍵が必要になる（なければ事前に&lt;code&gt;openssl&lt;/code&gt;コマンドや&lt;code&gt;crypto/x509&lt;/code&gt;パッケージなどを使って自己署名証明書をつくる）．&lt;/p&gt;

&lt;p&gt;コードは以下．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
    certFile, _ := filepath.Abs(&amp;quot;server.crt&amp;quot;)
    keyFile, _ := filepath.Abs(&amp;quot;server.key&amp;quot;)
    
    http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
       fmt.Fprintf(w, &amp;quot;Protocol: %s\n&amp;quot;, r.Proto)
    })

    err := http.ListenAndServeTLS(&amp;quot;:3000&amp;quot;, certFile, keyFile, nil)
    if err != nil {
        log.Printf(&amp;quot;[ERROR] %s&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;証明書と鍵を読み込んで&lt;code&gt;ListenAndServeTLS&lt;/code&gt;を呼ぶだけ．HTTP2のために特別なことをする必要はない．クライアントがHTTP2に対応していれば勝手にHTTP2が使われる．起動して接続すると以下のように「Protocol: HTTP/2.0」が確認できる（Chrome拡張の&lt;a href=&#34;https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin?hl=ja&#34;&gt;HTTP/2 and SPDY indicator&lt;/a&gt;が反応しているのも確認できる）．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/http2.png&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;コードの行方&#34;&gt;コードの行方&lt;/h2&gt;

&lt;p&gt;現在HTTP2のコードはどのように管理されているのか? もともとは&lt;a href=&#34;https://github.com/bradfitz&#34;&gt;bradfitz&lt;/a&gt;氏により&lt;a href=&#34;https://github.com/bradfitz/http2&#34;&gt;bradfitz/http2&lt;/a&gt;で実装が進められていた．そして&lt;a href=&#34;https://godoc.org/golang.org/x/net/http2&#34;&gt;golang.org/x/net/http2&lt;/a&gt;に移動した．ちなみにGo1.5以前でもこちらのパッケージを使えばHTTP2を&lt;a href=&#34;http://www.integralist.co.uk/posts/http2.html#10&#34;&gt;使うことはできる&lt;/a&gt;．&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;http2&lt;/code&gt;パッケージの位置付けはローレベルなHTTP2の実装であり普通のひとは触ることがない．Go1.6では普通のひとが触るハイレベルなインターフェースは今まで通りの&lt;code&gt;net/http&lt;/code&gt;となる．&lt;/p&gt;

&lt;p&gt;では最新のGoのコードにはどのようにマージされたのか? まずヘッダ圧縮の&lt;a href=&#34;https://tools.ietf.org/html/rfc7541&#34;&gt;HPACK&lt;/a&gt;は&lt;code&gt;http2/hpack&lt;/code&gt;という名前でサブディレクトリに別パッケージとして実装されている．これは&lt;code&gt;src/vendor&lt;/code&gt;以下にvendoringされている．&lt;code&gt;http2&lt;/code&gt;も同様にvendoringされているだけかと思ったが，こちらは&lt;code&gt;net/http&lt;/code&gt;パッケージに&lt;code&gt;h2_bundle.go&lt;/code&gt;という1つのファイルとして組み込まれている．&lt;/p&gt;

&lt;p&gt;具体的な経緯は&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-dev/8Qjr03xf07U&#34;&gt;http -&amp;gt; http2 -&amp;gt; http import cycle&lt;/a&gt;を読むとわかるが，単純にvendoringすると&lt;code&gt;net/http&lt;/code&gt;-&amp;gt;&lt;code&gt;http2&lt;/code&gt;と&lt;code&gt;http2&lt;/code&gt;-&amp;gt;&lt;code&gt;net/http&lt;/code&gt;というimport cycleが起こってしまう．これは上の例で示したようにAPIの変更なしにHTTP2を有効にするというゴールを達成するためには避けられない．&lt;/p&gt;

&lt;p&gt;これを解決するために使われたのが&lt;a href=&#34;https://godoc.org/golang.org/x/tools/cmd/bundle&#34;&gt;bundleコマンド&lt;/a&gt;である．これはパッケージを別パッケージとして1つのファイルにするコマンド．以下のように使われる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle golang.org/x/net/http2 net/http http2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;golang.org/x/net/http2&lt;/code&gt;を&lt;code&gt;net/http&lt;/code&gt;パッケージとして&lt;code&gt;http2&lt;/code&gt;というprefixをつけて一つのファイルにまとめるいうことがおこる．&lt;/p&gt;

&lt;p&gt;変更はどうするのか? &lt;code&gt;bundle&lt;/code&gt;はテストを無視するため変更はテストがちゃんとある&lt;a href=&#34;https://godoc.org/golang.org/x/net/http2&#34;&gt;golang.org/x/net/http2&lt;/a&gt;に入り，その都度&lt;code&gt;bundle&lt;/code&gt;してマージとなるらしい（リリースまでは）．&lt;/p&gt;

&lt;p&gt;&amp;hellip; というのが現状．正式なリリースまでに時間はあるのでどうなるのかはわからない．&lt;/p&gt;

&lt;h2 id=&#34;http2の機能を追う&#34;&gt;HTTP2の機能を追う&lt;/h2&gt;

&lt;p&gt;以下ではHTTP2の主な機能がどのようにGo言語で実装されているのかを見ていく．&lt;/p&gt;

&lt;h3 id=&#34;フレームとストリーム&#34;&gt;フレームとストリーム&lt;/h3&gt;

&lt;p&gt;HTTP1.xではリクエスト/レスポンスのフォーマットにテキストが利用されてきた．HTTP2ではフレームと呼ばれるバイナリのフォーマットが利用される．これにより転送量の低減を実現している．&lt;/p&gt;

&lt;p&gt;フレームには&lt;a href=&#34;https://tools.ietf.org/html/rfc7540#section-6&#34;&gt;いくつかのタイプが定義されている&lt;/a&gt;．例えばHTTP1.xのヘッダにあたるHEADERS，HTTP1.xのBody部にあたるDATAなどがある．フレームは以下のようなフォーマットで表現される（cf. &lt;a href=&#34;https://tools.ietf.org/html/rfc7540#section-4&#34;&gt;4.HTTP Frames&lt;/a&gt;）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTTP1.xでは1つのリソースを取得するために1つのTCPコネクションが必要である．つまり3つの画像が必要であれば3つのTCPコネクションが必要である．TCPはThree-way handshakingやスロースタートにより通信のオーバーヘッドが避けられない．そのため各コネクションはなるべく並列で確立されるのが望ましい．しかし同一オリジンへの同時接続数はたいてい6つに制限されている．つまり7つ目は先の6つのどれかが完了するまでブロックされる．これに対応するためにHTTP1.x時代では画像などを別ドメインから読み込むDomain Shardingという手法が一般的にはとられてきた（cf.&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-overview/&#34;&gt;HTTPリクエストを減らすために&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;HTTP2ではストリームという概念を導入し上記の問題を解決している．ストリームとは1つのTCPコネクション上に作られる仮想的な双方向シーケンスである．このストリームによりリクエストは多重化され複数のリソース取得も並列で実行可能になる．それぞれのリクエストとレスポンスはひとつのストリームで処理され，それぞれがユニークなIDをもつ．&lt;/p&gt;

&lt;p&gt;Go言語ではどう実装されているか．まず&lt;a href=&#34;https://godoc.org/golang.org/x/net/http2#Framer&#34;&gt;&lt;code&gt;Framer&lt;/code&gt;&lt;/a&gt;というstructがフレームの書き込みと読み込みを担う．そしてそれぞれのタイプのフレームの書き込みのために専用のメソッド，例えばDATAなら&lt;code&gt;WriteData&lt;/code&gt;，HEADERSなら&lt;code&gt;WriteHeaders&lt;/code&gt;，が準備されている．&lt;/p&gt;

&lt;p&gt;実際にDATAフレームを作って中身を覗いてみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;buf := new(bytes.Buffer)
fr := http2.NewFramer(buf, buf)

var streamID uint32 = 1&amp;lt;&amp;lt;24 + 2&amp;lt;&amp;lt;16 + 3&amp;lt;&amp;lt;8 + 4
fr.WriteData(streamID, true, []byte(&amp;quot;Hello&amp;quot;))

b := buf.Bytes()
fmt.Printf(&amp;quot;Frame: %q\n&amp;quot;, b)

fmt.Printf(&amp;quot;Type: %x\n&amp;quot;, b[4:5])    // Type: 01
fmt.Printf(&amp;quot;StremID: %x\n&amp;quot;, b[5:9]) // StremID: 01020304
fmt.Printf(&amp;quot;DATA: %x\n&amp;quot;, b[9:])     // DATA: 48656c6c6f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NewFramer&lt;/code&gt;で&lt;code&gt;Framer&lt;/code&gt;をつくり，&lt;code&gt;WriteData&lt;/code&gt;でストリームのIDとともにデータを書き込む．あとは書き込まれたデータを定義に基づき覗くと中身が見れる．&lt;/p&gt;

&lt;h3 id=&#34;ヘッダ圧縮&#34;&gt;ヘッダ圧縮&lt;/h3&gt;

&lt;p&gt;HTTPはステートレスなプロトコルである．そのためHTTP1.xでは1つのセッションで毎回似たようなヘッダを送る必要があり冗長である．HTTP2ではヘッダの圧縮を行う．ヘッダの圧縮にはHPACKと呼ばれる手法を用いる．HPACKは&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%95%E3%83%9E%E3%83%B3%E7%AC%A6%E5%8F%B7&#34;&gt;ハフマン符号化&lt;/a&gt;と静的/動的テーブルという仕組みで圧縮を行う手法である．HPACKはHTTP2とは別に&lt;a href=&#34;https://tools.ietf.org/html/rfc7541&#34;&gt;RFC 7541&lt;/a&gt;で仕様化されている．&lt;/p&gt;

&lt;p&gt;Go言語では&lt;code&gt;http2/hpack&lt;/code&gt;という名前で&lt;code&gt;http2&lt;/code&gt;パッケージのサブディレクトリに別パッケージとして実装されている．それぞれ実際に使ってみる．&lt;/p&gt;

&lt;p&gt;まずハフマン符号化．ハフマン符号は文字の出現頻度の偏りに合わせてビット列を割り当てる符号化である．ここでは例として&lt;code&gt;www.example.com&lt;/code&gt;という文字列をハフマン符号でEncode/Decodeしてみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;s := &amp;quot;www.example.com&amp;quot;

fmt.Println(len(s))
fmt.Println(hpack.HuffmanEncodeLength(s))

b := hpack.AppendHuffmanString(nil, s)
fmt.Printf(&amp;quot;%x\n&amp;quot;, b)

var buf bytes.Buffer
hpack.HuffmanDecode(&amp;amp;buf, b)

fmt.Printf(&amp;quot;%s\n&amp;quot;, buf.String())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の例では15バイトの文字列を12バイトに符号化できる．&lt;/p&gt;

&lt;p&gt;次にテーブルによる圧縮．HTTP2ではよく利用するヘッダをKey-Valueの辞書としてもちそのインデックスを示すことでヘッダを表現する．テーブルは仕様として事前に定義された（&lt;a href=&#34;https://tools.ietf.org/html/rfc7541#appendix-A&#34;&gt;Static Table Definition&lt;/a&gt;）静的テーブルとリクエストのやりとりの中で更新する動的テーブルがある．&lt;/p&gt;

&lt;p&gt;まず静的テーブルにエントリがある&lt;code&gt;:method GET&lt;/code&gt;をEncodeしてみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var buf bytes.Buffer
e := hpack.NewEncoder(&amp;amp;buf)

e.WriteField(hpack.HeaderField{
    Name:  &amp;quot;:method&amp;quot;,
    Value: &amp;quot;GET&amp;quot;,
})

fmt.Printf(&amp;quot;Encoded: %x (%d) \n&amp;quot;, buf.Bytes(), len(buf.Bytes()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは1バイトに圧縮される．&lt;/p&gt;

&lt;p&gt;次に静的テーブルにエントリのない&lt;code&gt;:authority www.example.com&lt;/code&gt;をEncodeしてみる．動的テーブルの効果をみるために2度実行する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var buf bytes.Buffer
e := hpack.NewEncoder(&amp;amp;buf)

e.WriteField(hpack.HeaderField{
    Name:  &amp;quot;:authority&amp;quot;,
    Value: &amp;quot;www.example.com&amp;quot;,
})

fmt.Printf(&amp;quot;Encoded: %x (%d) \n&amp;quot;, buf.Bytes(), len(buf.Bytes()))
buf.Reset()

e.WriteField(hpack.HeaderField{
    Name:  &amp;quot;:authority&amp;quot;,
    Value: &amp;quot;www.example.com&amp;quot;,
})

fmt.Printf(&amp;quot;Encoded: %x (%d) \n&amp;quot;, buf.Bytes(), len(buf.Bytes()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じヘッダに対して2度Encodeを実行する．まず1度目は動的テーブルにエントリがないため14バイトにしかならない．もしテーブルにエントリがない場合は，動的テーブルにそれが追加される．そして2度目の実行時はそのテーブルが参照され1バイトに圧縮される．&lt;/p&gt;

&lt;h3 id=&#34;優先度制御&#34;&gt;優先度制御&lt;/h3&gt;

&lt;p&gt;HTTP1.xでは全てのリクエストは平等に処理される．つまり画像もCSSもJSも全て平等に処理される．HTTP2ではクライアントがリクエストに優先度を指定することができる．例えばサイトのレンダリングが必要なCSSやJSを優先的にリクエストすることができる．これによりページの描画を改善しユーザの体感速度を向上することが期待できる．&lt;/p&gt;

&lt;p&gt;Go言語ではどうなっているのか．クライアントは&lt;a href=&#34;https://godoc.org/golang.org/x/net/http2#PriorityParam&#34;&gt;&lt;code&gt;PriorityParam&lt;/code&gt;&lt;/a&gt;というstructを用いて優先度の指定を行う．そしてHEADERSもしくはPRIOTIRYフレームでこれを送信する．&lt;/p&gt;

&lt;p&gt;次にサーバーの動き．これは外からは触れない．どう処理されるかはテストコードを見るのが良い．&lt;code&gt;priority_test.go&lt;/code&gt;を見る．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// A -&amp;gt; B
// move A&#39;s parent to B
streams := make(map[uint32]*stream)
a := &amp;amp;stream{
    parent: nil,
    weight: 16,
}
streams[1] = a

b := &amp;amp;stream{
    parent: a,
    weight: 16,
}
streams[2] = b

adjustStreamPriority(streams, 1, PriorityParam{
    Weight:    20,
    StreamDep: 2,
})

if a.parent != b {
    t.Errorf(&amp;quot;Expected A&#39;s parent to be B&amp;quot;)
}
if a.weight != 20 {
    t.Errorf(&amp;quot;Expected A&#39;s weight to be 20; got %d&amp;quot;, a.weight)
}
if b.parent != nil {
    t.Errorf(&amp;quot;Expected B to have no parent&amp;quot;)
}
if b.weight != 16 {
    t.Errorf(&amp;quot;Expected B&#39;s weight to be 16; got %d&amp;quot;, b.weight)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;という&lt;code&gt;stream&lt;/code&gt;がmapで管理されている．mapのkeyは各&lt;code&gt;stream&lt;/code&gt;のIDである．そして&lt;code&gt;adjustStreamPriority&lt;/code&gt;でIDが1である&lt;code&gt;a&lt;/code&gt;の優先度を16から20に更新し依存するストリームのIDを2に変更する．&lt;/p&gt;

&lt;p&gt;&amp;hellip;と優先度の更新は追えたが，この優先度をどのように使っているのかは見つけることができなかった．知ってる人がいたら教えてください．&lt;/p&gt;

&lt;h3 id=&#34;server-push&#34;&gt;Server Push&lt;/h3&gt;

&lt;p&gt;HTTP1.xではクライアントからリソースのリクエストがあって初めてサーバー側からそれを送ることができる．HTTP2ではServer Pushという仕組みを使い，クライアントがリクエストする前にサーバー側からクライアントにリソースを送りつけることができる．例えばサーバーがHTMLのリクエストを受けたとする．サーバーはHTMLの内容を知っているので次にCSSやJSのリクエストがクライアントから送られることを予想できる．Server Pushを使えばそれらを先に送信することができる．&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/kazuho&#34;&gt;kazuho&lt;/a&gt;さんによる&lt;a href=&#34;https://github.com/h2o/h2o&#34;&gt;H2O&lt;/a&gt;に関する発表を見ているとServer Pushは難しそう．Server Pushで送られたリソースはクライアントでキャッシュされ，クライアントはそのキャッシュを利用することになる．既にキャッシュが存在する場合にPushするのは無駄になるが，それを制御するのは難しい（H2Oでは&lt;a href=&#34;http://www.slideshare.net/kazuho/cache-awareserverpush-in-h2o-version-15&#34;&gt;Cache aware-server-push&lt;/a&gt;をしているとのこと）．&lt;/p&gt;

&lt;p&gt;Go言語ではどうなっているのか．Server Pushを行うときはPUSH_PROMISEというフレームをサーバーは送信する．このフレームを作成する&lt;code&gt;WritePushPromise&lt;/code&gt;というメソッドは準備されている．がServer Pushを行うためのハイレベルなインターフェースは現時点では見当たらなかった．&lt;a href=&#34;https://groups.google.com/forum/?fromgroups#!searchin/golang-nuts/http2/golang-nuts/1ggSbDA_XYI/kJhd35zwDgAJ&#34;&gt;&amp;ldquo;Please test Go&amp;rsquo;s HTTP/2 support&amp;rdquo;&lt;/a&gt;などを読む限り今後のバージョンでのリリースになりそう．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Go1.6に予定されているHTTP2の実装を追ってみた．Server Pushのハイレベルなインターフェースを除いた基本的な機能は実装されている．そしてGo1.5以前と同じインターフェースで利用できることがわかった．&lt;/p&gt;

&lt;p&gt;Go言語のHTTP2をすぐに使うのか? と聞かれるとまだ議論が必要であると感じた．少なくとも現時点ではTLS終端はアプリケーションの前段のnginxにある．最初はnginxなどで利用することから始めると思う．&lt;/p&gt;

&lt;p&gt;PaaSを運用している立場からみると状況はもう少し複雑になる．例えばGoogle App EngineのようにTLSとHTTP2は全てGoogleのサーバーが面倒見るからその上のアプリケーションは何もしなくてもHTTP2が有効になりますと言うこともできる（cf. &lt;a href=&#34;http://googlecloudplatform.blogspot.jp/2015/10/Full-Speed-Ahead-with-HTTP2-on-Google-Cloud-Platform.html&#34;&gt;Full Speed Ahead with HTTP/2 on Google Cloud Platform&lt;/a&gt;）．その一方でServer Pushなどはアプリケーションごとにコントロールしたいかもしれない．そういう場合にどのようにハンドルするべきなのかなど考えることは多い．&lt;/p&gt;

&lt;h3 id=&#34;cf&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/kazuho/http2-51888328&#34;&gt;HTTP/2時代のウェブサイト設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/KetoKawakami/http2-51414240&#34;&gt;HTTP/2でも初めてみます？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/Jxck/http2-web-web-over-http2-51943080&#34;&gt;HTTP2 時代の Web - web over http2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://techblog.yahoo.co.jp/infrastructure/http2/introduction_to_http2/&#34;&gt;HTTP/2 入門 - Yahoo! JAPAN Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/magazine/SD/archive/2015/201511&#34;&gt;Software Design 2015年11月号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/http2-server-side-architecture&#34;&gt;HTTP2 時代のサーバサイドアーキテクチャ考察&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/http2-rfc7540&#34;&gt;HTTP2 の RFC7540 が公開されました&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.scutum.jp/information/waf_tech_blog/2015/05/waf-blog-044.html&#34;&gt;HTTP/2のRFCを読んだ感想 - WAF Tech Blog ｜ クラウド型 WAFサービス Scutum 【スキュータム】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mew.org/~kazu/material/2015-warp-http2.pdf&#34;&gt;スレッドプログラミングによる HTTP/2 の実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/http2-server-side-architecture&#34;&gt;HTTP2 時代のサーバサイドアーキテクチャ考察&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/summerwind/2-deep-dive-priority-and-server-push&#34;&gt;HTTP/2 Deep Dive: Priority &amp;amp; Server Push&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.oracle.com/theaquarium/entry/http_2_and_server_push&#34;&gt;HTTP/2 and Server Push&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.integralist.co.uk/posts/http2.html&#34;&gt;http://www.integralist.co.uk/posts/http2.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://googlecloudplatform.blogspot.jp/2015/10/Full-Speed-Ahead-with-HTTP2-on-Google-Cloud-Platform.html&#34;&gt;Full Speed Ahead with HTTP/2 on Google Cloud Platform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://http2study.connpass.com/event/21161/presentation/&#34;&gt;http2/quic meetup - 資料一覧 - connpass&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mozaic.fm/post/83421293098/2-http2&#34;&gt;mozaic.fm #2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/99/&#34;&gt;Rebuild: 99: The Next Generation Of HTTP (kazuho)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://changelog.com/161/&#34;&gt;#161: HTTP/2 with Ilya Grigorik&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go言語と暗号技術（AESからTLS）</title>
      <link>http://deeeet.com/writing/2015/11/10/go-crypto/</link>
      <pubDate>Tue, 10 Nov 2015 15:53:31 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/11/10/go-crypto/</guid>
      <description>

&lt;p&gt;最近&lt;a href=&#34;http://www.amazon.co.jp/%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0TCP-SSL-TLS%E7%B7%A8-Eric-Rescorla/dp/4274065421&#34;&gt;マスタリングTCP/IP SSL/TLS編&lt;/a&gt;や&lt;a href=&#34;http://www.amazon.co.jp/3-ebook/dp/B015643CPE/&#34;&gt;暗号技術入門&lt;/a&gt;を読んでいた．理解を深めるためにGo言語で標準の&lt;code&gt;crypto&lt;/code&gt;パッケージを触り/実装を読みながら読んだ．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;crypto&lt;/code&gt;パッケージは他の標準パッケージと同様に素晴らしい．Go言語にはどのような暗号化手法が実装されているのか実例を含めてざっとまとめる．なお本文に書ききれなかったものを含め全ての実装例は&lt;a href=&#34;https://github.com/tcnksm/go-crypto&#34;&gt;tcnksm/go-crypto&lt;/a&gt;にある．&lt;/p&gt;

&lt;h2 id=&#34;共通鍵暗号&#34;&gt;共通鍵暗号&lt;/h2&gt;

&lt;p&gt;まずは共通鍵暗号をみる．共通鍵暗号は暗号化と復号化に同じ鍵を用いる暗号化方式である．共通鍵暗号はブロック暗号とストリーム暗号の2種類に分けることができる．ブロック暗号は特定の長さ単位で暗号化を行う方式であり，ストリーム暗号はデータの流れを順次処理していく方式である．&lt;/p&gt;

&lt;p&gt;Go言語にはブロック暗号としてDES（Data Encryption Standard），DESを繰り返すtriple-DES，そしてAES（Advanced Encryption Standard ）が実装されている．ストリーム暗号としてはRC4が実装されている．&lt;/p&gt;

&lt;p&gt;AESはDESに代わる新しい標準のアルゴリズムであり公募により選出された．互換性などを考慮しない限りこれを使うのが良い．実際に&lt;code&gt;plainText&lt;/code&gt;をAESで暗号化/復号化してみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;plainText := []byte(&amp;quot;This is 16 bytes&amp;quot;)

key := []byte(&amp;quot;passw0rdpassw0rdpassw0rdpassw0rd&amp;quot;)

block, err := aes.NewCipher(key)
if err != nil {
    fmt.Printf(&amp;quot;err: %s\n&amp;quot;, err)
    return
}

// Encrypt
cipherText := make([]byte, len(plainText))
block.Encrypt(cipherText, plainText)
fmt.Printf(&amp;quot;Cipher text: %x\n&amp;quot;, cipherText)

// Decrypt
decryptedText := make([]byte, len(cipherText))
block.Decrypt(decryptedText, cipherText)
fmt.Printf(&amp;quot;Decrypted text: %s\n&amp;quot;, string(decryptedText))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AESの鍵長さは16byte，24byte，32byteのいずれかである必要がある（それぞれAES-128，AES-192，AES-256と呼ばれる）．&lt;code&gt;NewCipher&lt;/code&gt;は&lt;code&gt;cipher.Block&lt;/code&gt;インタフェースを返す．このインタフェースには&lt;code&gt;Encrypt()&lt;/code&gt;と&lt;code&gt;Decrypt()&lt;/code&gt;が実装されている．全てのブロック暗号にはこのインタフェースが実装されている（他の例は&lt;a href=&#34;https://github.com/tcnksm/go-crypto/tree/master/symmetric-key&#34;&gt;こちら&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;AESは16byteというブロック単位で暗号化/復号化を行うアルゴリズムである．このままでは例にあるように16byteの固定視長の平文しか暗号化を行えない．これでは使えない．&lt;/p&gt;

&lt;h2 id=&#34;ブロック暗号のモード&#34;&gt;ブロック暗号のモード&lt;/h2&gt;

&lt;p&gt;任意の長さの平文を暗号化するためにはブロック暗号を繰り返し実行する必要がある．ブロック暗号にはそれを繰り返し実行するためのモードがある．&lt;/p&gt;

&lt;p&gt;まず単純に考えると平文を分割してそれぞれにブロック暗号を適用する方法が考えられる．これはECB（Electronic CodeBook mode）モードと呼ばれる．しかし同じ平文ブロックが存在する場合は同じ暗号文ブロックが存在してしまう，かつ攻撃者が暗号文ブロックを入れ替えたら平文の順番も入れ替わってしまうというなどの問題があり実用的ではない．これらの欠点を回避するために各種モードが存在する．&lt;/p&gt;

&lt;p&gt;Go言語では，ブロック暗号の各種モードを&lt;a href=&#34;https://golang.org/pkg/crypto/cipher/&#34;&gt;&lt;code&gt;cipher&lt;/code&gt;パッケージ&lt;/a&gt;に実装している．実装されているモードは以下，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CBC（Cipher Block Chainning）モード - 1つ前の暗号ブロックと平文ブロックの&lt;code&gt;XOR&lt;/code&gt;をとってから暗号化を行う．1番最初の平文ブロックにはIV（Initialization Vector）と&lt;code&gt;XOR&lt;/code&gt;をとる．暗号ブロックの一部が欠損すると以後の平文全てに影響が出る．SSL/TLSに利用されている（3DES_EDE_CBC，AES_256_CBC）．&lt;/li&gt;
&lt;li&gt;CFB（Cipher FeedBack）モード - 1つ前の暗号ブロックを暗号化したもの（Key Stream）と平文ブロックの&lt;code&gt;XOR&lt;/code&gt;をとる．再生攻撃が可能．&lt;/li&gt;
&lt;li&gt;OFB（Output FeedBack）モード - 1つ前の暗号化の出力（Key Stream）を次の暗号化の入力とする．暗号化の出力（Key Stream）と平文で&lt;code&gt;XOR&lt;/code&gt;をとる（Key Streamを事前につくっておくことができる）．もし暗号結果が同じものになったらそれ以後Key Streamは全て同じ値になってしまう．暗号文を1ビット反転させると平文も1ビット反転する&lt;/li&gt;
&lt;li&gt;CTR（CounTeR）モード - 1つずつ増加していくカウンタを暗号化してKey Streamを作り出す．カウンタを暗号化してKey Streamとする．カウンタは暗号化のたびに異なる値（ノンス）をもとにしてつくる．暗号文を1ビット反転させると平文も1ビット反転する．暗号結果が同じになってもそれ以後のKey Streamが同じ値になることがない．&lt;/li&gt;
&lt;li&gt;GCM（Galois/Counter）モード - CTRが暗号文を作り出すと同時に「この暗号文は正しい暗号化によって作られたものである」とう認証子を作り出す．暗号文の偽装を見抜くことができる．TLS1.2で使われる．IVが必要ない．AEAD（Authenticated Encryption with Associated Data）の一種である．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なおCFB，OFBそしてCTRはブロック暗号を使ってストリーム暗号を作り出しているとみなすことができる．&lt;/p&gt;

&lt;p&gt;実際にAES+CTRモードで&lt;code&gt;plainText&lt;/code&gt;を暗号/復号化してみる．今回は平文が16byteである必要はなく，任意の長さの平文を入力として使うことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;plainText := []byte(&amp;quot;Bob loves Alice. But Alice hate Bob...&amp;quot;)

key := []byte(&amp;quot;passw0rdpassw0rdpassw0rdpassw0rd&amp;quot;)

// Create new AES cipher block
block, err := aes.NewCipher(key)
if err != nil {
    fmt.Printf(&amp;quot;err: %s\n&amp;quot;, err)
}

// Create IV
cipherText := make([]byte, aes.BlockSize+len(plainText))
iv := cipherText[:aes.BlockSize]
if _, err := io.ReadFull(rand.Reader, iv); err != nil {
    fmt.Printf(&amp;quot;err: %s\n&amp;quot;, err)
}

// Encrypt
encryptStream := cipher.NewCTR(block, iv)
encryptStream.XORKeyStream(cipherText[aes.BlockSize:], plainText)
fmt.Printf(&amp;quot;Cipher text: %x \n&amp;quot;, cipherText)

// Decrpt
decryptedText := make([]byte, len(cipherText[aes.BlockSize:]))
decryptStream := cipher.NewCTR(block, cipherText[:aes.BlockSize])
decryptStream.XORKeyStream(decryptedText, cipherText[aes.BlockSize:])
fmt.Printf(&amp;quot;Decrypted text: %s\n&amp;quot;, string(decryptedText))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NewCipher&lt;/code&gt;は&lt;code&gt;cipher.Block&lt;/code&gt;をつくり，それを&lt;code&gt;NewCTR&lt;/code&gt;の入力とする．IV（ストリームの初期値）はユニークでる必要があるが安全である必要はないので暗号文の先頭に差し込んでいる．&lt;code&gt;NewCTR&lt;/code&gt;は&lt;code&gt;cipher.Stream&lt;/code&gt;インタフェースを返す．あとはそれに平文/暗号文を入力として与えれば暗号化/復号化が行われる．&lt;/p&gt;

&lt;h2 id=&#34;公開鍵暗号&#34;&gt;公開鍵暗号&lt;/h2&gt;

&lt;p&gt;共通鍵暗号は強力だが鍵配送問題（いかに安全に共通鍵を交換するか）がある．この問題を解決するのが公開鍵暗号である．公開鍵暗号は，公開鍵で暗号化を行い，秘密鍵で復号化を行う暗号化方式である．Go言語ではRSAと楕円曲線（Elliptic Curve）暗号が実装されている．&lt;/p&gt;

&lt;p&gt;RSAは一番よく知られた公開鍵暗号アルゴリズムである．RSAの暗号化と復号化は，付加するパディングデータの作成や検証の手順などを組み入れた形で行われるため，それら全てを含めて仕様が決まる．Go言語では標準で以下が実装されている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RSA-PKCS1v15 - パディングとしてランダムの値を先頭に追加する．&lt;/li&gt;
&lt;li&gt;RSA-OAEP (Optimal Asymmetric Encryption Padding) - 任意のラベルのハッシュ値と決まった個数の0から作成した認証情報を平文の頭に追加してRSAで暗号化する．複合化ではRSAで復号した後，先頭に正しい「認証情報」が現れなければ「平文」を知ってる人が作成した暗号文ではない，適当に作られた暗号文であると判断しエラーを返すことができる．つまり選択暗号文攻撃に対して安全になる．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際にRSA-PKCS1v15で&lt;code&gt;plainText&lt;/code&gt;を暗号化/復号化を行う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;plainText := []byte(&amp;quot;Bob loves Alice.&amp;quot;)

// size of key (bits)
size := 2048

// Generate private and public key pair
privateKey, err := rsa.GenerateKey(rand.Reader, size)
if err != nil {
    fmt.Printf(&amp;quot;err: %s&amp;quot;, err)
    return
}

// Get public key from private key and encrypt
publicKey := &amp;amp;privateKey.PublicKey

cipherText, err := rsa.EncryptPKCS1v15(rand.Reader, publicKey, plainText)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}
fmt.Printf(&amp;quot;Cipher text: %x\n&amp;quot;, cipherText)

// Decrypt with private key
decryptedText, err := rsa.DecryptPKCS1v15(rand.Reader, privateKey, cipherText)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}
    
fmt.Printf(&amp;quot;Decrypted text: %s\n&amp;quot;, decryptedText)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;乱数と鍵の長さを入力として&lt;code&gt;GenerateKey&lt;/code&gt;で公開鍵と秘密鍵のペアを作る．&lt;code&gt;PrivateKey&lt;/code&gt;の中身を見ると鍵を構成する素数をみることができる．あとは&lt;code&gt;EncryptPKCS1v15&lt;/code&gt;と&lt;code&gt;DecryptPKCS1v15&lt;/code&gt;で暗号化/復号化を行うことができる．&lt;/p&gt;

&lt;p&gt;鍵の長さは1024は新規用途には合わず，2048は2030年まで新規用途に合わず，4096は2031年以降も使うことができると言われている．&lt;/p&gt;

&lt;h2 id=&#34;ハッシュ&#34;&gt;ハッシュ&lt;/h2&gt;

&lt;p&gt;共通鍵暗号や公開鍵暗号を使えばメッセージを暗号化してやりとりすることができる．しかしそれだけではメッセージが途中で改竄されたかを判別することができない．これを解決するために用いられるのがハッシュ関数である．&lt;/p&gt;

&lt;p&gt;Go言語は標準でMD5，SHA-1，SHA-2（SHA-224，SHA-256，SHA-384，SHA-512，SHA-512/224，SHA-512/256）が実装されている．また&lt;a href=&#34;https://godoc.org/golang.org/x/crypto&#34;&gt;golang.org/x/crypto&lt;/a&gt;にはAES同様に公募によって選定されたSHA-3（Keccak）が実装されている．&lt;/p&gt;

&lt;p&gt;実際にSHA-512を使い&lt;code&gt;msg&lt;/code&gt;からハッシュ値を計算する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;msg := []byte(&amp;quot;Bob is dead&amp;quot;)
checksum512 := sha512.Sum512(msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にSHA-3を使い&lt;code&gt;msg&lt;/code&gt;からハッシュ値を計算する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;msg := []byte(&amp;quot;Alice is dead&amp;quot;)
// A MAC with 64 bytes of output has 512-bit security strength
h := make([]byte, 64)

d := sha3.NewShake256()
d.Write(msg)

d.Read(h)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SHA-1とSHA-2には入力制限があるが，SHA-3にはない．また&lt;code&gt;ShakeHash&lt;/code&gt;を使えば任意長のビット列を生成することができる．&lt;/p&gt;

&lt;p&gt;新規ではSHA-1を使うべきではなく，SHA-2もしくはSHA-3を使うのが良いとされている．&lt;/p&gt;

&lt;p&gt;ハッシュ関数を使えば改竄を検出することができるが，そのメッセージが期待する送信者によるものであるか，なりすましではないかを検出することはできない．&lt;/p&gt;

&lt;h2 id=&#34;メッセージ認証コード-mac&#34;&gt;メッセージ認証コード（MAC）&lt;/h2&gt;

&lt;p&gt;メッセージの改竄とそのメッセージが正しい送信者からのものであるかを検出するのにメッセージ認証コード（MAC）が利用される．MACは任意のメッセージと送信者と受信者が共有する鍵を入力として固定ビット長の出力をする関数である．&lt;/p&gt;

&lt;p&gt;Go言語では標準でHMACが実装されている．&lt;/p&gt;

&lt;p&gt;実際にHMACを使って&lt;code&gt;msg&lt;/code&gt;と&lt;code&gt;key&lt;/code&gt;からMAC値の計算と検証をやってみる．HMACは任意の&lt;code&gt;hash.Hash&lt;/code&gt;関数を使うことができる．ここではSHA-512を用いる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;msg := []byte(&amp;quot;Bob loves Alice.&amp;quot;)
key := []byte(&amp;quot;passw0rd&amp;quot;)

h1 := hmac.New(sha512.New, key)
h1.Write(msg)
mac1 := h1.Sum(nil)
fmt.Printf(&amp;quot;MAC1: %x\n&amp;quot;, mac1)

h2 := hmac.New(sha512.New, key)
h2.Write(msg)
mac2 := h2.Sum(nil)
fmt.Printf(&amp;quot;MAC2: %x\n&amp;quot;, mac2)

fmt.Printf(&amp;quot;Valid? %v\n&amp;quot;, hmac.Equal(mac1, mac2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MACでは「否認」を防止することができない．送信者と受信者が鍵を共有するため送信者だけではなく受信者もMAC値を生成できてしまう．つまり第三者にこれは送信者が生成したMACであることを証明できない（受信者が生成することもできる）．&lt;/p&gt;

&lt;h2 id=&#34;デジタル署名&#34;&gt;デジタル署名&lt;/h2&gt;

&lt;p&gt;「否認」を防止しメッセージの検証を行う方法にデジタル署名がある．デジタル署名は公開鍵暗号の応用であり，メッセージ送信者が秘密鍵で署名を行い，受信者が公開鍵で検証を行う．つまり第三者でもそのメッセージの送信を検証することができる．&lt;/p&gt;

&lt;p&gt;Go言語では標準でDSA（Digital Signature Algorithm），RSA，楕円曲線暗号によるデジタル署名が実装されている．&lt;/p&gt;

&lt;p&gt;実際に楕円曲線暗号を使ってデジタル署名とその検証をしてみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;priv, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}

hashed := []byte(&amp;quot;This is message.&amp;quot;)
r, s, err := ecdsa.Sign(rand.Reader, priv, hashed)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}

if ecdsa.Verify(&amp;amp;priv.PublicKey, hashed, r, s) {
    fmt.Printf(&amp;quot;Verified!\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;楕円曲線暗号は，楕円曲線上の演算に基づく暗号化手法である．&lt;code&gt;crypto/elliptic&lt;/code&gt;に曲線とその演算が定義されている．そして署名には&lt;code&gt;crypto/ecdsa&lt;/code&gt;パッケージを用いる．まず&lt;code&gt;GenerateKey&lt;/code&gt;で公開鍵と秘密鍵を生成する．その際に利用する楕円曲線を指定する．利用できる曲線はP-224，P-256，P-384そしてP-521である．生成した秘密鍵と任意の長さのハッシュ値を入力として&lt;code&gt;Sign&lt;/code&gt;し署名を行う．署名は&lt;code&gt;big.Int&lt;/code&gt;のペアとして返される．これらの値と公開鍵を入力として署名の検証を行う．&lt;/p&gt;

&lt;h2 id=&#34;証明書-x509&#34;&gt;証明書（x509）&lt;/h2&gt;

&lt;p&gt;公開鍵暗号は強力だが，このままでは「その公開鍵が期待する相手のものであるか」が不確かであり，man-in-the-middle攻撃を防ぐことができない．この問題を解決する方法が証明書と認証局（CA）である．サーバーは信頼できる認証局から公開鍵にデジタル署名を受け証明書を作成する．ユーザは認証局局の公開鍵で署名を検証しそのサーバーのものであるかを確認する．&lt;/p&gt;

&lt;p&gt;証明書にはX.509という規格で標準化されている．Go言語では標準で&lt;code&gt;crypto/x509&lt;/code&gt;というパッケージにこのX.509の規格に準じた証明書や鍵のパースや検証が実装されている．&lt;/p&gt;

&lt;p&gt;X.509の証明書はASN.1（Abstract Syntax Notation One）で表記される．ASN.1 は情報の抽象構文を定義するが情報のEncodeのフォーマットは限定しない．X.509ではDER（Distinguished Encoding Rules）でEncodeが行われる（Encodeがユニークに定まる）．Goでは&lt;code&gt;encoding/ans1&lt;/code&gt;パッケージにDERのEncoderが準備されている．またASN.1のよりlow levelの構造のパーサーは&lt;code&gt;crypto/x509/pkix&lt;/code&gt;に定義されている（例えば国名や組織名など）．証明書や鍵はPEM（Privacy Enhanced Mail）形式でEncodeされてファイルに保存されることが多いが，これらのエンコードは&lt;code&gt;encoding/pem&lt;/code&gt;に定義されている．&lt;/p&gt;

&lt;p&gt;または&lt;code&gt;crypto/x509&lt;/code&gt;にはRSA-PKCS1v15と楕円曲線暗号による鍵のASN.1 DER形式のMarshal/Unmarshalも実装されている．&lt;/p&gt;

&lt;p&gt;そんなことは滅多にないと思うが，実際にGo言語でX.509の自己署名証明書を作ってみる．公開鍵暗号としては楕円曲線暗号を使い，PEM形式でファイルに保存する（&lt;code&gt;ca.pem&lt;/code&gt;）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Generate pub &amp;amp; priv key pair by Elliptic Curve Digital Signature
priv, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}

// Create CA certificate template
ca := x509.Certificate{
    IsCA:         true,
    SerialNumber: big.NewInt(1234),
    Subject: pkix.Name{
        Country:      []string{&amp;quot;Japan&amp;quot;},
        Organization: []string{&amp;quot;TCNKSM ECDSA CA Inc.&amp;quot;},
    },

    NotBefore: time.Now(),
    NotAfter:  time.Now().Add(24 * time.Hour),

    KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment | x509.KeyUsageCertSign,
    ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
    BasicConstraintsValid: true,
}

// Create Certificate
derBytes, err := x509.CreateCertificate(rand.Reader, &amp;amp;ca, &amp;amp;ca, &amp;amp;priv.PublicKey, priv)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}

certOut, err := os.Create(&amp;quot;ca.pem&amp;quot;)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}
defer certOut.Close()

if err := pem.Encode(certOut, &amp;amp;pem.Block{
    Type:  &amp;quot;CERTIFICATE&amp;quot;,
    Bytes: derBytes,
}); err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;鍵の生成はデジタル署名と同じ．&lt;code&gt;x509.Certificate&lt;/code&gt;に証明書に必要な情報を書く．逆に読み込むときはこのstructにパースされる．あとはそれと署名したい公開鍵と署名するための秘密鍵（今回は自己署名なので生成されたペア）を入力として&lt;code&gt;x509.CreateCertificate&lt;/code&gt;を呼ぶ．&lt;/p&gt;

&lt;p&gt;他にも&lt;code&gt;crypto/x509&lt;/code&gt;パッケージで証明書の検証も行える．それらの実装例は&lt;a href=&#34;https://github.com/tcnksm/go-crypto/blob/master/certificate/x509/ecdsa/verify.go&#34;&gt;ここ&lt;/a&gt;に書いた．また&lt;code&gt;crypto/tls&lt;/code&gt;パッケージのテストを覗くと&lt;a href=&#34;https://golang.org/src/crypto/tls/generate_cert.go&#34;&gt;generate_cert.go&lt;/a&gt;というコードがあり証明書の生成例を見ることができる．&lt;/p&gt;

&lt;h2 id=&#34;tls&#34;&gt;TLS&lt;/h2&gt;

&lt;p&gt;TLSの実装も&lt;code&gt;crypto&lt;/code&gt;パッケージ以下にある．TLSは様々な暗号技術を寄せ集めたハイブリットな暗号技術であると言える．上で見てきた様々な暗号化手法が取り入れられている．通信の暗号化には共通鍵暗号を用い，共通鍵暗号の配送には公開鍵暗号を用いる．また公開鍵を認証するためにデジタル署名を用い，そしてデータの認証にHMACを持ちるなどなど．&lt;/p&gt;

&lt;p&gt;例えばpre-master secret（これをもとにサーバーとクライアントでmaster secretをつくり共通鍵暗号として通信を行う）の暗号化/復号化には公開鍵暗号が用いられる．RSAのkey-agreementの実装を見ると上で見たような暗号化が見られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;encrypted, err := rsa.EncryptPKCS1v15(config.rand(), cert.PublicKey.(*rsa.PublicKey), preMasterSecret)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;preMasterSecret, err := priv.Decrypt(config.rand(), ciphertext, &amp;amp;rsa.PKCS1v15DecryptOptions{SessionKeyLen: 48})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TLSを使ったサーバとクライアントの実装例は&lt;a href=&#34;https://github.com/tcnksm/go-crypto/tree/master/tls&#34;&gt;ここ&lt;/a&gt;にある．またhttpsのサーバとクライアントの実装例は&lt;a href=&#34;https://github.com/tcnksm/go-crypto/tree/master/https&#34;&gt;ここ&lt;/a&gt;にある．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Go言語の暗号化技術をざっと追ってみた．個々の暗号化技術を押さえておくとTLSのような複雑な実装も自分の手に届くようになる．自分なりの最終的目標は&lt;code&gt;crypto/tls&lt;/code&gt;の実装をある程度読めることとしていたが，ある程度読むことができるようになった．「暗号技術入門」を読みつつ実際のコードを読むのはとても面白いのでおすすめです．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hashicorp Ottoを読む</title>
      <link>http://deeeet.com/writing/2015/10/04/otto/</link>
      <pubDate>Sun, 04 Oct 2015 22:07:21 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/10/04/otto/</guid>
      <description>

&lt;p&gt;Hashicorpから2015年秋の新作が2つ登場した．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hashicorp.com/blog/otto.html&#34;&gt;Otto - HashiCorp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hashicorp.com/blog/nomad.html&#34;&gt;Nomad - HashiCorp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ottoがなかなか面白そうなのでコードを追いつつ，Ottoとは何か? なぜ必要になったのか? どのように動作するのか? を簡単にまとめてみる．&lt;/p&gt;

&lt;p&gt;バージョンは &lt;em&gt;0.1.0&lt;/em&gt; を対象にしている（イニシャルインプレッションである）&lt;/p&gt;

&lt;h2 id=&#34;ottoとは何か&#34;&gt;Ottoとは何か?&lt;/h2&gt;

&lt;p&gt;公式はVagrantの後継と表現されている．が，それはローカル開発環境の構築&lt;strong&gt;も&lt;/strong&gt;担っているという意味で後継であり，自分なりの言葉で表現してみると「OttoはHashicorpの各ツールを抽象化し開発環境の構築からインフラの整備，デプロイまでを一手に担うツール」である．ちなみにOttoという名前の由来は&lt;a href=&#34;https://twitter.com/zembutsu/status/648956697034096641&#34;&gt;Automationと語感が似ているからかつ元々そういう名前のbotがいた&lt;/a&gt;からとのこと．&lt;/p&gt;

&lt;h2 id=&#34;なぜottoか&#34;&gt;なぜOttoか?&lt;/h2&gt;

&lt;p&gt;なぜVagrantでは不十分であったのか? なぜOttoが必要だったのか? 理由をまとめると以下の5つである．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;設定ファイルは似通ったものになる&lt;/li&gt;
&lt;li&gt;設定ファイルは化石化する&lt;/li&gt;
&lt;li&gt;ローカル開発環境と同じものをデプロイしたい&lt;/li&gt;
&lt;li&gt;microservicesしたい&lt;/li&gt;
&lt;li&gt;パフォーマンスを改善したい &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まず各言語/フレームワークの&lt;code&gt;Vagrantfile&lt;/code&gt;は似通ったものになる．&lt;code&gt;Vagrantfile&lt;/code&gt;は毎回似たようなものを書く，もしくはコピペしていると思う．それならツール側が最も適したものを生成したほうがよい．Ottoは各言語のベストプラクティスな設定ファイルを持っておりそれを生成する．&lt;/p&gt;

&lt;p&gt;そして&lt;code&gt;Vagrantfile&lt;/code&gt;は時代とともに古くなる，つまり化石化する．秘伝のソースとして残る．Ottoは生成する設定ファイルを常に最新のものに保つ．つまり今Ottoが生成する設定ファイルは5年後に生成される設定ファイルとは異なるものになる（cf. &lt;a href=&#34;http://blog.bennycornelissen.nl/otto-a-modern-developers-new-best-friend/&#34;&gt;&amp;ldquo;Otto: a modern developer&amp;rsquo;s new best friend&amp;rdquo;&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;そしてローカル開発環境と同じものを本番に構築したい（Environmental parityを担保したい）．現在のVagrantでも&lt;code&gt;provider&lt;/code&gt;の仕組みを使えばIaaSサービスに環境を構築することはできる．が本番に適した形でそれを構築できるとは言い難い．Ottoは開発環境の構築だけではなく，デプロイ環境の構築も担う．&lt;/p&gt;

&lt;p&gt;時代はmicroservicesである．Vagrantは単一アプリ/サービスの構築には強いが複数には弱い．Ottoは依存サービスを記述する仕組みをもつ（&lt;code&gt;Appfile&lt;/code&gt;）．それによりmicroserviceな環境を簡単に構築することができる．&lt;/p&gt;

&lt;p&gt;そしてパフォーマンス．最近のVagrantはどんどん遅くなっている．例えば立ち上げているVMの状態を確認するだけの&lt;code&gt;status&lt;/code&gt;コマンドは2秒もかかる．Ottoはパフォーマンスの改善も目的にしている．&lt;/p&gt;

&lt;h2 id=&#34;ottoは何をするのか&#34;&gt;Ottoは何をするのか?&lt;/h2&gt;

&lt;p&gt;Ottoが行うことは以下の2つに集約できる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hashicorpツールの設定ファイルとスクリプトを生成する&lt;/li&gt;
&lt;li&gt;Hashicorpツールのインストール/実行をする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ottoの各コマンドと合わせてみてみると以下のようになる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compile&lt;/code&gt; - アプリケーションのコンテキスト（e.g., 言語やフレームワーク）の判定と専用の設定ファイルである&lt;code&gt;Appfile&lt;/code&gt;をもとにHashicorpツールの設定ファイル（&lt;code&gt;Vagrantfile&lt;/code&gt;やTerraformの&lt;code&gt;.tf&lt;/code&gt;ファイル，Packerのマシンテンプレート&lt;code&gt;.json&lt;/code&gt;）と各種インストールのためのシェルスクリプトを生成する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dev&lt;/code&gt; - 開発環境を構築する．Vagrantを実行する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;infra&lt;/code&gt; - アプリをデプロイするためのインフラを整備する．例えばAWSならVPCやサブネット，ゲートウェイなどを設定する．&lt;a href=&#34;https://terraform.io/&#34;&gt;Terraform&lt;/a&gt;を実行する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt; - アプリをデプロイ可能なイメージに固める．例えばAMIやDocker Imageなど．&lt;a href=&#34;https://www.packer.io/&#34;&gt;Packer&lt;/a&gt;を実行する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deploy&lt;/code&gt; - 作成したイメージを事前に構築したインフラにデプロイする．Terraformを実行する（OttoのデプロイはImmutable Infrastructureを嗜好する）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ottoがつくるインフラの基礎&#34;&gt;Ottoがつくるインフラの基礎&lt;/h2&gt;

&lt;p&gt;Ottoには&lt;a href=&#34;https://ottoproject.io/docs/concepts/foundations.html&#34;&gt;Foundation&lt;/a&gt;という概念がある（&lt;code&gt;foundation&lt;/code&gt;という言葉は生成される設定ファイルやディレクトリ名に登場する）．これはOttoが構築するインフラの基礎，本番環境にアプリケーションをデプロイするために重要となるレイヤーを示す．このFoundationの例としては，以下のようなものが挙げられる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.consul.io/&#34;&gt;Consul&lt;/a&gt;によるサービスディスカバリー&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://vaultproject.io/&#34;&gt;Vault&lt;/a&gt;によるパスワード管理 (Future)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nomadproject.io/&#34;&gt;Nomad&lt;/a&gt;によるスケジューリング (Future)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このレイヤーはモダンなアーキテクチャーではBest Practiceとされつつも構築はなかなか難しい．OttoはVagrantでローカル開発環境を構築するとき，本番環境のインフラを整備するときにこのレイヤーの整備も一緒に行う．&lt;/p&gt;

&lt;h2 id=&#34;ottoの設定ファイル&#34;&gt;Ottoの設定ファイル&lt;/h2&gt;

&lt;p&gt;単純なことをするならばOttoには設定ファイルは&lt;strong&gt;必要ない&lt;/strong&gt;．プロジェクトのルートディレクトリで&lt;code&gt;compile&lt;/code&gt;を実行すれば言語/フレームワークを判定し，それにあった&lt;code&gt;Vagrantfile&lt;/code&gt;とインフラを整備するためのTerraformの&lt;code&gt;.tf&lt;/code&gt;ファイルなどを生成してくれる．&lt;/p&gt;

&lt;p&gt;より複雑なことをしたければ不十分である．Ottoは専用の&lt;code&gt;Appfile&lt;/code&gt;という設定ファイルでカスタマイズを行うことができる．&lt;code&gt;Appfile&lt;/code&gt;は&lt;a href=&#34;https://github.com/hashicorp/hcl&#34;&gt;HCL&lt;/a&gt;で記述する．例えば，以下のように依存するサービスを記述することができる&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;application {
    dependency {
        source = &amp;quot;github.com/tcnksm-sample/golang-web&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他にも，言語のバージョンを指定したり，デプロイするIaaSサービスやその&lt;code&gt;flavar&lt;/code&gt;（e.g., AWSだと現在&lt;code&gt;simple&lt;/code&gt;と&lt;code&gt;vpc-public-private&lt;/code&gt;がある．&lt;code&gt;simple&lt;/code&gt;は最小限のリソースを使うのみでScalabilityや耐障害性などは犠牲にする．&lt;code&gt;vpc-public-private&lt;/code&gt;だとprivateネットワークやNATなども準備する）を設定することができる．&lt;/p&gt;

&lt;p&gt;基本は適切なデフォルト値と自動で判別される値が存在する．&lt;code&gt;Appfile&lt;/code&gt;はそれを上書きするものである．公式の説明の仕方を借りると&lt;code&gt;Appfile&lt;/code&gt;は「どのようにマシンを設定するのかを記述するのではなく，アプリケーションが何であるかを記述する」ものである．&lt;/p&gt;

&lt;h2 id=&#34;ottoを読む&#34;&gt;Ottoを読む&lt;/h2&gt;

&lt;p&gt;自分が気になった部分のソースコードを軽く読んでみる．&lt;/p&gt;

&lt;h3 id=&#34;概要&#34;&gt;概要&lt;/h3&gt;

&lt;p&gt;上述したように，Ottoは各Hashicorpツールのバイナリを実行しているだけある．大まかには以下のようになる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compile&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;依存サービスがある場合はそれらを全て&lt;code&gt;.otto&lt;/code&gt;以下のディレクトリにfetchする（依存先も&lt;code&gt;Appfile&lt;/code&gt;と&lt;code&gt;.ottoid&lt;/code&gt;を持っている必要がある）&lt;/li&gt;
&lt;li&gt;各&lt;code&gt;Appfile&lt;/code&gt;と言語/フレームワークを判別結果をマージして&lt;code&gt;.otto&lt;/code&gt;ディレクトリ以下に各種設定ファイルを生成する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コマンドごとに&lt;code&gt;otto/compiled&lt;/code&gt;以下の決められたディレクトリ内の設定ファイルをもとにバイナリを実行する

&lt;ul&gt;
&lt;li&gt;e.g., &lt;code&gt;build&lt;/code&gt;を実行するとPackerのマシンテンプレートである&lt;code&gt;.otto/compiled/app/build/template.json&lt;/code&gt;が使われる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;コア&#34;&gt;コア&lt;/h3&gt;

&lt;p&gt;Ottoのコアは&lt;a href=&#34;https://github.com/hashicorp/otto/blob/v0.1.1/otto/core.go&#34;&gt;https://github.com/hashicorp/otto/blob/v0.1.1/otto/core.go&lt;/a&gt;にある．基本的にどのコマンドもここに到達する．やっていることは単純でコンテキストをもとに実行するべき設定ファイルを決めてそれを元にバイナリを実行するだけ．&lt;/p&gt;

&lt;p&gt;以下をみると各バイナリをどのように実行しているかをみることができる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hashicorp/otto/tree/v0.1.1/helper/vagrant&#34;&gt;https://github.com/hashicorp/otto/tree/v0.1.1/helper/vagrant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hashicorp/otto/tree/v0.1.1/helper/terraform&#34;&gt;https://github.com/hashicorp/otto/tree/v0.1.1/helper/terraform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hashicorp/otto/tree/v0.1.1/helper/packer&#34;&gt;https://github.com/hashicorp/otto/tree/v0.1.1/helper/packer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;インストーラー&#34;&gt;インストーラー&lt;/h3&gt;

&lt;p&gt;バイナリがインストールされていなければコマンド実行直後にインストールが実行される．&lt;a href=&#34;https://github.com/hashicorp/otto/tree/v0.1.1/helper/hashitools&#34;&gt;https://github.com/hashicorp/otto/tree/v0.1.1/helper/hashitools&lt;/a&gt;にインストーラーが書かれている．以下の&lt;a href=&#34;bintray.com&#34;&gt;bintray.com&lt;/a&gt;のURLからzipをダウンロードして展開しているだけ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;url := fmt.Sprintf(
    &amp;quot;https://dl.bintray.com/mitchellh/%s/%s_%s_%s_%s.zip&amp;quot;,
    i.Name, i.Name, vsn, runtime.GOOS, runtime.GOARCH)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（なんでmitchellhアカウントなのだろう&amp;hellip;）&lt;/p&gt;

&lt;h3 id=&#34;言語-フレームワークの判定&#34;&gt;言語/フレームワークの判定&lt;/h3&gt;

&lt;p&gt;まず&lt;code&gt;compile&lt;/code&gt;のときにアプリケーションの言語/フレームワークの判定する方法．これはHerokuのBuildpackに似たことをする．アプリケーションに特有なファイル，例えばRubyならば&lt;code&gt;Gemfile&lt;/code&gt;，が存在するかをチェックする．判定のルールは以下のような&lt;code&gt;struct&lt;/code&gt;で保持する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;detectors := []*detect.Detector{
    &amp;amp;detect.Detector{
        Type: &amp;quot;go&amp;quot;,
        File: []string{&amp;quot;*.go&amp;quot;},
    },
    ....    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして以下で判別する．単純．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func (d *Detector) Detect(dir string) (bool, error) {
    for _, pattern := range d.File {
        matches, err := filepath.Glob(filepath.Join(dir, pattern))
        if err != nil {
            return false, err
        }
        if len(matches) &amp;gt; 0 {
            return true, nil
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.hcl&lt;/code&gt;ファイルで&lt;code&gt;Detector&lt;/code&gt;を書いて&lt;code&gt;~/.otto.d/detect&lt;/code&gt;以下に置い読み込むというロジックを見かけたので自分で好きな判定ロジックを定義できるかもしれない．&lt;/p&gt;

&lt;h3 id=&#34;設定ファイル-インストールスクリプトはどこにあるのか&#34;&gt;設定ファイル/インストールスクリプトはどこにあるのか?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/kenjiskywalker/status/648884208572600323&#34;&gt;&amp;ldquo;ハシコープは人類を含む全ての概念をバイナリにして配布した&amp;rdquo;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hashicorp/otto/tree/v0.1.1/builtin/app&#34;&gt;https://github.com/hashicorp/otto/tree/v0.1.1/builtin/app&lt;/a&gt;以下に各言語の&lt;code&gt;Vagrantfile&lt;/code&gt;やpackerのマシンテンプレート，それらが呼び出すインストールスクリプトが存在する．そしてOttoはそれらを&lt;a href=&#34;https://github.com/jteeuwen/go-bindata&#34;&gt;go-bindata&lt;/a&gt;を使ってバイナリとして埋め込んでいる．&lt;code&gt;app.go&lt;/code&gt;の先頭をみるとそのための&lt;code&gt;go generate&lt;/code&gt;文が見える．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;//go:generate go-bindata -pkg=goapp -nomemcopy -nometadata ./data/...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;時代はシェルスクリプト&#34;&gt;時代はシェルスクリプト&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Vagrantfile&lt;/code&gt;のインストールスクリプト，Packerのマシンテンプレートが呼び出す&lt;code&gt;provisioner&lt;/code&gt;のスクリプト，など全てがゴリゴリのシェルスクリプトで書かれている．&lt;code&gt;Dockerfile&lt;/code&gt;以後，時代はシェルスクリプトになっている気がする．大変そう．&lt;/p&gt;

&lt;p&gt;ちなみにデーモンの管理は&lt;code&gt;upstart&lt;/code&gt;が使われている（cf. &lt;a href=&#34;https://github.com/hashicorp/otto/blob/v0.1.1/builtin/foundation/consul/data/common/app-build/upstart.conf.tpl&#34;&gt;https://github.com/hashicorp/otto/blob/v0.1.1/builtin/foundation/consul/data/common/app-build/upstart.conf.tpl&lt;/a&gt;）．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;とりあえず何か始めたいと思うときは便利であるし，期待感はある．が，最後にこれはどうなるんだろうと思ったことをまとめておく．&lt;/p&gt;

&lt;p&gt;設定ファイルをバイナリに含めたら変更が辛くなるのではないか? もし設定ファイルに不備があったらそれを修正して新しくバイナリをリリースしないといけなくなる．利用者は開発者なので問題はなさそうだけど，一度ダウンロードしたものをすぐにアップグレードしてくれるだろうか（一応利用しているバイナリが最新であるかそうでないかを判定し，古い場合には警告を出す&lt;a href=&#34;https://github.com/hashicorp/go-checkpoint&#34;&gt;仕組み&lt;/a&gt;はある）．Atlasを使ってファイルをホストする方式ではだめだったのか? boxを使うのはダメだったのか?（重いかな..）．&lt;/p&gt;

&lt;p&gt;今のところ&lt;code&gt;compile&lt;/code&gt;するたびに&lt;code&gt;.otto&lt;/code&gt;ディレクトリは作り直される．同じ環境であることは担保するのは&lt;code&gt;.ottoid&lt;/code&gt;ファイルしかない．これはどこまで非互換な変更を対処してくれるのか．ローカル開発環境は良いが，デプロイがぶっ壊れることはないだろうか.. （が，これはottoというよりはTerraformの問題な気もする）．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pocketstudio.jp/log3/2015/10/01/joined-hashiconf-2015-at-portland/&#34;&gt;HashiConf 2015 参加してきました＆KeyNoteまとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>プレゼンするときに考えていること</title>
      <link>http://deeeet.com/writing/2015/09/25/talking/</link>
      <pubDate>Fri, 25 Sep 2015 08:48:30 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/09/25/talking/</guid>
      <description>&lt;p&gt;僕はカンファレンスで喋るのが好きだ．好きだが決して得意ではない．むしろ喋るのは苦手なほうだと思う．&lt;/p&gt;

&lt;p&gt;実際に自分でやるまではプレゼンは才能だと思っていた．大学の研究発表などで実際に自分でプレゼンをするようになり，大学の研究室で指導されまくった結果，プレゼンは技術だと認識した（もちろん才能もある）．技術であるということは学ぶことができる．それに気づいてからはたくさんプレゼンに関する本を読んだ．昔は発表前に必ず何か一冊プレゼンに関する本を読みそれを積極的に取り入れるようにした．&lt;/p&gt;

&lt;p&gt;得意でないなりに学んで，発表を繰り返した結果なんとなく毎回考えること/意識することが固まってきた．今後のために簡単にまとめておく．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;聴衆は貴重な時間を割いて会場に来る&lt;/li&gt;
&lt;li&gt;オーガナイザーは貴重な時間を割いてカンファレンスを準備している&lt;/li&gt;
&lt;li&gt;聴衆が誰かを妄想する&lt;/li&gt;
&lt;li&gt;早めに準備する．早めに準備する．早めに準備する．早めに&amp;hellip;&lt;/li&gt;
&lt;li&gt;Keynoteを開く前に概要とトークの流れを書く&lt;/li&gt;
&lt;li&gt;Keynoteを先に開くと流れのない壊滅的な資料ができる&lt;/li&gt;
&lt;li&gt;流れを書きつつここでx分/ここでy分という時間も想定する&lt;/li&gt;
&lt;li&gt;時間超えるのはクソである&lt;/li&gt;
&lt;li&gt;むしろ早く終わった方がよい&lt;/li&gt;
&lt;li&gt;少しでも有意義なものを受け取ってもらいたいから言いたいことは絞る&lt;/li&gt;
&lt;li&gt;言いたいことを絞れば早く終わる&lt;/li&gt;
&lt;li&gt;概要から始まり徐々に詳細に向かう&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/writing/sld012.htm&#34;&gt;逆茂木型&lt;/a&gt;に注意する&lt;/li&gt;
&lt;li&gt;前のスライドから次のスライドが想定できるようにする&lt;/li&gt;
&lt;li&gt;前のスライドから次のスライドが想定できるようなきっかけを書く&lt;/li&gt;
&lt;li&gt;Itemizeは文末を揃える&lt;/li&gt;
&lt;li&gt;例をなるべく使う&lt;/li&gt;
&lt;li&gt;図をなるべく使う&lt;/li&gt;
&lt;li&gt;文字を大きくする&lt;/li&gt;
&lt;li&gt;文字の配置，大きさ，色を一貫させる&lt;/li&gt;
&lt;li&gt;文字の配置，大きさ，色はそれだけで意味を持つ&lt;/li&gt;
&lt;li&gt;作り終わったらちゃんと喋ってこの段階のスライドがゴミであることに気づく&lt;/li&gt;
&lt;li&gt;喋って直す&lt;/li&gt;
&lt;li&gt;喋って詰まるところを喋りやすいように直す&lt;/li&gt;
&lt;li&gt;どうしても詰まるなら軽くメモを書く（書き過ぎない．あくまでメモ）&lt;/li&gt;
&lt;li&gt;会場に向かう前に一度喋っておく&lt;/li&gt;
&lt;li&gt;直前まで微調整する&lt;/li&gt;
&lt;li&gt;プロジェクターの接続テストをする&lt;/li&gt;
&lt;li&gt;アイスブレイクなんて普通は無理．ふざけるな&lt;/li&gt;
&lt;li&gt;デモは何度も練習する&lt;/li&gt;
&lt;li&gt;どんなすごい人でもデモは失敗する&lt;/li&gt;
&lt;li&gt;質問は最後までちゃんと聞く．わからなければ聞き直す&lt;/li&gt;
&lt;li&gt;本当にわけわからん質問はあとで話しましょうと言う．無理しない（昔わけわからんおっさんと戦ったことがあるが無駄だった）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;学術的な学会発表とは違って技術カンファレンスはとても好きだ．テーマは決まっているものの自由に話すことができる．
学会はある程度決められたフォーマットに従っていた．それは聞く側からすればわかりやすさにつながるが，喋る側からすればちょっと堅苦しかった．今は自由な感じで喋れるのを楽しんでいる．&lt;/p&gt;

&lt;p&gt;苦手だけど喋るのはなぜか? こんなん作ったとか，こんなんわかったとかシェアしたいという思いがあるから．ブログで書くのもよいけど，プレゼンはまた違ったフォーマットで伝わり方も変わるから楽しい．あと僕は若干コミュニケーションに問題がある．懇親会などで初対面のひとに喋りに行くとかはほぼ無理だ．が，プレゼンしてると，あれを喋った僕です的な感じで喋りに行くきっかけになる．カンファレンスで喋るモチベーションはここにもある．&lt;/p&gt;

&lt;p&gt;最後にここで書いているのは表層的な話である．本当に大切なのは内容．とにかく自分が喋る内容に対して自分が一番のプロフェッショナルになるのが大切だと思う．&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>