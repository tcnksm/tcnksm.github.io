<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SOTA</title>
    <link>http://deeeet.com/</link>
    <description>Recent content on SOTA</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>Copyright (C) 2013-2015 Taichi Nakashima All Right Reserved.</copyright>
    <lastBuildDate>Tue, 24 May 2016 08:07:56 +0900</lastBuildDate>
    <atom:link href="http://deeeet.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Known unknowns</title>
      <link>http://deeeet.com/writing/2016/05/24/known-unknowns/</link>
      <pubDate>Tue, 24 May 2016 08:07:56 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/05/24/known-unknowns/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.amazon.co.jp/Systems-Performance-Enterprise-Brendan-Gregg-ebook/dp/B00FLYU9T2&#34;&gt;&amp;ldquo;Systems Performance: Enterprise and the Cloud&amp;rdquo;&lt;/a&gt; をずっと読んでいる．この本はNetflixの&lt;a href=&#34;http://www.brendangregg.com/&#34;&gt;Brendan Gregg&lt;/a&gt;氏がJoyent時代に書いた本である．その名の通りLinux（とSolaris）のシステムのパフォーマンスの本である（とにかく一つ一つが丁寧かつ深く解説されておりページをめくるごとに学びしかないのでパフォーマンスに関わるひとは今すぐ読むと良い）．&lt;/p&gt;

&lt;p&gt;この本で一貫して現れてくる，通底するのが，known-knowns，known-unknownsそしてunknown-unknownsという概念である．元ネタは&lt;a href=&#34;https://en.wikipedia.org/wiki/Donald_Rumsfeld&#34;&gt;Donald Rumsfeld&lt;/a&gt; 氏の会見でのコメントだが（cf. &lt;a href=&#34;https://en.wikipedia.org/wiki/There_are_known_knowns&#34;&gt;There are known knowns&lt;/a&gt;），複雑なシステムのパフォーマンスの重要な原則を集約している．良い概念なので簡単に紹介する．&lt;/p&gt;

&lt;p&gt;それぞれをパフォーマンスの観点から説明すると以下のようになる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;known-knowns&lt;/strong&gt; - 知っていること．そのパフォーマンスのメトリクスをチェックするべきことを知っているし，現在の値も知っている．例えば，CPUの利用率をチェックするべきことを知っているし，その平均的な値が10%であることも知っている&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;known-unknowns&lt;/strong&gt; - 「知らないこと」を知っていること．そのパフォーマンスのメトリクスをチェックできること，そのようなサブシステムが存在してることを知っているが，まだそれらを観測したことがない（知らない）．例えば，profilingによって何がCPUを使いまくっているのかチェックできるのを知っているけどまだそれを実施してない．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unknown-unknowns&lt;/strong&gt; - 「知らないこと」を知らないこと．例えば，デバイス割り込みがCPUを多く消費することを知らず，そのためチェックしてないかもしれない．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;パフォーマンスというのは「知れば知るほど知らないことが増える」という分野である．システムについて学べば学ぶほど，unknown-unknownsに気づき，それはknown-unknownになり，次回からはそれをチェックできるようになる．&lt;/p&gt;

&lt;p&gt;そしてこれはパフォーマンスに限った話ではない．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GolangのGCを追う</title>
      <link>http://deeeet.com/writing/2016/05/08/gogc-2016/</link>
      <pubDate>Sun, 08 May 2016 23:01:06 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/05/08/gogc-2016/</guid>
      <description>

&lt;p&gt;Go1.5とGo1.6でGoのGCのレイテンシが大きく改善された．この変更について「ちゃんと」理解するため，アルゴリズムレベルでGoのGCについて追ってみた．&lt;/p&gt;

&lt;p&gt;まずGoのGCの現状をパフォーマンス（レイテンシ）の観点からまとめる．次に具体的なアルゴリズムについて，そして最後に実際の現場でのチューニングはどうすれば良いのかについて解説する．&lt;/p&gt;

&lt;h2 id=&#34;goのgcの今&#34;&gt;GoのGCの今&lt;/h2&gt;

&lt;p&gt;最初にGoのGCの最近の流れ（2016年5月まで）をまとめる．&lt;/p&gt;

&lt;p&gt;Go1.4までは単純なStop The World（STW）GCが実装されていたがGo1.5からは新たなGCアルゴリズムが導入された．導入の際に設定された数値目標は大きなヒープサイズにおいてもレイテンシを10ms以下に抑えることであった．Go1.5で新たなアルゴリムが実装されGo1.6で最適化が行われた．&lt;/p&gt;

&lt;p&gt;以下は公開されているベンチマーク．まずはGo1.5を見る．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.github.com/tcnksm/talks/master/2016/02/go1.6/img/go15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=aiv1JOfMjm0&#34;&gt;GopherCon 2015: Rick Hudson - Go GC: Solving the Latency Problem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;グラフの横軸はヒープサイズで縦軸はレイテンシである（小さいほどよい）．以前のバージョンと比較するとヒープの増加に伴ってレイテンシが3.0sを超えていたのがほぼ0sに抑えらているのがわかる．コミュニティからも以下のようなベンチマークが公開されている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/brianhatfield/status/634166123605331968&#34;&gt;https://twitter.com/brianhatfield/status/634166123605331968&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@robin.verlangen/billions-of-request-per-day-meet-go-1-5-362bfefa0911#.vyckzy74d&#34;&gt;Billions of request per day meet Go 1.5&lt;/a&gt; (The new version of Go reduces our 95-percentile garbage collector from 279 milliseconds down to just 10 ms)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次に以下はGo1.6のベンチマーク．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.github.com/tcnksm/talks/master/2016/02/go1.6/img/go16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/presentations/go-gc-performance&#34;&gt;QCon: Go GC: Prioritizing Low Latency and Simplicity&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;縦軸と横軸はGo1.5と同じ．まずGo1.5のグラフと比べると10倍のヒープサイズでベンチマークが行われているのがわかる．Go1.5が50GBに達する前にレイテンシが増大しているのに対してGo1.6は250GBのヒープに対しても10msのレイテンシで抑えらているのが確認できる．&lt;/p&gt;

&lt;p&gt;Go1.7のリリースが近いが，既に今までと同じくTwitterの&lt;a href=&#34;https://twitter.com/brianhatfield&#34;&gt;@brianhatfield&lt;/a&gt;氏がCanaryテストを行い，さらにGCのレイテンシが改善されたことが報告されている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-dev/n-D2RYU4nIs&#34;&gt;Go 1.7 observed performance changes (production canary@eeca3ba)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらのアップデートからGoにおいてGCのレイテンシは大規模プロダクション環境においても全く問題にならないレベルになっていることがわかる．つまりパフォーマンスに問題があったときに疑うべき場所としては優先度は低いと言える．&lt;/p&gt;

&lt;p&gt;以下ではこれらをどのように達成したのかを追っていく．&lt;/p&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;まず最初に筆者はGCに関してはほぼ初心者であった．GoのGCを少しでも「ちゃんと」理解したいがために勉強したにすぎない．そのためGCの知識は素人に毛が生えた程度でしかない．先に参考文献やリンクをまとめておくので，気になるひとは自分でそれらを追ってみるのが良い．&lt;/p&gt;

&lt;p&gt;まずGCの基礎については以下の書籍が勉強になった．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tatsu-zine.com/books/gcbook&#34;&gt;ガベージコレクションのアルゴリズムと実装&lt;/a&gt; - とにかく初心者はまずこれを読むのが良い．本書はアルゴリズム編と実装編に分かれている．アルゴリズム編では基本となるアルゴリズムが図解と疑似コードで丁寧に解説されておりGCの基礎を抑えることができる．中で述べられているようにGCの基本はGCが登場して50年たってもそれほど変わっていないのでこれらを抑えるだけでもだいぶ話に入っていける．実装編では実際のruntime例えばPythonやV8などをのコードを追っていく．これで「GCのコードの追い方」がなんとなくわかった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B01CYDGUT0&#34;&gt;ガベージコレクション&lt;/a&gt; - こちらは最近（2016年3月）発売されたばかりの本．先に上げた「ガベージコレクションのアルゴリズムと実装」がカジュアルな本であるのに対してこちらは膨大なGC研究がまとめられておりより硬派な本であると言える．基礎アルゴリズムから説明していくのは同じであるが本書は並列・並行処理/マルチコア時代のことが意識されているのが特徴的である．Goで採用されているConcurrent GCはこちらで学んだ．また参照局所性といったハードウェアに対する言及も多い&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次にGoのGCそのものについての解説は以下のRick Hudson氏の一連の発表及びブログ，デザインノートを見るとよい．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=aiv1JOfMjm0&#34;&gt;GopherCon 2015: Rick Hudson - Go GC: Solving the Latency Problem&lt;/a&gt; (&lt;a href=&#34;https://talks.golang.org/2015/go-gc.pdf&#34;&gt;slide&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/go15gc&#34;&gt;Go GC: Prioritizing low latency and simplicity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/16Y4IsnNRCN43Mx0NZc5YXZLovrHvvLhK_h0KN8woTO4&#34;&gt;Go 1.4+ Garbage Collection (GC) Plan and Roadmap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GopherConとQconの内容は基本的に同じだが後者はGo1.6に関するアップデートを幾つか含んでいる．&lt;/p&gt;

&lt;p&gt;以下の論文が参考として挙げられている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://research.microsoft.com/en-us/um/people/lamport/pubs/garbage.pdf&#34;&gt;On-the-Fly Garbage Collection: An Exercise in Cooperation&lt;/a&gt; - 基礎となったアルゴリズムについて述べた論文&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;ftp://ftp.cs.umass.edu/pub/osl/papers/sapphire-2003.pdf&#34;&gt;Sapphire: Copying GC Without Stopping the World&lt;/a&gt; - 上記のアルゴリズムの正確さと完全性，GCが「終了すること」を示した論文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また&lt;a href=&#34;https://golang.org/pkg/runtime/&#34;&gt;runtime package&lt;/a&gt;のソースコード（&lt;code&gt;mgc.go&lt;/code&gt;）にも具体的な実装の解説がコメントで書かれているので参考になる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/mgc.go&#34;&gt;https://golang.org/src/runtime/mgc.go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;またGo1.4以前のGCの歴史はstackovwerflowに良い回答があったのでそちらを見ると良い．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/7823725/what-kind-of-garbage-collection-does-go-use/7824353#7824353&#34;&gt;What kind of Garbage Collection does Go use?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下はこれらを自分の言葉で整理し直したものである．&lt;/p&gt;

&lt;h2 id=&#34;ハードウェアの進化とソフトウェアの進化&#34;&gt;ハードウェアの進化とソフトウェアの進化&lt;/h2&gt;

&lt;p&gt;Rick Hudson氏が発表でもブログでも述べていたことだが，GoのGCは現在だけではなくて10年後も使えるものを目指している．ハードウェアの進化を見据えてソフトウェアを改善している．&lt;/p&gt;

&lt;p&gt;今回のGoのGCの変更で仮定されているのは「将来のハードウェアがGCのスループットを改善する」である．そのためGCが目指したのはレイテンシの改善である（レイテンシのためにスループットを犠牲にされている）．&lt;/p&gt;

&lt;h2 id=&#34;goのgcアルゴリズム&#34;&gt;GoのGCアルゴリズム&lt;/h2&gt;

&lt;p&gt;Go1.5以降のGCアルゴリズムはConcurrent Mark &amp;amp; Sweepである．GC中のオブジェクトの状態の表現にはTri-color markig（三色マーキング）を用いている．&lt;/p&gt;

&lt;h3 id=&#34;mark-sweep&#34;&gt;Mark &amp;amp; Sweep&lt;/h3&gt;

&lt;p&gt;まずMark &amp;amp; Sweepについて説明する．Mark &amp;amp; Sweepは基礎中の基礎のGCアルゴリズムである．アルゴリズムはその名前の通りMarkとSweepという2つのフェーズに分けられる．まずMarkフェーズではルートを起点にポインタを辿りオブジェクトにマークをつけていく．次にSweepフェーズではマークが付けられていないオブジェクトをフリーリストに追加していく．フリーリストに追加された領域は次回のアロケーションで利用可能になる．&lt;/p&gt;

&lt;p&gt;つまりMark &amp;amp; Sweepではルートから到達可能なオブジェクトを生きているオブジェクトとし到達不可能なオブジェクトを死んでいると判別し回収する．オブジェクトがミューテータ（アプリケーション）に実際に使われているか?  といった判別は行わない（つまり全く使われていないにもかかわらずルートから到達できればオブジェクトは掃除されることはない）．&lt;/p&gt;

&lt;h3 id=&#34;gcはなぜ問題になるのか&#34;&gt;GCはなぜ問題になるのか?&lt;/h3&gt;

&lt;p&gt;こう見るとGCは非常に単純に見える．しかしGCは多くのアプリケーションで大きな問題になる．それはStop The World（STW），つまりミューテータの実行を止めること，が必要になるからである．なぜならミューテータはGCがオブジェクトが生きているか死んでいるかを判断している間にヒープのトポロジを変更してしまうからである．&lt;/p&gt;

&lt;p&gt;例えば，GCの途中にミューテータが新たにアロケーションを行ってしまった場合を考える．するとそのオブジェクトはマークされず，生きているのにもかかわらずSweepの対象になってしまうかもしれない．これは大きなバグになる．GCの正確さを保証するためにはミューテータとコレクタの動作を同期させる必要がある．&lt;/p&gt;

&lt;p&gt;この同期のための最も単純な戦略はGCを行っている間はミューテータを完全に止めてしまう方法である．しかしこれではアプリケーションはまともなサービスを提供できなくなる．例えばWebアプリケーションにおいてはしばらくレスポンスを返せないなどといった状況が発生してしまうかもしれない．GCの研究においてSTWをいかに短くするか，レイテンシをいかに小さくするか，もしくは避けるか，は大きな分野である（他には断片化をいかに少なくしてヒープの使用効率を良くするかといった方向もある）．&lt;/p&gt;

&lt;p&gt;Go1.4以前のGCはこの単純なSTWであり，レイテンシが大きな問題になっていた．以下で説明する，Tri-color markingやConcurrent GCはSTWを減らし，レイテンシを改善するための方法である．&lt;/p&gt;

&lt;h3 id=&#34;tri-color-marking&#34;&gt;Tri-color marking&lt;/h3&gt;

&lt;p&gt;一度にGCのプロセスを全て実行するのではなく，GCの実行を分割し，ミューテータと交互に実行させることでレイテンシを小さくすることができる．このように実行するGCをインクリメンタルGCと呼ぶ．Tri-color marking（三色マーキング）は，インクリメンタルGCを可能にするためのオブジェクトの抽象化である．&lt;/p&gt;

&lt;p&gt;Tri-color markingはその名の通りGC中のオブジェクトを状態に応じて以下の3種類に分類する．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;白 - まだ探索されていないオブジェクト&lt;/li&gt;
&lt;li&gt;グレー - 探索途中のオブジェクト&lt;/li&gt;
&lt;li&gt;黒 - 探索済みのオブジェクト&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mark &amp;amp; SweepをTri-color markingを使ってインクリメンタルに実行すると以下の3つのフェーズに分けることができる．GCの開始時点では全てのオブジェクトの色は白である．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ルートスキャンフェーズ - ルートから直接参照可能なオブジェクトをグレーに塗る&lt;/li&gt;
&lt;li&gt;マークフェーズ - グレーのオブジェクトを取り出し，その子オブジェクトをグレーに塗る．全ての子オブジェクトがグレーに塗られたらそのオブジェクトは黒に塗られる&lt;/li&gt;
&lt;li&gt;スイープフェーズ - ヒープ領域をスキャンし白いオブジェクトを死んでいるオブジェクトであると判別してフリーリストに連結する．また黒いオブジェクトは白色に戻す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ルートスキャンフェーズはGCの開始時に一度だけ実行される．マークフェーズでは，全てのグレーオブジェクトを一度に全て処理するのではなく，一定個数だけ処理して中断し，ミューテータの実行を再開する．これを繰り返しグレーのオブジェクトがなくなるまでこのフェーズを続ける．スイープフェーズもヒープを一括でスキャンするのではなく順次スキャンする．ミューテーターは，ルートスキャンフェーズとマークフェーズの間，マークフェーズの間，そしてスイープフェーズの間に実行が再開される．&lt;/p&gt;

&lt;h3 id=&#34;ライトバリア&#34;&gt;ライトバリア&lt;/h3&gt;

&lt;p&gt;マークフェーズを中断しミューテータを再開する場合を考える．この時に何も考慮しないと問題が発生する．&lt;/p&gt;

&lt;p&gt;例えば，ミューテータを再開した際に，グレーのオブジェクトAから参照された白いオブジェクトBがあるとする．ミューテータがこのオブジェクトBを別の黒いオブジェクトCから参照するようにポインタを更新し，かつオブジェクトAからの参照を削除してしまったとする．このままマークフェーズが再開するとどうなるか? 黒いオブジェクトCは「探索済み」である．よってオブジェクトCは再びスキャンされることはない．新たに参照された白いオブジェクトBもスキャンされることはなく「マーク漏れ」が発生する．つまり生きいるのに回収されるという大きな問題が発生してしまう．&lt;/p&gt;

&lt;p&gt;この「マーク漏れ」（オブジェクトの迷子）が発生するのは以下の2つの条件が成立する時である．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ミューテータが白いオブジェクトへのポインタを黒いオブジェクトに書き込む&lt;/li&gt;
&lt;li&gt;すべてのグレーのオブジェクトから，その白いオブジェクトへの経路が削除される&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを防ぐのがライトバリアである．ライトバリアはGenerational GC（世代別GC）などでも使われる手法である．インクリメンタルGCのライトバリアはいくつか提案されている．Dijkstraによって提案された手法では「新たに参照されるオブジェクトが白いオブジェクトであればそれをグレーとする」．上の例だと，白いオブジェクトBを黒いオブジェクトCから参照するときにオブジェクトBをグレーにする．こうすることでBの「マーク漏れ」を防ぐことができる．&lt;/p&gt;

&lt;p&gt;インクリメンタルGCによりミューテータの実行を長時間妨げることはなくなり，レイテンシは大きく改善できる．しかし，このライトバリアによってオーバーヘッドを避けることができない．よってスループットを犠牲にする必要がある．&lt;/p&gt;

&lt;h3 id=&#34;concurrent-mark-sweep&#34;&gt;Concurrent Mark &amp;amp; Sweep&lt;/h3&gt;

&lt;p&gt;これらをConcurentに実行しているのがGoのGCである．並行への移行は単純なステップである．新たに加わる困難はコレクタとミューテータが適切に同期してヒープの一貫したビューを維持することである．&lt;/p&gt;

&lt;p&gt;GoはそれぞれのOSスレッド上にスケジューリングのコンテキストを持つ．このコンテキストはGoroutineのためのローカルのスケジューラであるとみなせ，&lt;code&gt;runtime&lt;/code&gt;のコードではPと呼ばれる（詳しくは&lt;a href=&#34;https://morsmachine.dk/go-scheduler&#34;&gt;&amp;ldquo;The Go scheduler&amp;rdquo;&lt;/a&gt; がわかりやすい）．GCにおいては，フェーズ（スキャンフェーズなど）が変わるたびに，すべてのPからのackを待つことで複数のスレッド間の同期を行っている．&lt;/p&gt;

&lt;p&gt;GCは終了することが重要である．Concurrent GCではミューテータがGCプロセスと同時に動くためオブジェクトは次々に新たにアロケートされていく．このためマークフェーズが収束しない可能性がある．これを解決するためにGoではマークフェーズ後に&lt;code&gt;marktermination&lt;/code&gt;フェーズが存在する．ここでは新たなオブジェクトは全て黒色でアロケートされる．これによりGCは収束に向かう．&lt;/p&gt;

&lt;h2 id=&#34;gogc-goのgcをチューニングする&#34;&gt;GOGC（GOのGCをチューニングする）&lt;/h2&gt;

&lt;p&gt;GCというとJavaのようなたくさんのチューニングパラメーター（&lt;code&gt;xms&lt;/code&gt;や&lt;code&gt;xmx&lt;/code&gt;）を思い浮かべる．Goにはただ1つの&lt;code&gt;GOGC&lt;/code&gt;という環境変数がGCをチューニングするパラメーターとして提供されている．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GOGC&lt;/code&gt;はGoにおける最も古い環境変数の1つである（&lt;a href=&#34;http://dave.cheney.net/2015/11/29/a-whirlwind-tour-of-gos-runtime-environment-variables&#34;&gt;A whirlwind tour of Go&amp;rsquo;s runtime environment variables&lt;/a&gt;）．この環境変数はGCのAggressivenessを決める．&lt;/p&gt;

&lt;p&gt;デフォルト値は&lt;code&gt;100&lt;/code&gt;である．これはある時点でのGC完了後に到達可能であったオブジェクトのサイズよりも100%，つまり2倍大きなヒープサイズが消費されたら次のGCを実行するという意味である．&lt;/p&gt;

&lt;p&gt;どのようにチューニングするか? まずより大きな値，例えば&lt;code&gt;200&lt;/code&gt;をセットする．これはある時点でのGC完了後に到達可能であったあったオブジェクトのサイズよりも200%，つまり3倍のヒープサイズが消費されたら次のGCを実行するという意味である．つまりGCの実行を遅らせることができる．RAMに余裕がありGCに使われる合計時間を減らしたい（スループットを向上させたい）場合は大きな値を設定する．．&lt;/p&gt;

&lt;p&gt;次により小さな値を設定するとGCの実行間隔が短くなる．メモリの使用量を少なくしたい場合は小さな値を設定する（&lt;code&gt;off&lt;/code&gt;を設定するとGCは実行されなくなる）．&lt;/p&gt;

&lt;p&gt;GoのGCはハードウェアの進化が考慮されているのであった．もしハードウェアが進化してRAMの容量が2倍なったらどうするか．&lt;code&gt;GOGC&lt;/code&gt;の値を2倍にすればGCのサイクルを半分にすることができ，チューニングなしでアプリケーションを簡単にスケールさせることができる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;GoのGCの変更について追ってみた．追ってみて他の言語と比べてもシンプルなGCが実装されているなあと感じた．そのためアルゴリズムなどを理解するのは容易だった．シンプルさの思想がGCにもあるのは良いなあと感じた．&lt;/p&gt;

&lt;p&gt;GCにはレイテンシやスループット以外にも解決するべき問題がある．例えばGoの場合は断片化の問題などは考慮されていない．今後その他の問題にどのように対処していくのかも楽しみになった．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golangのエラー処理とpkg/errors</title>
      <link>http://deeeet.com/writing/2016/04/25/go-pkg-errors/</link>
      <pubDate>Mon, 25 Apr 2016 09:00:22 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/04/25/go-pkg-errors/</guid>
      <description>

&lt;p&gt;GoConでは毎回エラー処理について面白い知見が得られる．&lt;a href=&#34;http://gocon.connpass.com/event/9748/&#34;&gt;Go Conference 2014 autumn&lt;/a&gt; においては（実際のトークではないが）居酒屋にて&lt;a href=&#34;https://twitter.com/jxck_&#34;&gt;@Jxck&lt;/a&gt;さんがRob Pike氏から以下のようなテクニックを紹介してもらっていた．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;Errors are values - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/golang-error-handling-lesson-by-rob-pike&#34;&gt;Golang Error Handling lesson by Rob Pike&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これはWrite（やRead）のエラー処理が複数続く場合に&lt;code&gt;errWriter&lt;/code&gt; を定義して複数のエラー処理を一箇所にまとめてコードをすっきりとさせるテクニックであった．&lt;/p&gt;

&lt;p&gt;そして今回の &lt;a href=&#34;http://gocon.connpass.com/event/27521/&#34;&gt;Go Conference 2016 spring&lt;/a&gt; のkeynoteにおいてもDave Cheney氏から（僕にとっては）新たなエラー処理テクニックが紹介された．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dave.cheney.net/paste/gocon-spring-2016.pdf&#34;&gt;Gocon Spring 2016&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際に使ってみて/コードを読んでみて（飲み会でもコードとともにいろいろ教えてもらった）自分の抱えている問題を解決できそうで使ってみたいと思えた．&lt;/p&gt;

&lt;p&gt;本記事では現在のエラー処理の問題と発表で紹介された&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;pkg/errors&lt;/a&gt;についてまとめる．なお上記のスライドにはトークノートも書かれているので具体的な内容はそちらを見るのが良い．&lt;/p&gt;

&lt;h2 id=&#34;問題&#34;&gt;問題&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/jxck_&#34;&gt;@Jxck&lt;/a&gt;さんのケースは1つの関数において複数のエラーハンドリングが煩雑になる，言わば縦方向のエラー処理の問題であった．Dave氏のトークで語られているのは深さ方向のエラー処理の問題である．大きく分けて2つの問題がある．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最終的に表示されるエラーメッセージ&lt;/li&gt;
&lt;li&gt;特定のエラーに対する分岐処理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下ではそれらを具体的に説明する．&lt;/p&gt;

&lt;h3 id=&#34;エラーメッセージ&#34;&gt;エラーメッセージ&lt;/h3&gt;

&lt;p&gt;まずはエラーメッセージについて．以下は基本的なGoのエラー処理である．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Foo() error {
    conf, err := ReadConf()
    if err != nil {
        return err
    }
    ...
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Foo()&lt;/code&gt;が&lt;code&gt;ReadConf()&lt;/code&gt;を呼び，&lt;code&gt;ReadConf()&lt;/code&gt;がエラーを返せばそれを&lt;code&gt;err&lt;/code&gt;として返し，そうでなければ&lt;code&gt;conf&lt;/code&gt;をつかった処理を続行し問題がなければ&lt;code&gt;nil&lt;/code&gt;を返す．&lt;/p&gt;

&lt;p&gt;大きなパッケージやツールになるとこの定型的な処理はどんどん連なり深くなる．例えばこの例の場合は&lt;code&gt;ReadConf()&lt;/code&gt;がさらに&lt;code&gt;Write()&lt;/code&gt;といった標準パッケージの関数を呼びそのエラーを返すかもしれないし，&lt;code&gt;Foo()&lt;/code&gt;は別の関数から呼ばれその中でエラーが処理されるかもしれない．&lt;/p&gt;

&lt;p&gt;これらの一連のエラーは最終的にどうなるか? コマンドラインツールやWebサーバーの&lt;code&gt;main()&lt;/code&gt;に戻り以下のように&lt;code&gt;fmt.Printf()&lt;/code&gt;（や&lt;code&gt;log&lt;/code&gt;）を使って適切なエラーメッセージとしてユーザに表示する（&amp;rdquo;べき&amp;rdquo;である）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Printf(&amp;quot;Failed Foo: %s&amp;quot;,err)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この単純な&lt;code&gt;return err&lt;/code&gt;の連鎖は問題を起こす．最終的にユーザに表示されるエラーメッセージにはその後のデバッグに対してなんの情報も提示できないことがある．つまりどの関数のどこでエラーが発生したのか追えなくなる．例えば発表でも触れられていたように&lt;code&gt;no such file or directory&lt;/code&gt;のみ表示されるケースに出会った人は多いと思う．他にもGoのツールだとTLSに関わるエラーなどで困ったひとは多いと思う（これはググるとDockerのGithub Issueが最初に現れるw）．&lt;/p&gt;

&lt;p&gt;この問題に対してできることは&lt;code&gt;fmt.Errorf()&lt;/code&gt;を使って具体的なエラーの状況を付加することである．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Foo() error {
    conf, err := ReadConf()
    if err != nil {
        return fmt.Errorf(&amp;quot;failed to read configuration file: %s&amp;quot;)
    }
    ...
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはよくPR reviewで指摘することだと思う．これで最終的に提示されるエラーはよりデバッグのしやすいものになる．&lt;/p&gt;

&lt;p&gt;しかし&lt;code&gt;fmt.Errorf()&lt;/code&gt;は&lt;code&gt;error&lt;/code&gt;を別の&lt;code&gt;string&lt;/code&gt;に結合して別の&lt;code&gt;error&lt;/code&gt;をつくり出す．原因となったエラーが特定の型を持っていた場合にそれを隠蔽してしまう．これにより&lt;code&gt;fmt.Errorf()&lt;/code&gt;は次に説明する呼び出し元での分岐処理を難しくする．&lt;/p&gt;

&lt;h3 id=&#34;分岐処理&#34;&gt;分岐処理&lt;/h3&gt;

&lt;p&gt;次に特定のエラーに対する呼び出し元での分岐処理の問題について説明する．関数の呼び元において特定のエラーが返ってきたときに単純にそれを返す，もしくはユーザに表示するのではなく，別の処理をしたいという場合がある．例えばリトライ処理を行うなど．&lt;/p&gt;

&lt;p&gt;これは様々な方法がある．が，以下は避けるべきである．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;error.Error()&lt;/code&gt;して中身をみて&lt;code&gt;string&lt;/code&gt;として使う&lt;/li&gt;
&lt;li&gt;Sentinel error（&lt;code&gt;io.EOF&lt;/code&gt;など）を使う&lt;/li&gt;
&lt;li&gt;自分でError typeを定義してType assertionする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1つ目は初心者がやりがちだが最も避けるべき方法である．他の2つを避ける理由は呼び出しに別の依存をもたらすことになるのが大きな理由（スライドにはもっと詳しい例があるのでそちらを見るとよい）．無駄なCouplingは避ける．基本的には単純な&lt;code&gt;error&lt;/code&gt;を返すというパッケージ間のContractを破るべきではない．&lt;/p&gt;

&lt;p&gt;ではどうするのが良いか? 型ではなくインターフェースを考える（Assert errors for behaviour, not type）．以下のようにする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type temporary interface {
    Temporary() bool 
}

func IsTemporary(err error) bool { 
   te, ok := err.(temporary) 
   return ok &amp;amp;&amp;amp; te.Temporary() 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;err&lt;/code&gt;が&lt;code&gt;temporary&lt;/code&gt;インターフェースを実装していれば&lt;code&gt;Temporary()&lt;/code&gt;関数で特別な分岐処理をするべきか（例えばリトライするべきか）どうかを判別して返す．していなければ無関係なエラーとして単純に&lt;code&gt;false&lt;/code&gt;を返し特別な処理分岐をスキップする．これは無駄な依存やCouplingを避けることができる．&lt;/p&gt;

&lt;p&gt;しかしこの方法と上述した&lt;code&gt;fmt.Errorf()&lt;/code&gt;によるエラーメッセージ問題を同時に解決することはできない．&lt;code&gt;fmt.Errorf()&lt;/code&gt;がエラーを作り直してしまうからである（元のエラーがインターフェースを持っていたか追えなくなる）．&lt;/p&gt;

&lt;h2 id=&#34;errorsを使う&#34;&gt;errorsを使う&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;errors&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;errors&lt;/code&gt;は上記で説明したエラーメッセージ問題を良い感じに解決しつつ処理分岐にも対応する．&lt;code&gt;errors&lt;/code&gt; パッケージは以下のような関数を持つ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Wrap(cause error, message string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Cause(err error) error
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wrap&#34;&gt;Wrap()&lt;/h3&gt;

&lt;p&gt;まず&lt;code&gt;Wrap()&lt;/code&gt;はオリジナルの&lt;code&gt;error&lt;/code&gt;を具体的なエラーの状況（&lt;code&gt;message&lt;/code&gt;）とともにラップした新たな&lt;code&gt;error&lt;/code&gt;を返す．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;conf, err := ReadConf()
if err != nil {
    return errors.Wrap(err, &amp;quot;failed to read configuration file&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この&lt;code&gt;Error()&lt;/code&gt;の結果は以下の&lt;code&gt;error&lt;/code&gt;と同じである．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Errorf(&amp;quot;failed to read configuration file: %s&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数のインターフェースとしてそのエラーのコンテキスト（annotation）を要求するのがよい．最終的に出力されるエラーメッセージは&lt;code&gt;fmt.Errorf()&lt;/code&gt;と同じ結果になりエラー処理の方法も変わらない．&lt;/p&gt;

&lt;p&gt;これだけではなく&lt;code&gt;Wrap()&lt;/code&gt;は呼ばれたファイルとその行数も同時に内部に記録する．同パッケージの&lt;code&gt;Print&lt;/code&gt;（&lt;code&gt;Fprint&lt;/code&gt;）を使うと以下のような詳細なエラーメッセージを表示することができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;err := fn()
errors.Fprint(os.Stderr, err)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;read.go:3: A.conf is not exist
conf.go:35: failed to read configuration
main.go:100: Failed to run fn()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは単純に&lt;code&gt;fmt.Errorf&lt;/code&gt;を使うより便利なので移行の理由になる．&lt;/p&gt;

&lt;h3 id=&#34;cause&#34;&gt;Cause()&lt;/h3&gt;

&lt;p&gt;次に&lt;code&gt;Cause()&lt;/code&gt;は元となったエラーをそのまま取り出す．&lt;code&gt;fmt.Errorf&lt;/code&gt;はコンテキストを付与できる一方で新しいエラーを返してしまうために呼び出し元での処理の分岐がやりにくくなってしまった．&lt;code&gt;Cause()&lt;/code&gt;は以下のインターフェースを&lt;code&gt;error&lt;/code&gt;に持たせることで元となった&lt;code&gt;error&lt;/code&gt;を取り出す関数である．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Causer interface {
    Cause() error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを使うと上記の&lt;code&gt;temporary&lt;/code&gt;インターフェースの例は以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func IsTemporary(err error) bool { 
    te, ok := errors.Cause(err).(temporary)
    return ok &amp;amp;&amp;amp; te.Temporary() 
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん&lt;code&gt;Wrap()&lt;/code&gt;はデフォルトで元の&lt;code&gt;error&lt;/code&gt;を保持し，かつ&lt;code&gt;Causer&lt;/code&gt;インターフェースを満たすので&lt;code&gt;Cause()&lt;/code&gt;をそのまま使える．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;errors&lt;/a&gt;を使うとエラーにコンテキストを付与しつつ，オリジナルのエラーを保持し呼び出し元において処理の分岐を行うことができる．かつ&lt;code&gt;error&lt;/code&gt;を介すので標準的なContractから外れることもない．&lt;/p&gt;

&lt;p&gt;Canonicalのいくつかのツールでも使われている（&lt;code&gt;juju&lt;/code&gt;も似たパッケージ&lt;a href=&#34;https://github.com/juju/errors&#34;&gt;juju/errors&lt;/a&gt;を使っている）らしい．そして&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;errors&lt;/a&gt;はそれらのシンプル版とのこと．&lt;/p&gt;

&lt;p&gt;こういう標準パッケージに則した薄いライブラリはとても好きなので使っていきたい．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年振り返り</title>
      <link>http://deeeet.com/writing/2015/12/31/2015/</link>
      <pubDate>Thu, 31 Dec 2015 23:19:18 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/12/31/2015/</guid>
      <description>

&lt;p&gt;2015年の振り返りとして自分が好きだったもの，影響を受けたものを雑多にまとめる．それに合わせて自分の活動についても振り返り，2016年の展望を書く（&lt;a href=&#34;http://blog.fogus.me/&#34;&gt;fogus: Send More Paramedics&lt;/a&gt;の形式が良かったのでそれを真似ている）．&lt;/p&gt;

&lt;h2 id=&#34;blog-posts-read&#34;&gt;Blog posts read&lt;/h2&gt;

&lt;p&gt;今年読んで印象に残った，影響を受けたブログ記事．順不同．&lt;/p&gt;

&lt;h3 id=&#34;japanese&#34;&gt;Japanese&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.sigbus.info/2015/01/p1.html&#34;&gt;コードを書くことは無限の可能性を捨てて一つのやり方を選ぶということ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.kengo-toda.jp/entry/2015/03/22/215005&#34;&gt;7年働いた時点での私の仕事の極意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.jockinsey.com/settingalowbar&#34;&gt;志低く&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://myfinder.hatenablog.com/entry/2015/03/27/141416&#34;&gt;ソフトウェアエンジニアだけでサービス運用できる環境を作って失業した話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mrorii.github.io/blog/2015/04/04/language-of-food/&#34;&gt;食べログの口コミに見る人間心理 -麻薬と性とトラウマと-&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.livedoor.jp/sonots/archives/44075238.html&#34;&gt;運用を楽にするためのアプリケーションコードを書くということ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hb.matsumoto-r.jp/entry/2015/04/20/151743&#34;&gt;Webオペレーションエンジニアのアウトプットと開発力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hail2u.net/blog/software/patience-time.html&#34;&gt;我慢の期間&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yuuki.hatenablog.com/entry/2015-webserver-architecture&#34;&gt;2015年Webサーバアーキテクチャ序論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://anemone.dodgson.org/2015/07/13/a-million-hello-worlds/&#34;&gt;A Million Hello Worlds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hb.matsumoto-r.jp/entry/2015/08/23/220153&#34;&gt;技術者が研究者のように論文を書くメリットはあるか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://t-wada.hatenablog.jp/entry/active-oss-development-vs-simplicity&#34;&gt;OSS開発の活発さの維持と良いソフトウェア設計の間には緊張関係があるのだろうか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.twitter.com/ja/2015/buttons&#34;&gt;持続的なプラットフォームのための難しい決断&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://anond.hatelabo.jp/20151117013422&#34;&gt;翻訳は/誰がやっても/間違える&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://steps.dodgson.org/b/2012/12/30/code-review-from-lowland/&#34;&gt;下から目線のコードレビュー&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;english&#34;&gt;English&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.linux.com/news/featured-blogs/200-libby-clark/806347-collaboration-summit-keynote-alex-polvi-coreos&#34;&gt;CoreOS Co-Founder Alex Polvi Talks Containers, Rocket vs. Docker, and More&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mnot.net/blog/2015/02/18/http2&#34;&gt;HTTP/2 is Done&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.shubhro.com/2014/12/27/software-engineers-should-write/&#34;&gt;Software engineers should write&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@darrenrush/after-docker-unikernels-and-immutable-infrastructure-93d5a91c849e#.7x8i5lfvt&#34;&gt;After Docker: Unikernels and Immutable Infrastructure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/199PqyG3UsyXlwieHaqbGiWVa8eMWi8zzAn0YfcApr8Q/edit&#34;&gt;My Philosophy on Alerting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://thenewstack.io/new-stack-mitchell-hashimoto-containers-no-containers-one-question-2015&#34;&gt;Mitchell Hashimoto: Containers or No Containers? That is One Question for 2015&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://coreos.com/blog/cluster-osi-model/&#34;&gt;What makes a cluster a cluster?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pl-enthusiast.net/2015/03/25/interview-with-gos-russ-cox-and-sameer-ajmani/&#34;&gt;Interview with Go’s Russ Cox and Sameer Ajmani&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.toolshed.com/2015/05/the-failure-of-agile.html&#34;&gt;The Failure of Agile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http/&#34;&gt;Deprecating Non-Secure HTTP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://influxdb.com/blog/2015/06/03/InfluxDB_clustering_design.html&#34;&gt;InfluxDB Clustering Design - neither strictly CP or AP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.circleci.com/its-the-future/&#34;&gt;It&amp;rsquo;s The Future&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mkremins.github.io/blog/unix-not-acceptable-unix/&#34;&gt;Unix is not an acceptable Unix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.parse.com/learn/how-we-moved-our-api-from-ruby-to-go-and-saved-our-sanity/&#34;&gt;How We Moved Our API From Ruby to Go and Saved Our Sanity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mitchellh.com/apple-the-key-to-my-success&#34;&gt;APPLE: My Key to Success&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jmoiron.net/blog/thoughts-on-timeseries-databases/&#34;&gt;Thoughts on Time-series Databases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kismatic.com/company/qa-with-malte-schwarzkopf-on-distributed-systems-orchestration-in-the-modern-data-center/&#34;&gt;Omega, and what it means for Kubernetes: a Q&amp;amp;A about cluster scheduling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boxfuse.com/blog/no-ssh.html&#34;&gt;Immutable Infrastructure: No SSH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mitchellh.com/automation-obsessed&#34;&gt;Automation Obsessed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jvns.ca/blog/2015/11/21/why-you-should-understand-a-little-about-tcp/&#34;&gt;Why you should understand (a little) about TCP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://misfra.me/2015/07/20/time-series-databases-discussion-notes/&#34;&gt;Time Series Databases Discussion Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dave.cheney.net/2015/11/05/lets-talk-about-logging&#34;&gt;Let&amp;rsquo;s talk about logging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://http2.cloudflare.com/the-story-of-one-latency-spike/&#34;&gt;The story of one latency spike&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html&#34;&gt;Linux Performance Analysis in 60,000 Milliseconds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.cloudflare.com/introducing-http2/&#34;&gt;HTTP/2 is here! Goodbye SPDY? Not quite yet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://composition.al/blog/2015/12/29/refactoring-as-a-way-to-understand-code/&#34;&gt;Refactoring as a way to understand code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.agner.org/optimize/blog/read.php?i=417&#34;&gt;Moores law hits the roof&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;blog-posts-by-me&#34;&gt;Blog posts by me&lt;/h2&gt;

&lt;p&gt;今年は30本の記事を書いた．大体月2-3本くらい．ほとんどが技術関連の記事だったが，趣味のCoffeeに関するものも2本ほど書いた．年間のPVは &lt;strong&gt;275,966&lt;/strong&gt; viewsだった．特に読まれたのは以下の記事．順番はPV順．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/02/17/docker-bad-points/&#34;&gt;Dockerの諸問題とRocket登場の経緯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/09/01/apache-kafka/&#34;&gt;Apache Kafkaに入門した&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/06/26/golang-dependency-vendoring/&#34;&gt;Go言語のDependency/Vendoringの問題と今後．gbあるいはGo1.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/03/17/serverspec-for-automation/&#34;&gt;デプロイ自動化とServerspec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/10/04/otto/&#34;&gt;Hashicorp Ottoを読む&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;特にある分野の現状の問題を整理した記事がよく読まれたと思う．このような記事は自分の頭も書くことで整理されたので良かった．&lt;/p&gt;

&lt;p&gt;2015年は後半になるにつれて長文の記事を書いてしまう傾向があった．2016年はダラダラと書くのではなく短くシンプルな記事を目指していきたい（&lt;a href=&#34;https://twitter.com/omo2009&#34;&gt;@omo2009&lt;/a&gt;さんの記事くらいの長さが目標）．2015年は1本だけ英語の記事を書いた（cf. &lt;a href=&#34;http://deeeet.com/writing/2015/05/11/gox-server/&#34;&gt;Golang Cross Compiler on Heroku (with Docker)&lt;/a&gt;）．2016年は英語の記事の量も増やしていきたい．&lt;/p&gt;

&lt;h2 id=&#34;presentations&#34;&gt;Presentations&lt;/h2&gt;

&lt;p&gt;今年印象に残った，影響を受けた発表．実際にカンファレンスで観れたもの，参加できなくて後日スライドのみを観たものを含む．順不同．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/yutakakinjyo/hackerscample-lt-49900119&#34;&gt;一度死んだ話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/kelseyhightower/cfgmgmtcamp-2015/slides/coreos-kubernetes.slide#1&#34;&gt;Managing Containers at Scale with CoreOS and Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/hayabusa333/ss-16114338&#34;&gt;漏れのある抽象化の法則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://talks.golang.org/2015/gogo.slide#1&#34;&gt;Go in Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/benbjohnson/raft-the-understandable-distributed-consensus-protocol&#34;&gt;Raft: The Understandable Distributed Consensus Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/pirhilton/how-to-name-things-the-hardest-problem-in-programming&#34;&gt;How to name things: the hardest problem in programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/a_matsuda/the-recipe-for-the-worlds-largest-rails-monolith&#34;&gt;he Recipe for the World&amp;rsquo;s Largest Rails Monolith&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/mirakui/developer-productivity-in-cookpad&#34;&gt;Developer Productivity in Cookpad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/taijitsuchiya5/ss-47398248&#34;&gt;なぜネットワーク運用自動化が進まないのか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/jacopen/openpaas-paas&#34;&gt;ひしめき合うOpen PaaSを徹底解剖！ PaaSの今と未来&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://techblog.netflix.com/2015/08/netflix-at-velocity-2015-linux.html&#34;&gt;Velocity 2015 linux perf tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hitode909.hatenablog.com/entry/2015/08/21/165932&#34;&gt;Perlの上にも三年 〜 ずっとイケてるサービスを作り続ける技術 〜&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chibicode.com/sf-hell/&#34;&gt;#地獄のサンフランシスコ by @chibicode / 上杉周作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;presentations-by-me&#34;&gt;Presentations by me&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tcnksm/talks&#34;&gt;github.com/tcnksm/talks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今年は9回発表をした．以下がスライド．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/coreoskurasutanidockerkontenawodepuroi-number-dockerjp&#34;&gt;&amp;ldquo;Deploy Docker Containers on CoreOS Cluster&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://connpass.com/event/10318/&#34;&gt;Docker Meetup Tokyo #4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/coreoskurasutafalsedockerkontenafalsejian-shi-number-monitoringcasual&#34;&gt;&amp;ldquo;Monitor Docker Containers on CoreOS Cluster&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://www.zusaar.com/event/9807003&#34;&gt;Monitoring Casual Talks #7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/aruruo-shou-inhuraenziniafalsexian-zhuang-que-ren-number-wakateinfra&#34;&gt;&amp;ldquo;A wakete infra engineer&amp;rdquo;&lt;/a&gt; at Wakate Infra meetup&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/introduction-of-coreos-at-coreos-meetup-tokyo-number-1-number-coreosjp&#34;&gt;&amp;ldquo;Introduction of CoreOS&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://coreos-meetup-tokyo.connpass.com/event/12596/&#34;&gt;CoreOS meetup Tokyo #1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/what-i-talk-about-when-i-talk-about-cli-tool-by-golang-number-gocon&#34;&gt;&amp;ldquo;What I Talk About When I Talk About CLI Tool By Golang #gocon&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://gocon.connpass.com/event/14063/&#34;&gt;Go Conference 2015 Summer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/how-to-dev-and-ops-internal-paas&#34;&gt;&amp;ldquo;How to Dev&amp;amp;Ops Internal PaaS&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://www.zusaar.com/event/9057007&#34;&gt;Hosting Casual #2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/tcnksm/talks/2015/07/jtf2015.Slide#1&#34;&gt;&amp;ldquo;若手インフラエンジニアたちが語る技術トレンドと数年後の未来&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://2015.techfesta.jp/&#34;&gt;JTF2015&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/tcnksm/talks/2015/08/hashicorp-meetup.slide#1&#34;&gt;&amp;ldquo;Go pakcages from Hashicorp&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://engineer.wantedly.com/2015/08/06/hashicorp-product-meetup.html&#34;&gt;Hashicorp Meetup&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今年は特に&lt;a href=&#34;https://twitter.com/hashtag/wakateinfra&#34;&gt;#wakateinfra&lt;/a&gt;として同年代の人と知り合いになれたのがとても良かった．&lt;/p&gt;

&lt;h2 id=&#34;podcasts&#34;&gt;Podcasts&lt;/h2&gt;

&lt;p&gt;好きだったPodcastエピソード．順不同．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mozaic.fm/post/133930208998/20-browser&#34;&gt;#20 Browser | mozaic.fm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://changelog.com/180/&#34;&gt;#180: Otto, Vagrant, and Automation with Mitchell Hashimoto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://changelog.com/168/&#34;&gt;#168: Prometheus and Service Monitoring with Julius Volz from SoundCloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://changelog.com/151/&#34;&gt;#151: Rust with Steve Klabnik and Yehuda Katz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/101/&#34;&gt;Rebuild: 101: Before And After Refactoring (Dice)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/99/&#34;&gt;Rebuild: 99: The Next Generation Of HTTP (kazuho)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/91/&#34;&gt;Rebuild: 91: The PHP Way (Naoya Ito)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/81/&#34;&gt;Rebuild: 81: Enable The Broken Web (Hajime Morrita)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通勤時間が短くなった影響もあり以前よりも多くを聴けなくなった．2016年は運動をもう少し増やしてその間に聴こうという作戦がある．&lt;/p&gt;

&lt;h2 id=&#34;podcasts-by-me&#34;&gt;Podcasts by me&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/83/&#34;&gt;Rebuild: 83: Living In A Container&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2015年の最大のイベントは&lt;a href=&#34;http://rebuild.fm/&#34;&gt;rebuild.fm&lt;/a&gt;に出演したことだと思う．普段やっているプレゼンとは勝手が違いとにかく喋るのは難しかった（NaoyaさんにPodcastでうまく喋る方法をブログに書いてもらいたい）．2016年は自分でもPodcastを始めてみたいという妄想はしている．そういうので喋りを鍛えたい．&lt;/p&gt;

&lt;h2 id=&#34;papers-read&#34;&gt;Papers read&lt;/h2&gt;

&lt;p&gt;今年読んだ論文．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sites.computer.org/debull/A12june/pipeline.pdf&#34;&gt;Building LinkedIn&amp;rsquo;s Real-time Activity Data Pipeline&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ざっと目を通すのはいくつもあったがちゃんと読み込んだのは1本（これをまとめたのが&lt;a href=&#34;http://deeeet.com/writing/2015/09/01/apache-kafka/&#34;&gt;&amp;ldquo;Apache Kafkaに入門した&amp;rdquo;&lt;/a&gt;）．来年はもっと論文のインプットを増やしたい．とりあえず抑えるべき会議を抑え，読む習慣をつけたい．&lt;/p&gt;

&lt;h2 id=&#34;books-read&#34;&gt;Books read&lt;/h2&gt;

&lt;p&gt;今年読んだ本で良かったものをランキングで．&lt;/p&gt;

&lt;h3 id=&#34;tech&#34;&gt;Tech&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B0184N7WWS&#34;&gt;The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4254127057&#34;&gt;オペレーティングシステムの仕組み&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4797382228&#34;&gt;暗号技術入門 第3版 秘密の国のアリス&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;non-tech&#34;&gt;Non-tech&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/425500613X&#34;&gt;暇と退屈の倫理学&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4403120245&#34;&gt;スクリプトドクターの脚本教室・初級篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4576151142&#34;&gt;１４歳からの哲学入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4884184432&#34;&gt;職業としての小説家&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4344026241&#34;&gt;僕がコントや演劇のために考えていること&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;とにかく読書量が少なかった．2016年はアウトプットよりもインプットを重視したい．&lt;/p&gt;

&lt;h2 id=&#34;music&#34;&gt;Music&lt;/h2&gt;

&lt;p&gt;今年好きだった音楽をランキングで．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Oneohtrix Point Never - &lt;a href=&#34;https://www.youtube.com/watch?v=jt5tRaV3iY0&#34;&gt;&amp;ldquo;Garden of Delete&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Swindle - &lt;a href=&#34;http://peaceloveandmusic.info/&#34;&gt;&amp;ldquo;Peace, Love &amp;amp; Music&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Slack - &lt;a href=&#34;https://www.youtube.com/watch?v=OD7s62BTy9M&#34;&gt;&amp;ldquo;My Space&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kamasi Washington - &lt;a href=&#34;https://www.youtube.com/watch?v=NtQRBzSN9Vw&#34;&gt;&amp;ldquo;The Epic&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jam City - &lt;a href=&#34;https://www.youtube.com/watch?v=CiFbb6Waj_A&#34;&gt;&amp;ldquo;Dream A Garden&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Floating Points - &lt;a href=&#34;https://www.youtube.com/watch?v=5ntcVE3AQsg&#34;&gt;&amp;ldquo;Elaenia&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clap! Clap! - &lt;a href=&#34;https://www.youtube.com/watch?v=5etsDAlRTdg&#34;&gt;&amp;ldquo;Simple&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Battles - &lt;a href=&#34;https://www.youtube.com/watch?v=bkhLzHuUYmo&#34;&gt;&amp;ldquo;La Di Da Di&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jamie xx - &lt;a href=&#34;https://www.youtube.com/watch?v=TP9luRtEqjc&#34;&gt;&amp;ldquo;In Colour&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kitty, Daisy &amp;amp; Lewvis - &lt;a href=&#34;https://www.youtube.com/watch?v=9ASLWuIPXGc&#34;&gt;&amp;ldquo;The third&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;過去&#34;&gt;過去&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/12/31/music-2014/&#34;&gt;Best Music 2014&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2013/12/31/music-2013/&#34;&gt;Best Music 2013&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2012/12/31/music-2012/&#34;&gt;Best Music 2012&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;movie&#34;&gt;Movie&lt;/h2&gt;

&lt;p&gt;今年観て好きだった映画をランキングで．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;George Miller - &lt;a href=&#34;http://www.madmaxmovie.com/&#34;&gt;&amp;ldquo;MAD MAX: FURY ROAD&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;是枝裕和 - &lt;a href=&#34;http://umimachi.gaga.ne.jp/&#34;&gt;&amp;ldquo;海街diary&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Paul Thomas Anderson - &lt;a href=&#34;http://wwws.warnerbros.co.jp/inherent-vice/&#34;&gt;&amp;ldquo;Inherent Vice&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dan Gilroy - &lt;a href=&#34;http://nightcrawler.gaga.ne.jp/&#34;&gt;&amp;ldquo;Nightcrawler&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;J.J. Abrams - &lt;a href=&#34;http://www.starwars.com/the-force-awakens/&#34;&gt;&amp;ldquo;Star Wars: The Force Awakens&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Go言語でファジング</title>
      <link>http://deeeet.com/writing/2015/12/21/go-fuzz/</link>
      <pubDate>Mon, 21 Dec 2015 00:25:30 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/12/21/go-fuzz/</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/go&#34;&gt;Go Advent Calendar 2015&lt;/a&gt;の21日目の記事です．&lt;/p&gt;

&lt;p&gt;今年もGoコミュニティーから多くのツールが登場した．その中でも異彩を放っていたのがGoogleのDynamic testing toolsチームの&lt;a href=&#34;https://twitter.com/dvyukov&#34;&gt;@dvyukov&lt;/a&gt;氏による&lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;go-fuzz&lt;/a&gt;である．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go-fuzz&lt;/code&gt;はGo関数のファジングを行うツールである．このツールはとても強力で標準パッケージで100以上，&lt;a href=&#34;golang.org/x/&#34;&gt;golang.org/x/&lt;/a&gt;パッケージで40以上，その他を含めると300以上のバグを発見するという実績を残している（cf. &lt;a href=&#34;https://github.com/dvyukov/go-fuzz#trophies&#34;&gt;Trophies&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;本記事ではこの&lt;code&gt;go-fuzz&lt;/code&gt;の紹介を行う．&lt;/p&gt;

&lt;h2 id=&#34;ファジングとは&#34;&gt;ファジングとは?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fuzz_testing&#34;&gt;Fuzz testing - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/dev/feature/01/fuzzing&#34;&gt;ソフトウェアの脆弱性検出におけるファジングの活用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;「ファジング」とはソフトウェアのテスト手法である．テスト対象となるソフトウェアにランダムなデータを大量に入力し意図しない挙動を検出する．&lt;/p&gt;

&lt;p&gt;普通のソフトウェアは予期しないデータを受けても適切な処理，例えばエラーを返すなど，を行う．そしてそれはテストされる．しかし予期しない入力をすべてテストすることは難しい．適切に処理しているつもりであっても予期しないデータによりソフトウェアがクラッシュしてしまうことはありうる．このようなテストでファジングは光る．大量のランダムデータを入力し予期しないクラッシュを見つける．&lt;/p&gt;

&lt;p&gt;ファジングの利点に以下が挙げられる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;チープである&lt;/li&gt;
&lt;li&gt;バイアスがない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まずファジングは単純にランダムなデータを放り込むだけなので非常にチープな手法である．使うだけなら特別な知識は必要ない．次にランダムであるためテスターのバイアスがない．そのソフトウェアをつくっているひとほど思い込みが強くなってしまう（と思う）が，そのようなバイアスを排除することができる．&lt;/p&gt;

&lt;p&gt;ファジングで入力となるデータは「ファズ」と呼ばれる．コマンドラインツールであれば引数や環境変数，ウェブサーバーであればHTTPリクエストである．ファジングではこのファズをいかに生成するのかが重要になる．完全にランダムにする，指定の範囲内で連続に値を変化させる，正常なデータの一部を変更させる．ある特定の制御文字列を対象にするといった手法がある．&lt;/p&gt;

&lt;h2 id=&#34;go-fuzzとは&#34;&gt;go-fuzzとは?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;dvyukov/go-fuzz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=a9xrxRsIbSU&#34;&gt;GopherCon 2015: Dmitry Vyukov - Go Dynamic Tools&lt;/a&gt; (&lt;a href=&#34;https://talks.golang.org/2015/dynamic-tools.slide#1&#34;&gt;Slide&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go言語の関数に対してファジングを行うために開発されたのが&lt;code&gt;go-fuzz&lt;/code&gt;である．&lt;code&gt;go-fuzz&lt;/code&gt;はC/C++の&lt;a href=&#34;http://lcamtuf.coredump.cx/afl/&#34;&gt;afl-fuzz&lt;/a&gt;がベースになっている．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go-fuzz&lt;/code&gt;は完全にランダムなデータを入力するのではなく，正常なデータの一部を変更させランダムなデータを生成する．これにより単純にランダムな値で盲目的にテストをするのではなく，ある程度「ありそうな」データでテストを行うことができる．このためのデータセットをcorpusと呼び，&lt;code&gt;go-fuzz&lt;/code&gt;はテストを繰り返しながらこのcorpusを成長させていく．&lt;/p&gt;

&lt;p&gt;corpusはどのように成長するのか? &lt;code&gt;go-fuzz&lt;/code&gt;は&lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;AST&lt;/a&gt;を使い対象関数のテストのカバレッジ情報を取得する．カバレッジを上げるような入力が得られればそれをcorpusに登録する．これによりテストはより網羅的になる．&lt;/p&gt;

&lt;p&gt;corpusは事前に与えることもできる．例えば対象とする関数の入力が画像データである場合は事前に幾つかの画像データを与えることができる．もしくはユニットテストなどで既にテストしている値を使うこともできる．&lt;/p&gt;

&lt;p&gt;入力を繰り返し意図しない挙動が得られる（例えばpanicが起こる）と&lt;code&gt;go-fuzz&lt;/code&gt;はそれを引き起こした入力とスタックトレースをファイルとして保存する．開発者はその結果をもとに新たにユニットテストを追加しコードを修正していく．&lt;/p&gt;

&lt;h3 id=&#34;使いかた&#34;&gt;使いかた&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go-fuzz&lt;/code&gt;によるファジングには以下の2つが必要である&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fuzz()&lt;/code&gt;関数の準備&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go-fuzz-buid&lt;/code&gt;と&lt;code&gt;go-fuzz&lt;/code&gt;の実行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まず&lt;code&gt;Fuzz()&lt;/code&gt;関数は以下のような関数である．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Fuzz(data []byte) int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;data&lt;/code&gt;は&lt;code&gt;go-fuzz&lt;/code&gt;によって与えられるランダムな値である（ほとんどはinvalidな値である）．そしてこの値をテストしたい関数に入力として与える．&lt;code&gt;go-fuzz&lt;/code&gt;はこの入力で関数が&lt;code&gt;panic&lt;/code&gt;したりクラッシュしたり，メモリを割り当てすぎてhangしないかを監視する．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Fuzz()&lt;/code&gt;の返り値はcorpusの作成に使われる．以下の3つの値のうちどれかを返す．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt;- 入力がふさわしいデータであると考えられる場合（例えば関数がエラーを返さずに正常に処理された場合その入力はその関数にとってふさわしい入力であると考えることができる．ここから新たなランダムな値を生成すれば新たなエラーを発見できる可能性が高い）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-1&lt;/code&gt; - 入力がカバレッジを上げるようなふさわしい入力であると考えられてもcorpusには追加したくない場合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; - 上記以外の場合（例えばエラーが返った場合）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;関数が書けたら以下で専用のバイナリをつくる．&lt;code&gt;zip&lt;/code&gt;形式で出力される．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-fuzz-build pkg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして以下でテストを実行する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-fuzz -bin=pkg_fuzz.zip -workdir=dir 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-bin&lt;/code&gt;に上で生成したバイナリを指定する．テストは止めるまで無限に実行される．corpusやテストの結果は&lt;code&gt;-workdir&lt;/code&gt;で指定するディレクトリに出力される．例えばプログラムをクラッシュさせるような入力が得られた場合は&lt;code&gt;crashers/&lt;/code&gt;ディレクトリ内にその値とスタックトレースがファイルとして出力される．&lt;/p&gt;

&lt;p&gt;ちなみに作成されたcorpusはバージョン管理システムに保存するべきである．そうすれば他の人もそれを再利用することができる．&lt;/p&gt;

&lt;h2 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h2&gt;

&lt;p&gt;言葉だけでは分かり難いので実際に使ってみる．例えば以下のような関数をテストしてみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func CoolFunc(str string) error {

if len(str) &amp;lt; 1 {
    return fmt.Errorf(&amp;quot;Input must not be empty&amp;quot;)
}

if str[0] != &#39;A&#39; {
    return fmt.Errorf(&amp;quot;Input must start with A&amp;quot;)
}

// Super cool processing.

// Bug hard to find !
if str == &amp;quot;ABCD&amp;quot; {
    panic(&amp;quot;input must not be ABCD&amp;quot;)
}

return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この関数は文字列を受け取ってめちゃめちゃクールな処理を行う．長さ0の文字列の入力は許容しない．また&lt;code&gt;A&lt;/code&gt;で始まる文字列ではエラーが発生することまではわかっていおり適切にハンドルがされている．そして&lt;code&gt;ABCD&lt;/code&gt;という値が入力されたときのみなぜか関数がクラッシュするというバグが混入しているとする．以下ではこのバグをファジングで発見する（当たり前だが普通はそもそもこのようなバグがあることは事前にわからない）．&lt;/p&gt;

&lt;p&gt;まず&lt;code&gt;Fuzz()&lt;/code&gt;は以下のようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// +build gofuzz

func Fuzz(data []byte) int {
    if err := CoolFunc(string(data)); err != nil {
        return 0
    }
    return 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーのときはすでにそれは適切にハンドルされているので&lt;code&gt;0&lt;/code&gt;を返す．正常に動作した場合は&lt;code&gt;1&lt;/code&gt;を返してcorpusの生成に利用するようにする．&lt;/p&gt;

&lt;p&gt;ビルドしてファジングを実行する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-fuzz-build github.com/tcnksm-sample/go-fuzz
$ go-fuzz -bin=pkg-fuzz.zip -workdir=workdir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行すると以下のような出力が得られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2015/12/20 21:23:54 slaves: 4, corpus: 3 (2s ago), crashers: 1, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;crashers:　1&lt;/code&gt;とあり関数をクラッシュさせるような入力が得られたことがわかる．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;workdir/crashers&lt;/code&gt;をみると以下のようなファイルが生成されている．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;workdir/crashers
├── fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6
├── fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6.output
└── fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6.quoted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず拡張子がないファイルは具体的に関数をクラッシュさせた入力が含まれている（&lt;code&gt;.quoted&lt;/code&gt;はその入力を&amp;rdquo;&amp;ldquo;で囲ったもの）．この場合は&lt;code&gt;ABCD&lt;/code&gt;が得られる．そして&lt;code&gt;.output&lt;/code&gt;ファイルにはその際のスタックトレースが出力される．今回は以下のような出力が得られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat workdir/crashers/fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6.output
panic: input must not be ABCD

goroutine 1 [running]:
github.com/tcnksm-sample/go-fuzz.CoolFunc(0x820267e78, 0x4, 0x0, 0x0)
....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クラッシュが得られたどうするか? まずユニットテストにその入力を追加する．そしてコードを修正し適切にハンドルされるようにする．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;自分のつくっているいくつかのツールでも試してみたが残念ながら面白いバグを発見することはできなかった（特に複雑なことをしていないというものあるが..）．&lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/go-fuzz/&#34;&gt;ユーザの入力を受けるソフトウェアはすべてファジングするべき&lt;/a&gt;という意見もある．会社で書いているソフトウェアにもファジングを導入していきたいと思う．ファジングはとにかく簡単なので導入は容易だと思う．&lt;/p&gt;

&lt;p&gt;OSSのツールに対してファジングでバグを発見してコミットを行う実践的な方法は&lt;a href=&#34;https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c#.2s399y3sg&#34;&gt;&amp;ldquo;go-fuzz github.com/arolek/ase&amp;rdquo;&lt;/a&gt;が詳しい．&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;dvyukov/go-fuzz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fuzz_testing&#34;&gt;Fuzz testing - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/dev/feature/01/fuzzing&#34;&gt;ソフトウェアの脆弱性検出におけるファジングの活用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=a9xrxRsIbSU&#34;&gt;GopherCon 2015: Dmitry Vyukov - Go Dynamic Tools&lt;/a&gt; (&lt;a href=&#34;https://talks.golang.org/2015/dynamic-tools.slide#1&#34;&gt;Slide&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lcamtuf.coredump.cx/afl/&#34;&gt;american fuzzy lop (1.96b)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.cloudflare.com/dns-parser-meet-go-fuzzer/&#34;&gt;DNS parser, meet Go fuzzer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/filosottile/automated-testing-with-go-fuzz&#34;&gt;Automated Testing with go-fuzz // Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c#.2s399y3sg&#34;&gt;go-fuzz github.com/arolek/ase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/go-fuzz/&#34;&gt;Go Fuzz&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>自宅で美味いコーヒーを淹れる</title>
      <link>http://deeeet.com/writing/2015/12/17/coffee-2015/</link>
      <pubDate>Thu, 17 Dec 2015 00:35:03 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/12/17/coffee-2015/</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://www.adventar.org/calendars/895&#34;&gt;コーヒー Advent Calendar 2015&lt;/a&gt;の17日目の記事です．&lt;/p&gt;

&lt;p&gt;コーヒーを淹れること，豆を買いに行くこと，コーヒー器具を集めること，コーヒー関連の本を読むことが好きだ．コーヒーは趣味といっても過言でなない．自宅で美味しいコーヒーを淹れるために今までいろいろ試行錯誤してきたが，最近ある程度固まってきたのでその環境についてまとめてみる．&lt;/p&gt;

&lt;h2 id=&#34;過去&#34;&gt;過去&lt;/h2&gt;

&lt;p&gt;最初に自分とコーヒーとの馴れ初めをつらつらと．&lt;/p&gt;

&lt;p&gt;親がコーヒー好きなので実家では当たり前のように毎日コーヒーが淹れられていた．そのため家で自分でコーヒーを淹れて飲むのは当たり前のものとして育った．実家ではドリップマシンが使われていた．特にこだわりはなく出されるものをそのまま飲んでいたと思う．&lt;/p&gt;

&lt;p&gt;自分でコーヒーを淹れるようになったのは大学生で一人暮らしを始めてから．最初は実家にあった使われていないドリッパー（確か&lt;a href=&#34;http://www.hario.com/&#34;&gt;HARIO&lt;/a&gt;）と近所のスーパーの安い豆でドリップを始めた．見よう見まねでなんとなくやっていたと思う．大学生にもなるとカフェなどでまともなコーヒーを飲むようになり，自分で淹れるコーヒーがあまり美味しくないと感じ始めた．&lt;/p&gt;

&lt;p&gt;どうやら自分で豆を挽くと美味いということを聞きつけ&lt;a href=&#34;http://www.amazon.co.jp/dp/B0002JZCF2&#34;&gt;ポーレックスのコーヒーミル&lt;/a&gt;を買い，近所の&lt;a href=&#34;http://kaldi-online.com/&#34;&gt;KALDI&lt;/a&gt;で豆を買い，手挽きによる豆とドリップを始めた．&lt;/p&gt;

&lt;p&gt;こうなってくると良いドリッパーも欲しくなる．いろいろ探して&lt;a href=&#34;http://www.chemexcoffeemaker.com/&#34;&gt;Chemex&lt;/a&gt;を買った．Chemexは未だに使っているので5年以上の付き合いになる（よくおしゃれインテリア的な感じで使ってるやついるけどああいうやつはフィルターが買えなくなって最終的に花瓶として使い始める．映画&lt;a href=&#34;http://wwws.warnerbros.co.jp/interstellar/&#34;&gt;&amp;ldquo;インターステラー&amp;rdquo;&lt;/a&gt;では水飲み用のデキャンタとして使われていて映画の評価に響いた）．&lt;/p&gt;

&lt;p&gt;手挽きはとにかく失敗した．特にグラインドが粗すぎて青臭くなってしまうことが多かった．また手挽きは時間がかかるため平日は厳しくて週末しかできないとう問題があった．そのため在学中は平日はお店で挽いてもらった豆でドリップし，週末に手挽きでドリップをした．ドリップは自己流でやっていて日によってばらつきがあるもののある程度まともなものが淹れられるようにはなった&lt;/p&gt;

&lt;h2 id=&#34;現在&#34;&gt;現在&lt;/h2&gt;

&lt;p&gt;過去のコーヒー環境には以下の問題があった．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;手挽きをしていたため平日に自分で豆を挽くことができないこと&lt;/li&gt;
&lt;li&gt;自己流ドリップで同じ豆でも味が固定されないこと&lt;/li&gt;
&lt;li&gt;良質な豆を使っていないこと&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まず1つ目は社会人になり財力で解決した．必要なのは良質な電動グライダー．コーヒーは一生付き合うと思い&lt;a href=&#34;http://www.amazon.co.jp/dp/B000NJDT9M&#34;&gt;Kalitaのナイスカットミル&lt;/a&gt;を購入した．これは最高でグラインドは綺麗に均等になるしあらゆる淹れ方（ドリップ，エスプレッソ，フレンチプレス）にあったグラインドに簡単に調整できる．何より速い．忙しい朝でも新鮮な豆を挽くことができる．&lt;/p&gt;

&lt;p&gt;2つ目の再現性の問題．これは本を読み，またサードウェーブの流れに触れることで多くを学び解決した．これについては以下で詳しく書く．&lt;/p&gt;

&lt;p&gt;3つ目の問題はそもそも問題と認識できていなかった．これもサードウェーブの文化に触れることで学んだ．東京にもサードウェーブの流れを汲んだカフェはたくさんある（cf. &lt;a href=&#34;http://deeeet.com/writing/2014/01/21/third-wave-tokyo/&#34;&gt;東京サードウェーブコーヒー&lt;/a&gt;）．KALDIの豆は今でも買う（特にリッチブレンドが大好き）が時間があればロースターに行き新鮮な豆を買うようになった．サードウェーブの原点であるオークランドが対岸にあるサンフランシスコを訪れたときは時間があればロースターに行き，コーヒーを飲み，豆を買うなどした（cf. &lt;a href=&#34;http://deeeet.com/writing/2015/06/07/sf-coffee/&#34;&gt;サンフランシスコでたくさんコーヒー飲んだ&lt;/a&gt;）．&lt;/p&gt;

&lt;h3 id=&#34;良い豆&#34;&gt;良い豆?&lt;/h3&gt;

&lt;p&gt;ちょっと脱線するが，良い豆って何? あるいはサードウェーブと今までの豆の違いって何? という話を．&lt;/p&gt;

&lt;p&gt;昔ながらのコーヒーに深煎りのものが多い．それは昔は豆が熟度など不完全なものしか入ってこなくてその欠点を焙煎で消そうとしていたため．&lt;/p&gt;

&lt;p&gt;近年はクオリティの高い豆が流通するようになった．特にサードウェーブってのは豆そのもの味を楽しもうって流れで浅煎が多い．そして素材そのものを楽しむのをよしとする．同じ農園の豆の味でも年ごとに違うし，同じ品種でもテロワール（生産地の地理/地勢/気候/土壌などの特徴）で異なってくる．今まではそれを隠そうとしたが，今はそれを楽しもうとしている．&lt;/p&gt;

&lt;p&gt;農家に対する配慮に関してもよく語られる．これはコーヒーの美味しさは実が果実として完熟しているかどうかで決まるため．かつそれは木になっているときにしか判断できないから．良好な関係を築くことでより良い栽培/収穫方法のループを回せるようにする．スタバとかが批判されるのは同じ味を世界中で実現するために農家無視で大量生産してるから．&lt;/p&gt;

&lt;p&gt;もちろん今でも昔ながらの深煎りも好きで全然飲むけど．&lt;/p&gt;

&lt;p&gt;以下では最近はどのような器具を使っているのか? 再現性を高めるにはどうしているのか? などについて書く．&lt;/p&gt;

&lt;h2 id=&#34;器具&#34;&gt;器具&lt;/h2&gt;

&lt;p&gt;もともとドリップ至上主義でコーヒーはドリップ，ドリップ以外は認めない，ドリップ以外は飲むに値しないという過激な立場を取ってきた．しかし豆にはその豆にあった淹れ方があることを知り，今ではこの考えを改めていろいろな抽出方法を使うようになった（メインはドリップだが）．&lt;/p&gt;

&lt;p&gt;簡単に現在使っている器具を紹介する．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/coffee-set.JPG&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;左から順番に&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.chemexcoffeemaker.com/&#34;&gt;Chemex&lt;/a&gt; - Chemexを愛して5年．これからも使い続けると思う．Chemexは専用のフィルターが必要でそれによってChemexっぽい味が出る．KALDIの豆によく使う．最近は人に淹れることもあるので6カップの購入も考えている．&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dodrip.net/detail.html&#34;&gt;Donuts Dripper&lt;/a&gt; - Chemex以外のドリップもしようと2年ほど前に購入．しっかり濃いのに重くないスッキリした飲み心地になるようにデザインされており実際そんな感じになる．市販の安いフィルターが使えるもの良い．&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B0000AN3QI&#34;&gt;BIALETTI モカポット&lt;/a&gt; - エスプレッソマシンなど買えない．圧力はマシンに及ばないがそれに近しいものは淹れることができる．ど濃いコーヒーを飲みたい時に良い．イタリアにはどの家庭にもあるらしい．&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aerobie.com/product/aeropress/&#34;&gt;AeroPress&lt;/a&gt; - 素早く淹れられて洗うのも簡単．使い方次第でいろいろな淹れ方ができて面白い（大会もあるとか）．これは買ったばかりでまだうまく使えていないのでこれからもっとうまくなりたい．&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B0092UDYLQ&#34;&gt;HARIO フレンチプレス&lt;/a&gt; - なかなか難しいが面白い味のコーヒーを作れる．友人からプレゼントしてもらった．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ちなみにカップは&lt;a href=&#34;http://fourbarrelcoffee.com/&#34;&gt;Four Barrel Coffee&lt;/a&gt;のもの．ここで飲んだコーヒーが今まで飲んだなかで一番美味しかった．&lt;/p&gt;

&lt;h2 id=&#34;再現性&#34;&gt;再現性&lt;/h2&gt;

&lt;p&gt;過去の自分のコーヒーの淹れ方には同じ豆を使っているのに再現性がないという問題があった．それもそもはずで計測などしないで感覚でやっていたのが原因．再現性への回答は計測すること．&lt;/p&gt;

&lt;p&gt;抽出の味のファクターは豆の量，グラインドの細かさ，抽出時間，お湯の量，お湯の温度である．&lt;a href=&#34;http://www.amazon.co.jp/dp/B009GPJMOU&#34;&gt;HARIOのドリップスケール&lt;/a&gt;にははかりとタイマーが付いている．これは最高のツールで豆の量とお湯の量，抽出時間を計測しながらコーヒーを抽出することができる．これを導入したことで再現性は飛躍的に高まった．&lt;/p&gt;

&lt;p&gt;使い方を簡単に説明する．まず以下のように豆の量を測る．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/coffee-beans.JPG&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;次に抽出．以下はChemexを使った例．抽出しながら，時間とお湯の量を測ることができる（温度計は別途購入した）．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/coffee-brew1.JPG&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/coffee-brew2.JPG&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;豆の量や抽出時間はどこから知るのか? サードウェーブ系のロースターでは豆を買う時に聞けば大抵どこでも教えてくれる．場所によっては豆のグラインドのサンプルもくれる．簡単な説明書みたなのを準備してるところもある．新鮮な豆とそれを淹れるためのレシピを聞けば自宅でそれを再現することは容易い（しかもロースターで飲むと1杯500円くらいする．豆は100gあたり800円-1000円の価格帯になる．1杯あたりは10-15gの豆を使うので自分で淹れれば1杯100-150円程度になる．つまり自分で淹れたほうが断然良い）．&lt;/p&gt;

&lt;p&gt;この手法でドリップであれば5分程度で最高の味を再現できるようになった．&lt;/p&gt;

&lt;h2 id=&#34;課題&#34;&gt;課題&lt;/h2&gt;

&lt;p&gt;だいぶ良い感じに美味しいコーヒーを淹れることができるようになったが，まだまだ課題がある．&lt;/p&gt;

&lt;h3 id=&#34;言語&#34;&gt;言語&lt;/h3&gt;

&lt;p&gt;まだうまく豆を買えない．とにかく味の表現が複雑すぎる．昔ながらの苦味/酸味だけではなくなっている．例えば&lt;a href=&#34;http://www.allianceforcoffeeexcellence.org/en/&#34;&gt;Cup of excellence&lt;/a&gt;の評価項目にはSweetness，Acidity，Mouth Feel，Flavour，Aftertasteがある．店に行ってもダークチェリーだのオレンジだのチョコレートだのたくさんの表現が並んでいて混乱する．&lt;/p&gt;

&lt;p&gt;これは新しいプログラミング言語を学ぶときに大変なのと同じかなと思う．新しい言語は宇宙語に感じてしまう．とにかく量をこなして身につけていくしかない．&lt;/p&gt;

&lt;h3 id=&#34;場所&#34;&gt;場所&lt;/h3&gt;

&lt;p&gt;今は自宅でしかちゃんとしたものを淹れることができない．&lt;a href=&#34;https://david-smith.org/blog/2014/05/22/my-travel-coffee-kit/&#34;&gt;My Travel Coffee Kit&lt;/a&gt;にあるように出張先でも最高のコーヒーを淹れられるようになりたい．&lt;/p&gt;

&lt;h2 id=&#34;書籍&#34;&gt;書籍&lt;/h2&gt;

&lt;p&gt;最後に面白かった書籍をいくつか．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B00CQW6XLK&#34;&gt;サードウェーブ！：サンフランシスコ周辺で体験した最新コーヒーカルチャー&lt;/a&gt; - サードウェーブ系の文化を学ぶ入り口としてとても良い．&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4388251143&#34;&gt;コーヒー「こつ」の科学 - コーヒーを正しく知るため&lt;/a&gt; - コーヒーの基礎知識を科学的な視点から説明している書籍（例えば酸味成分と苦味成分がどのように抽出されるのか，それはなぜかを知れたりする）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp//dp/483872540X&#34;&gt;美味しいコーヒーって何だ?&lt;/a&gt; - ロースターたちが最近のサードウェーブの流れを含めて焙煎についてあれこれ語る本．特に鹿児島のVOILAの井ノ上達也さんの話はとても面白い．昔のコーヒーの問題と今の状況がすごくクリアになった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fuglentyo.thebase.in/items/2027086&#34;&gt;COFFEE WITH TIM WENDELBOE&lt;/a&gt; - バリスタチャンピオンによる自宅での美味しいコーヒーの淹れ方．一番今っぽい淹れ方を丁寧に書いている本だと思う．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;https://bluebottlecoffee.com/store/blue-bottle-craft-of-coffee&#34;&gt;Blue Bottle本&lt;/a&gt;は読まないといけないなあと思いつつ積んでいる．年末年始にでも読もうと思う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go言語でLet&#39;s EncryptのACMEを理解する</title>
      <link>http://deeeet.com/writing/2015/12/01/go-letsencrypt-acme/</link>
      <pubDate>Tue, 01 Dec 2015 23:18:42 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/12/01/go-letsencrypt-acme/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://letsencrypt.org/&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s EncryptのベースのプロトコルであるACMEを理解する．&lt;/p&gt;

&lt;p&gt;まずACMEをベースとしたCAである&lt;a href=&#34;https://github.com/letsencrypt/boulder/&#34;&gt;boulder&lt;/a&gt;をローカルで動かす．次にACMEのGo言語クライアントライブラリである&lt;a href=&#34;https://github.com/ericchiang/letsencrypt&#34;&gt;ericchiang/letsencrypt&lt;/a&gt;（非公式）を使い実際にboulderと喋りながら証明書発行を行い，コードとともにACMEが具体的にどのようなものなのかを追う．&lt;/p&gt;

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;証明書というのは面倒なもの，少なくともカジュアルなものではない，というイメージが強い．それは有料であることや自動化しにくいなどといったことに起因している（と思う）．そのようなイメージに反して近年登場する最新の技術/プロトコルはTLSを前提にしているものが少なくない（e.g., HTTP2）．&lt;/p&gt;

&lt;p&gt;このような背景の中で登場したのがLet&amp;rsquo;s Encryptと呼ばれるCAである．Let&amp;rsquo;s Encryptは上で挙げたような問題（煩雑さ）を解決しようとしており，無料・自動・オープンを掲げている（cf. &lt;a href=&#34;http://jxck.hatenablog.com/entry/letsencrypt-acme&#34;&gt;&amp;ldquo;Let&amp;rsquo;s Encrypt を支える ACME プロトコル&amp;rdquo;&lt;/a&gt;）．最近（2015年12月3日）Public Betaが&lt;a href=&#34;https://letsencrypt.org/2015/12/03/entering-public-beta.html&#34;&gt;アナウンスされ&lt;/a&gt;すでに1日に70kの証明証が発行され始めており（cf. &lt;a href=&#34;https://letsencrypt.org/stats/&#34;&gt;Let&amp;rsquo;s Encrypt Stats&lt;/a&gt;）大きな期待が寄せられている．特に自分は仕事で多くのドメインを扱うのでLet&amp;rsquo;s Encryptは使ってくぞ！という意識がある．&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s EncryptはDV証明書を発行することができるCAである．DV証明書とはドメインの所有を確認して発行されるタイプの証明書である．Let&amp;rsquo;s Encryptの大きな特徴の1つに自動化が挙げられる．申請からドメインの所有の確認，証明書発行までは全てコマンドラインで完結させることができる．そしてこのフローはLet&amp;rsquo;s Encrypt以外のCAでも利用できるように&lt;a href=&#34;https://github.com/ietf-wg-acme/acme/&#34;&gt;標準化が進められている&lt;/a&gt;．これはAutomated Certificate Management Environment（ACME）プロトコルと呼ばれる（ちなみにLet&amp;rsquo;s encryptの証明証の有効期限は90日である．これはセキュリティ強化の面もあるが自動化の促進という面もある（cf. &lt;a href=&#34;https://letsencrypt.org/2015/11/09/why-90-days.html&#34;&gt;Why ninety-day lifetimes for certificates?&lt;/a&gt;））．&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s Encryptは専用のACMEクライアントを提供している（&lt;a href=&#34;https://github.com/letsencrypt/letsencrypt&#34;&gt;letsencrypt&lt;/a&gt;）．基本はこれを使えば証明書の発行や，Apacheやnginxの設定ファイルの書き換え(!)などができる（やりすぎ感が気にくわないと感じるひとが多いようでsimple alternativeがいくつか登場している&amp;hellip;）．&lt;/p&gt;

&lt;p&gt;それだけではなくACMEベースのCA（つまりLet&amp;rsquo;s encrypt）は&lt;a href=&#34;https://github.com/letsencrypt/boulder/&#34;&gt;Boulder&lt;/a&gt;とう名前でOSSベースで開発されている（Go言語で実装されている）．つまりBoulderを使えば誰でもACMEをサポートしたCAになることができる．&lt;/p&gt;

&lt;p&gt;本記事ではおそらく将来的には意識しないでよくなる（であろう）ACMEプロトコルがどのようなものかを理解する．boulderをローカルで動かし（&lt;code&gt;Dockerfile&lt;/code&gt;が提供されている），非公式であるがGo言語のACMEクライアント&lt;a href=&#34;https://github.com/ericchiang/letsencrypt&#34;&gt;ericchiang/letsencrypt&lt;/a&gt;を使ってACMEを喋ってみる．&lt;/p&gt;

&lt;p&gt;なおACMEはまだ仕様策定中なので以下の説明は変更される可能性がある．&lt;/p&gt;

&lt;h2 id=&#34;boulderを動かす&#34;&gt;boulderを動かす&lt;/h2&gt;

&lt;p&gt;まず準備としてboulderを動かす．今回は例として&lt;code&gt;example.org&lt;/code&gt;の証明証を発行する．ローカルでこれを実行するためには以下の準備が必要になる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cmd/policy-loader/base-rules.json&lt;/code&gt;のブラックリストから&lt;code&gt;example.org&lt;/code&gt;を外す&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/hosts&lt;/code&gt;を編集して&lt;code&gt;example.org&lt;/code&gt;を&lt;code&gt;127.0.0.1&lt;/code&gt;に向ける&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完了したらboulderコンテナを起動する．&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/letsencrypt/boulder/
$ ./test/run-docker.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;acmeの概要&#34;&gt;ACMEの概要&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ietf-wg-acme/acme/&#34;&gt;ACME spec draft&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ACMEとは「クライアントのドメインの所有を確認して証明書を発行する」ためのプロトコルであった．これをさらに細かくブレイクダウンすると以下の操作から構成される．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;各操作を行うためのURIを知る（directory）&lt;/li&gt;
&lt;li&gt;クライアントの登録を行う（new-registration）&lt;/li&gt;
&lt;li&gt;認証（ドメイン所有の確認）を行う（new-authorization）&lt;/li&gt;
&lt;li&gt;証明書（Certification）を発行する（new-certificate）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ACMEはこれらのリソースを持ったRESTアプリケーションであるとみなすこともできる．各リソースはその上のリソースに依存しており，上から順番にリクエストをこなしていくことで最後の証明書の発行に到達することになる．&lt;/p&gt;

&lt;p&gt;以下ではこれらのリソースをさらに細かく見ていく．&lt;/p&gt;

&lt;h2 id=&#34;directory&#34;&gt;directory&lt;/h2&gt;

&lt;p&gt;directoryは他の各種リソースのURIをクライアントに提示する．クライアントはまずここにリクエストしその後の操作でリクエストするべきendpointを知る．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ericchiang/letsencrypt&lt;/code&gt;を使うと以下のようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;client, err := letsencrypt.NewClient(&amp;quot;http://localhost:4000/directory&amp;quot;)
if err != nil {
    log.Fatal(err)
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NewClient&lt;/code&gt;はdirectoryにリクエストを投げ以下の操作で必要なendopointを保持した&lt;code&gt;client&lt;/code&gt;を作成する．&lt;/p&gt;

&lt;h2 id=&#34;new-registration&#34;&gt;new-registration&lt;/h2&gt;

&lt;p&gt;new-registrationはクライアントの登録を行う．具体的にはRSAもしくはECDSAの公開鍵を登録する．ここで登録した鍵は以後のすべてのリクエストで利用する．ここではRSAを利用する．以下で事前に生成しておく．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ssh-keygen -t rsa -b 4096 -C &amp;quot;tcnksm@mail.com&amp;quot; -f letsencrypt-test -N &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コードは以下のようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;client, err := letsencrypt.NewClient(&amp;quot;http://localhost:4000/directory&amp;quot;)
if err != nil {
    log.Fatal(err)
}

data, err := ioutil.ReadFile(&amp;quot;letsencrypt-test&amp;quot;)
if err != nil {
    log.Fatal(err)
}

block, _ := pem.Decode(data)
key, err := x509.ParsePKCS1PrivateKey(block.Bytes)
if err != nil {
    log.Fatal(err)
}

if _, err := client.NewRegistration(key); err != nil {
    log.Fatal(err)
}

log.Println(&amp;quot;Registered&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事前に生成した鍵ファイルを読み込みデコードして&lt;code&gt;NewRegistration&lt;/code&gt;を呼ぶ（cf. &lt;a href=&#34;http://deeeet.com/writing/2015/11/10/go-crypto/&#34;&gt;Go言語と暗号技術（AESからTLS）&lt;/a&gt;に書いた）．これで登録が完了する．&lt;/p&gt;

&lt;p&gt;この鍵はnew-registrationだけではなくこの後の各リクエストの署名とその検証にも利用される．具体的にはクライアントはリクエストするJSONをJWSという仕様に基づき署名する．そしてサーバーはリクエストを受けると処理を始める前にそのJWSによる署名の検証を行う．&lt;/p&gt;

&lt;p&gt;ちなみに公開鍵はどのようにサーバーに送られるのか? これにはJWKという仕様がありそれに基づき送信される（JWSやJWKといったJWxの技術に関しては&lt;a href=&#34;https://twitter.com/lestrrat&#34;&gt;@lestrrat&lt;/a&gt;さんのブログ記事&lt;a href=&#34;http://hde-advent-2015.hatenadiary.jp/entry/2015/12/02/095643&#34;&gt;&amp;ldquo;GoでOAuth2/OpenIDとJOSE (JWA/JWT/JWK/JWS/JWE)&amp;rdquo;&lt;/a&gt;が詳しい）．&lt;/p&gt;

&lt;h2 id=&#34;new-authorization&#34;&gt;new-authorization&lt;/h2&gt;

&lt;p&gt;new-authorizationではドメインの所有の確認を行い認証を行う．具体的にそのドメインの所有をどのように確認するのか? それにはドメインの所有者にしかできない特定の操作を行わせることで確認を行う．ACMEではこの操作を&lt;strong&gt;Challenge&lt;/strong&gt;と呼ぶ．&lt;/p&gt;

&lt;p&gt;現在（2015年12月）Challengeには&lt;code&gt;http-01&lt;/code&gt;や&lt;code&gt;tls-sni-01&lt;/code&gt;といったものがある．例えば&lt;code&gt;http-01&lt;/code&gt;はクライアントのサーバー上の特定のパスに指定された内容のテキストファイルを配置させ，そこにアクセスし予期するファイルが配置されているかで確認を行う．&lt;/p&gt;

&lt;p&gt;認証は以下のような流れで行われる．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;クライアントはnew-authorizationリソースにPOSTリクエストを送る（POSTリクエストのBodyにはJWSが含まれていなけばならない）&lt;/li&gt;
&lt;li&gt;サーバーは利用可能なChallengeとそのうち達成するべき組み合わせ（複数のChallengeの達成を要求することもできる）を返答する&lt;/li&gt;
&lt;li&gt;クライアントはChallengeに応える&lt;/li&gt;
&lt;li&gt;サーバーはChallengeの達成を確認する&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;コードで書くと以下のようになる．まずChallengeの取得を行う（&lt;code&gt;client&lt;/code&gt;の初期化と&lt;code&gt;key&lt;/code&gt;の読み込みは完了しているとする）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;auth, _, err := client.NewAuthorization(key, &amp;quot;dns&amp;quot;, &amp;quot;example.org&amp;quot;)
if err != nil {
    log.Fatal(err)
}

log.Println(&amp;quot;[INFO] Challenges:&amp;quot;)
for _, challenge := range auth.Challenges {
    log.Println(&amp;quot;  &amp;quot;, challenge.Type, challenge.URI)
}

var combs string
for _, comb := range auth.Combs {
    combs += fmt.Sprintf(&amp;quot;%v &amp;quot;, comb)
}
log.Println(&amp;quot;[INFO] Combinations:&amp;quot;, combs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを実行すると以下のような結果が得られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2015/12/05 17:16:44 [INFO] Challenges:
  dns-01 http://127.0.0.1:4000/acme/challenge/FQ01uZjCoY13Z5Jak7..
  tls-sni-01 http://127.0.0.1:4000/acme/challenge/FQ01uZjCoY13Z5..
  dvsni http://127.0.0.1:4000/acme/challenge/FQ01uZjCoY13Z5Jak7H..
  http-01 http://127.0.0.1:4000/acme/challenge/FQ01uZjCoY13Z5Jak..
  simpleHttp http://127.0.0.1:4000/acme/challenge/FQ01uZjCoY13Z5..
  
2015/12/05 17:16:44 [INFO] Combinations: [0] [1] [2] [3] [4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在の&lt;code&gt;boulder&lt;/code&gt;のdevモードは4つのChallengeを返す（&lt;code&gt;simpleHttp&lt;/code&gt;と&lt;code&gt;dvsni&lt;/code&gt;はdeprecatedなので無視してもよい &lt;a href=&#34;https://github.com/letsencrypt/acme-spec/issues/231&#34;&gt;#231&lt;/a&gt;）．&lt;code&gt;challenge.URI&lt;/code&gt;は具体的なChallengeに必要となる情報（例えば&lt;code&gt;http-01&lt;/code&gt;の場合はサーバーにアクセスさせるためのパスとそこに配置するリソース）を取得するためのendpointである．そして組み合わせ（&lt;code&gt;Combs&lt;/code&gt;）は指定されておらずどれか1つでも達成すればよい．&lt;/p&gt;

&lt;p&gt;次に実際にChallengeを達成する．ここでは&lt;code&gt;http-01&lt;/code&gt;を達成する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;auth, _, err := client.NewAuthorization(key, &amp;quot;dns&amp;quot;, &amp;quot;example.org&amp;quot;)
if err != nil {
    log.Fatal(err)
}

var httpChallengeURI string
for _, challenge := range auth.Challenges {
    if challenge.Type == &amp;quot;http-01&amp;quot; {
        log.Println(&amp;quot;[INFO]&amp;quot;, challenge.Type, challenge.URI)
        httpChallengeURI = challenge.URI
    }
}

if httpChallengeURI == &amp;quot;&amp;quot; {
    log.Fatal(&amp;quot;httpChallengeURI should not be empty&amp;quot;)
}

challenge, err := client.Challenge(httpChallengeURI)
if err != nil {
    log.Fatal(err)
}

b, err := json.MarshalIndent(&amp;amp;challenge, &amp;quot;&amp;quot;, &amp;quot;  &amp;quot;)
if err != nil {
    log.Fatal(err)
}
log.Println(&amp;quot;[INFO]&amp;quot;, string(b))

path, resource, err := challenge.HTTP(key)
if err != nil {
    log.Fatal(err)
}

go func() {
    http.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {
        io.WriteString(w, resource)
    })

    // The test Let&#39;s Encrypt server uses port 5002 instead of 80.
    if err := http.ListenAndServe(&amp;quot;:5002&amp;quot;, nil); err != nil {
        log.Fatal(err)
    }
}()

if err := client.ChallengeReady(key, challenge); err != nil {
    log.Fatal(err)
}

log.Println(&amp;quot;[INFO] Complete challenge!&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下のようなことをしている．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;サーバーが受け付け可能なChallengeをリクエストする（&lt;code&gt;NewAuthorization&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http-01&lt;/code&gt;を選択し具体的なアクションのために必要となる情報をリクエストする（&lt;code&gt;Challenge&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;上のレスポンスから&lt;code&gt;http-01&lt;/code&gt;に必要なサーバーからリクエストされる&lt;code&gt;path&lt;/code&gt;とその&lt;code&gt;resource&lt;/code&gt;を取得する（&lt;code&gt;HTTP&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt;にて&lt;code&gt;resource&lt;/code&gt;をserveするようにサーバーを起動する（goroutine）&lt;/li&gt;
&lt;li&gt;Challgenが準備できたことをサーバーに伝えValidateしてもらう（&lt;code&gt;ChallengeReady&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これで認証は完了する．あとは&lt;code&gt;csr&lt;/code&gt;を送れば証明書を取得することができる．&lt;/p&gt;

&lt;h2 id=&#34;new-certification&#34;&gt;new-certification&lt;/h2&gt;

&lt;p&gt;new-certificationは新しい証明書の発行を行う．&lt;/p&gt;

&lt;p&gt;まず&lt;code&gt;.csr&lt;/code&gt;ファイルを作成する．&lt;code&gt;.csr&lt;/code&gt;の作成は&lt;code&gt;openssl&lt;/code&gt;コマンドなどでも可能だがここではGo言語で作成する．Go言語で証明書を操作するには&lt;code&gt;x509&lt;/code&gt;パッケージを使えばよい（詳しくは&lt;a href=&#34;http://deeeet.com/writing/2015/11/10/go-crypto/&#34;&gt;Go言語と暗号技術（AESからTLS）&lt;/a&gt;）．コードは以下．RSAを使う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;certKey, err := rsa.GenerateKey(rand.Reader, 2048)
if err != nil {
    log.Fatal(err)
}

template := x509.CertificateRequest{
    SignatureAlgorithm: x509.SHA256WithRSA,
    PublicKeyAlgorithm: x509.RSA,
    PublicKey:          &amp;amp;certKey.PublicKey,
    Subject:            pkix.Name{CommonName: &amp;quot;example.org&amp;quot;},
    DNSNames:           []string{&amp;quot;example.org&amp;quot;},
}

if err != nil {
    log.Fatal(err)
}

csrOut, err := os.Create(&amp;quot;example.org.csr&amp;quot;)
if err != nil {
    log.Fatal(err)
}
defer csrOut.Close()

if err := pem.Encode(csrOut, &amp;amp;pem.Block{
    Type:  &amp;quot;CERTIFICATE REQUEST&amp;quot;,
    Bytes: csrDerByte,
}); err != nil {
    log.Fatal(err)
}

keyOut, err := os.Create(&amp;quot;example.org.key&amp;quot;)
if err != nil {
    log.Fatal(err)
}

if err := pem.Encode(keyOut, &amp;amp;pem.Block{
    Type:  &amp;quot;RSA PRIVATE KEY&amp;quot;,
    Bytes: x509.MarshalPKCS1PrivateKey(certKey),
}); err != nil {
    log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;example.org.csr&lt;/code&gt;と&lt;code&gt;example.org.key&lt;/code&gt;が生成できる．&lt;/p&gt;

&lt;p&gt;次に証明書の発行を行う．コードは以下（&lt;code&gt;client&lt;/code&gt;の初期化と&lt;code&gt;key&lt;/code&gt;の読み込みは完了しているとする）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;csrData, err := ioutil.ReadFile(&amp;quot;example.org.csr&amp;quot;)
if err != nil {
    log.Fatal(err)
}

csrBlock, _ := pem.Decode(csrData)
csr, err := x509.ParseCertificateRequest(csrBlock.Bytes)
if err != nil {
    log.Fatal(err)
}

cert, err := client.NewCertificate(key, csr)
if err != nil {
    log.Fatal(err)
}

certOut, err := os.Create(&amp;quot;example.org.crt&amp;quot;)
if err != nil {
    log.Fatal(err)
}

if err := pem.Encode(certOut, &amp;amp;pem.Block{
    Type:  &amp;quot;CERTIFICATE&amp;quot;,
    Bytes: cert.Raw,
}); err != nil {
    log.Fatal(err)
}

log.Println(&amp;quot;[INFO] Successfully issued&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上で生成した&lt;code&gt;.csr&lt;/code&gt;を読み込み&lt;code&gt;NewCertificate&lt;/code&gt;を呼ぶだけ．簡単．&lt;/p&gt;

&lt;h2 id=&#34;証明書の検証&#34;&gt;証明書の検証&lt;/h2&gt;

&lt;p&gt;最後に証明書の検証を行う．Go言語で証明書の検証は以下のように書ける（&lt;code&gt;boulder&lt;/code&gt;のDevモードの場合は&lt;code&gt;test&lt;/code&gt;ディレクトリ以下に&lt;code&gt;test-ca.pem&lt;/code&gt;があるのでそれを使う）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;caData, err := ioutil.ReadFile(&amp;quot;./test-ca.pem&amp;quot;)
roots := x509.NewCertPool()
if ok := roots.AppendCertsFromPEM(caData); !ok {
    log.Fatal(&amp;quot;Failed to parse ca pem&amp;quot;)
}

certData, err := ioutil.ReadFile(&amp;quot;./example.org.crt&amp;quot;)
certBlock, _ := pem.Decode(certData)
cert, err := x509.ParseCertificate(certBlock.Bytes)
if err != nil {
    log.Fatal(err)
}

opts := x509.VerifyOptions{
    DNSName: &amp;quot;example.org&amp;quot;,
    Roots:   roots,
}

if _, err := cert.Verify(opts); err != nil {
    log.Fatal(err)
}

log.Println(&amp;quot;[INFO] Verified !&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;本記事ではACMEをベースとしたCAであるboulderをローカルで動かし，ACMEのGo言語クライアントライブラリを使いながらACMEの詳細を追ってみた．Webの基本の技術を組み合わせているだけなので特に複雑ではない．200行のpythonで書かれたACMEツールなどもある（cf. &lt;a href=&#34;https://github.com/diafygi/acme-tiny&#34;&gt;diafygi/acme-tiny&lt;/a&gt;）のでいろいろ探ってみたら面白いと思う．&lt;/p&gt;

&lt;p&gt;どんどんTLSにしていくぞ！&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ietf-wg-acme/acme/&#34;&gt;ACME spec draft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://letsencrypt.org/stats/&#34;&gt;Let&amp;rsquo;s Encrypt Stats&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/letsencrypt/boulder&#34;&gt;boulder: An ACME-based CA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/letsencrypt/boulder/blob/master/DESIGN.md&#34;&gt;Boulder flow diagrams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://letsencrypt.org/2015/11/12/public-beta-timing.html&#34;&gt;Public Beta: December 3, 2015&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://letsencrypt.org/2015/10/19/lets-encrypt-is-trusted.html&#34;&gt;Let&amp;rsquo;s Encrypt is Trusted&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://letsencrypt.org/2015/11/09/why-90-days.html&#34;&gt;Why ninety-day lifetimes for certificates?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/letsencrypt-acme&#34;&gt;Let&amp;rsquo;s Encrypt を支える ACME プロトコル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hlandau/acme&#34;&gt;hlandau/acme&lt;/a&gt;, &lt;a href=&#34;https://github.com/xenolf/lego&#34;&gt;xenolf/lego&lt;/a&gt;, &lt;a href=&#34;https://github.com/diafygi/acme-tiny&#34;&gt;diafygi/acme-tiny&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ericchiang.github.io/go/tls/lets/encrypt/letsencrypt/2015/11/13/a-letsencrypt-client-for-go.html&#34;&gt;A Let&amp;rsquo;s Encrypt Client for Go&lt;/a&gt; (&lt;a href=&#34;https://github.com/ericchiang/letsencrypt&#34;&gt;ericchiang/letsencrypt&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/rrreeeyyy/lets-encrypt-and-acme-overview-hbstyle-2015-1112&#34;&gt;Let&amp;rsquo;s Encrypt &amp;amp; ACME Overview (hbstyle-2015-1112)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lolware.net/2015/10/27/letsencrypt_go_live.html&#34;&gt;Using Lets Encrypt&lt;/a&gt; (RubyでACMEを喋りたい場合に参考になる)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.kazuhooku.com/2015/12/using-h2o-with-lets-encrypt.html&#34;&gt;Using H2O with Let&amp;rsquo;s Encrypt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hde-advent-2015.hatenadiary.jp/entry/2015/12/02/095643&#34;&gt;GoでOAuth2/OpenIDとJOSE (JWA/JWT/JWK/JWS/JWE)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go言語とHTTP2</title>
      <link>http://deeeet.com/writing/2015/11/19/go-http2/</link>
      <pubDate>Thu, 19 Nov 2015 01:30:18 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/11/19/go-http2/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://golang.org/s/http2iscoming&#34;&gt;http2 in Go 1.6; dotGo 2015 - Google スライド&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2015年の5月に&lt;a href=&#34;http://www.rfc-editor.org/rfc/rfc7540.txt&#34;&gt;RFC&lt;/a&gt;が出たばかりのHTTP2が2016年の2月に&lt;a href=&#34;https://github.com/golang/go/milestones&#34;&gt;リリース予定&lt;/a&gt;のGo1.6で早くも利用可能になることになっている．HTTP2の勉強も兼ねてGo言語におけるHTTP2実装を追ってみる．&lt;/p&gt;

&lt;p&gt;以下ではまず実際にHTTP2サーバを動かしChromeで接続してみる．次に現状コードがどのように管理されているかを追う．最後に実際にコードを動かしながらHTTP2の各種機能を追う．なお参照するコードはすべて以下のバージョンを利用している（まだWIPなのでコードなどは今後変わる可能性があるので注意）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go version
go version devel +9b299c1  darwin/amd64
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;http2とは&#34;&gt;HTTP2とは?&lt;/h2&gt;

&lt;p&gt;HTTP/2に関してはスライドやブログ記事，Podcastなど非常に豊富な情報がインターネット上に存在する．そもそもHTTP2とは何か?なぜ必要なのか?などを理解したい場合は&lt;a href=&#34;#cf&#34;&gt;参考&lt;/a&gt;に挙げた記事などを参照するのがよい．&lt;/p&gt;

&lt;h2 id=&#34;実際に使ってみる&#34;&gt;実際に使ってみる&lt;/h2&gt;

&lt;p&gt;最小限のコードでHTTP2サーバーを起動しChromeで接続してみる．&lt;/p&gt;

&lt;p&gt;まず最新のGoをソースからビルドする（ビルドにはGo1.5.1を利用する）．以下では2015年11月16日時点の最新を利用した．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone --depth=1 https://go.googlesource.com/go ~/.go/latest
$ export GOROOT_BOOTSTRAP=~/.go/1.5.1
$ cd ~/.go/latest/src &amp;amp;&amp;amp; ./make.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現時点でGoにおけるHTTP2はover TLSが前提になっている．そのためサーバー証明書と鍵が必要になる（なければ事前に&lt;code&gt;openssl&lt;/code&gt;コマンドや&lt;code&gt;crypto/x509&lt;/code&gt;パッケージなどを使って自己署名証明書をつくる）．&lt;/p&gt;

&lt;p&gt;コードは以下．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
    certFile, _ := filepath.Abs(&amp;quot;server.crt&amp;quot;)
    keyFile, _ := filepath.Abs(&amp;quot;server.key&amp;quot;)
    
    http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
       fmt.Fprintf(w, &amp;quot;Protocol: %s\n&amp;quot;, r.Proto)
    })

    err := http.ListenAndServeTLS(&amp;quot;:3000&amp;quot;, certFile, keyFile, nil)
    if err != nil {
        log.Printf(&amp;quot;[ERROR] %s&amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;証明書と鍵を読み込んで&lt;code&gt;ListenAndServeTLS&lt;/code&gt;を呼ぶだけ．HTTP2のために特別なことをする必要はない．クライアントがHTTP2に対応していれば勝手にHTTP2が使われる．起動して接続すると以下のように「Protocol: HTTP/2.0」が確認できる（Chrome拡張の&lt;a href=&#34;https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin?hl=ja&#34;&gt;HTTP/2 and SPDY indicator&lt;/a&gt;が反応しているのも確認できる）．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/http2.png&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;コードの行方&#34;&gt;コードの行方&lt;/h2&gt;

&lt;p&gt;現在HTTP2のコードはどのように管理されているのか? もともとは&lt;a href=&#34;https://github.com/bradfitz&#34;&gt;bradfitz&lt;/a&gt;氏により&lt;a href=&#34;https://github.com/bradfitz/http2&#34;&gt;bradfitz/http2&lt;/a&gt;で実装が進められていた．そして&lt;a href=&#34;https://godoc.org/golang.org/x/net/http2&#34;&gt;golang.org/x/net/http2&lt;/a&gt;に移動した．ちなみにGo1.5以前でもこちらのパッケージを使えばHTTP2を&lt;a href=&#34;http://www.integralist.co.uk/posts/http2.html#10&#34;&gt;使うことはできる&lt;/a&gt;．&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;http2&lt;/code&gt;パッケージの位置付けはローレベルなHTTP2の実装であり普通のひとは触ることがない．Go1.6では普通のひとが触るハイレベルなインターフェースは今まで通りの&lt;code&gt;net/http&lt;/code&gt;となる．&lt;/p&gt;

&lt;p&gt;では最新のGoのコードにはどのようにマージされたのか? まずヘッダ圧縮の&lt;a href=&#34;https://tools.ietf.org/html/rfc7541&#34;&gt;HPACK&lt;/a&gt;は&lt;code&gt;http2/hpack&lt;/code&gt;という名前でサブディレクトリに別パッケージとして実装されている．これは&lt;code&gt;src/vendor&lt;/code&gt;以下にvendoringされている．&lt;code&gt;http2&lt;/code&gt;も同様にvendoringされているだけかと思ったが，こちらは&lt;code&gt;net/http&lt;/code&gt;パッケージに&lt;code&gt;h2_bundle.go&lt;/code&gt;という1つのファイルとして組み込まれている．&lt;/p&gt;

&lt;p&gt;具体的な経緯は&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-dev/8Qjr03xf07U&#34;&gt;http -&amp;gt; http2 -&amp;gt; http import cycle&lt;/a&gt;を読むとわかるが，単純にvendoringすると&lt;code&gt;net/http&lt;/code&gt;-&amp;gt;&lt;code&gt;http2&lt;/code&gt;と&lt;code&gt;http2&lt;/code&gt;-&amp;gt;&lt;code&gt;net/http&lt;/code&gt;というimport cycleが起こってしまう．これは上の例で示したようにAPIの変更なしにHTTP2を有効にするというゴールを達成するためには避けられない．&lt;/p&gt;

&lt;p&gt;これを解決するために使われたのが&lt;a href=&#34;https://godoc.org/golang.org/x/tools/cmd/bundle&#34;&gt;bundleコマンド&lt;/a&gt;である．これはパッケージを別パッケージとして1つのファイルにするコマンド．以下のように使われる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bundle golang.org/x/net/http2 net/http http2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;golang.org/x/net/http2&lt;/code&gt;を&lt;code&gt;net/http&lt;/code&gt;パッケージとして&lt;code&gt;http2&lt;/code&gt;というprefixをつけて一つのファイルにまとめるいうことがおこる．&lt;/p&gt;

&lt;p&gt;変更はどうするのか? &lt;code&gt;bundle&lt;/code&gt;はテストを無視するため変更はテストがちゃんとある&lt;a href=&#34;https://godoc.org/golang.org/x/net/http2&#34;&gt;golang.org/x/net/http2&lt;/a&gt;に入り，その都度&lt;code&gt;bundle&lt;/code&gt;してマージとなるらしい（リリースまでは）．&lt;/p&gt;

&lt;p&gt;&amp;hellip; というのが現状．正式なリリースまでに時間はあるのでどうなるのかはわからない．&lt;/p&gt;

&lt;h2 id=&#34;http2の機能を追う&#34;&gt;HTTP2の機能を追う&lt;/h2&gt;

&lt;p&gt;以下ではHTTP2の主な機能がどのようにGo言語で実装されているのかを見ていく．&lt;/p&gt;

&lt;h3 id=&#34;フレームとストリーム&#34;&gt;フレームとストリーム&lt;/h3&gt;

&lt;p&gt;HTTP1.xではリクエスト/レスポンスのフォーマットにテキストが利用されてきた．HTTP2ではフレームと呼ばれるバイナリのフォーマットが利用される．これにより転送量の低減を実現している．&lt;/p&gt;

&lt;p&gt;フレームには&lt;a href=&#34;https://tools.ietf.org/html/rfc7540#section-6&#34;&gt;いくつかのタイプが定義されている&lt;/a&gt;．例えばHTTP1.xのヘッダにあたるHEADERS，HTTP1.xのBody部にあたるDATAなどがある．フレームは以下のようなフォーマットで表現される（cf. &lt;a href=&#34;https://tools.ietf.org/html/rfc7540#section-4&#34;&gt;4.HTTP Frames&lt;/a&gt;）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTTP1.xでは1つのリソースを取得するために1つのTCPコネクションが必要である．つまり3つの画像が必要であれば3つのTCPコネクションが必要である．TCPはThree-way handshakingやスロースタートにより通信のオーバーヘッドが避けられない．そのため各コネクションはなるべく並列で確立されるのが望ましい．しかし同一オリジンへの同時接続数はたいてい6つに制限されている．つまり7つ目は先の6つのどれかが完了するまでブロックされる．これに対応するためにHTTP1.x時代では画像などを別ドメインから読み込むDomain Shardingという手法が一般的にはとられてきた（cf.&lt;a href=&#34;http://t32k.me/mol/log/reduce-http-requests-overview/&#34;&gt;HTTPリクエストを減らすために&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;HTTP2ではストリームという概念を導入し上記の問題を解決している．ストリームとは1つのTCPコネクション上に作られる仮想的な双方向シーケンスである．このストリームによりリクエストは多重化され複数のリソース取得も並列で実行可能になる．それぞれのリクエストとレスポンスはひとつのストリームで処理され，それぞれがユニークなIDをもつ．&lt;/p&gt;

&lt;p&gt;Go言語ではどう実装されているか．まず&lt;a href=&#34;https://godoc.org/golang.org/x/net/http2#Framer&#34;&gt;&lt;code&gt;Framer&lt;/code&gt;&lt;/a&gt;というstructがフレームの書き込みと読み込みを担う．そしてそれぞれのタイプのフレームの書き込みのために専用のメソッド，例えばDATAなら&lt;code&gt;WriteData&lt;/code&gt;，HEADERSなら&lt;code&gt;WriteHeaders&lt;/code&gt;，が準備されている．&lt;/p&gt;

&lt;p&gt;実際にDATAフレームを作って中身を覗いてみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;buf := new(bytes.Buffer)
fr := http2.NewFramer(buf, buf)

var streamID uint32 = 1&amp;lt;&amp;lt;24 + 2&amp;lt;&amp;lt;16 + 3&amp;lt;&amp;lt;8 + 4
fr.WriteData(streamID, true, []byte(&amp;quot;Hello&amp;quot;))

b := buf.Bytes()
fmt.Printf(&amp;quot;Frame: %q\n&amp;quot;, b)

fmt.Printf(&amp;quot;Type: %x\n&amp;quot;, b[4:5])    // Type: 01
fmt.Printf(&amp;quot;StremID: %x\n&amp;quot;, b[5:9]) // StremID: 01020304
fmt.Printf(&amp;quot;DATA: %x\n&amp;quot;, b[9:])     // DATA: 48656c6c6f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NewFramer&lt;/code&gt;で&lt;code&gt;Framer&lt;/code&gt;をつくり，&lt;code&gt;WriteData&lt;/code&gt;でストリームのIDとともにデータを書き込む．あとは書き込まれたデータを定義に基づき覗くと中身が見れる．&lt;/p&gt;

&lt;h3 id=&#34;ヘッダ圧縮&#34;&gt;ヘッダ圧縮&lt;/h3&gt;

&lt;p&gt;HTTPはステートレスなプロトコルである．そのためHTTP1.xでは1つのセッションで毎回似たようなヘッダを送る必要があり冗長である．HTTP2ではヘッダの圧縮を行う．ヘッダの圧縮にはHPACKと呼ばれる手法を用いる．HPACKは&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%95%E3%83%9E%E3%83%B3%E7%AC%A6%E5%8F%B7&#34;&gt;ハフマン符号化&lt;/a&gt;と静的/動的テーブルという仕組みで圧縮を行う手法である．HPACKはHTTP2とは別に&lt;a href=&#34;https://tools.ietf.org/html/rfc7541&#34;&gt;RFC 7541&lt;/a&gt;で仕様化されている．&lt;/p&gt;

&lt;p&gt;Go言語では&lt;code&gt;http2/hpack&lt;/code&gt;という名前で&lt;code&gt;http2&lt;/code&gt;パッケージのサブディレクトリに別パッケージとして実装されている．それぞれ実際に使ってみる．&lt;/p&gt;

&lt;p&gt;まずハフマン符号化．ハフマン符号は文字の出現頻度の偏りに合わせてビット列を割り当てる符号化である．ここでは例として&lt;code&gt;www.example.com&lt;/code&gt;という文字列をハフマン符号でEncode/Decodeしてみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;s := &amp;quot;www.example.com&amp;quot;

fmt.Println(len(s))
fmt.Println(hpack.HuffmanEncodeLength(s))

b := hpack.AppendHuffmanString(nil, s)
fmt.Printf(&amp;quot;%x\n&amp;quot;, b)

var buf bytes.Buffer
hpack.HuffmanDecode(&amp;amp;buf, b)

fmt.Printf(&amp;quot;%s\n&amp;quot;, buf.String())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上の例では15バイトの文字列を12バイトに符号化できる．&lt;/p&gt;

&lt;p&gt;次にテーブルによる圧縮．HTTP2ではよく利用するヘッダをKey-Valueの辞書としてもちそのインデックスを示すことでヘッダを表現する．テーブルは仕様として事前に定義された（&lt;a href=&#34;https://tools.ietf.org/html/rfc7541#appendix-A&#34;&gt;Static Table Definition&lt;/a&gt;）静的テーブルとリクエストのやりとりの中で更新する動的テーブルがある．&lt;/p&gt;

&lt;p&gt;まず静的テーブルにエントリがある&lt;code&gt;:method GET&lt;/code&gt;をEncodeしてみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var buf bytes.Buffer
e := hpack.NewEncoder(&amp;amp;buf)

e.WriteField(hpack.HeaderField{
    Name:  &amp;quot;:method&amp;quot;,
    Value: &amp;quot;GET&amp;quot;,
})

fmt.Printf(&amp;quot;Encoded: %x (%d) \n&amp;quot;, buf.Bytes(), len(buf.Bytes()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは1バイトに圧縮される．&lt;/p&gt;

&lt;p&gt;次に静的テーブルにエントリのない&lt;code&gt;:authority www.example.com&lt;/code&gt;をEncodeしてみる．動的テーブルの効果をみるために2度実行する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var buf bytes.Buffer
e := hpack.NewEncoder(&amp;amp;buf)

e.WriteField(hpack.HeaderField{
    Name:  &amp;quot;:authority&amp;quot;,
    Value: &amp;quot;www.example.com&amp;quot;,
})

fmt.Printf(&amp;quot;Encoded: %x (%d) \n&amp;quot;, buf.Bytes(), len(buf.Bytes()))
buf.Reset()

e.WriteField(hpack.HeaderField{
    Name:  &amp;quot;:authority&amp;quot;,
    Value: &amp;quot;www.example.com&amp;quot;,
})

fmt.Printf(&amp;quot;Encoded: %x (%d) \n&amp;quot;, buf.Bytes(), len(buf.Bytes()))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同じヘッダに対して2度Encodeを実行する．まず1度目は動的テーブルにエントリがないため14バイトにしかならない．もしテーブルにエントリがない場合は，動的テーブルにそれが追加される．そして2度目の実行時はそのテーブルが参照され1バイトに圧縮される．&lt;/p&gt;

&lt;h3 id=&#34;優先度制御&#34;&gt;優先度制御&lt;/h3&gt;

&lt;p&gt;HTTP1.xでは全てのリクエストは平等に処理される．つまり画像もCSSもJSも全て平等に処理される．HTTP2ではクライアントがリクエストに優先度を指定することができる．例えばサイトのレンダリングが必要なCSSやJSを優先的にリクエストすることができる．これによりページの描画を改善しユーザの体感速度を向上することが期待できる．&lt;/p&gt;

&lt;p&gt;Go言語ではどうなっているのか．クライアントは&lt;a href=&#34;https://godoc.org/golang.org/x/net/http2#PriorityParam&#34;&gt;&lt;code&gt;PriorityParam&lt;/code&gt;&lt;/a&gt;というstructを用いて優先度の指定を行う．そしてHEADERSもしくはPRIOTIRYフレームでこれを送信する．&lt;/p&gt;

&lt;p&gt;次にサーバーの動き．これは外からは触れない．どう処理されるかはテストコードを見るのが良い．&lt;code&gt;priority_test.go&lt;/code&gt;を見る．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// A -&amp;gt; B
// move A&#39;s parent to B
streams := make(map[uint32]*stream)
a := &amp;amp;stream{
    parent: nil,
    weight: 16,
}
streams[1] = a

b := &amp;amp;stream{
    parent: a,
    weight: 16,
}
streams[2] = b

adjustStreamPriority(streams, 1, PriorityParam{
    Weight:    20,
    StreamDep: 2,
})

if a.parent != b {
    t.Errorf(&amp;quot;Expected A&#39;s parent to be B&amp;quot;)
}
if a.weight != 20 {
    t.Errorf(&amp;quot;Expected A&#39;s weight to be 20; got %d&amp;quot;, a.weight)
}
if b.parent != nil {
    t.Errorf(&amp;quot;Expected B to have no parent&amp;quot;)
}
if b.weight != 16 {
    t.Errorf(&amp;quot;Expected B&#39;s weight to be 16; got %d&amp;quot;, b.weight)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各&lt;code&gt;a&lt;/code&gt;と&lt;code&gt;b&lt;/code&gt;という&lt;code&gt;stream&lt;/code&gt;がmapで管理されている．mapのkeyは各&lt;code&gt;stream&lt;/code&gt;のIDである．そして&lt;code&gt;adjustStreamPriority&lt;/code&gt;でIDが1である&lt;code&gt;a&lt;/code&gt;の優先度を16から20に更新し依存するストリームのIDを2に変更する．&lt;/p&gt;

&lt;p&gt;&amp;hellip;と優先度の更新は追えたが，この優先度をどのように使っているのかは見つけることができなかった．知ってる人がいたら教えてください．&lt;/p&gt;

&lt;h3 id=&#34;server-push&#34;&gt;Server Push&lt;/h3&gt;

&lt;p&gt;HTTP1.xではクライアントからリソースのリクエストがあって初めてサーバー側からそれを送ることができる．HTTP2ではServer Pushという仕組みを使い，クライアントがリクエストする前にサーバー側からクライアントにリソースを送りつけることができる．例えばサーバーがHTMLのリクエストを受けたとする．サーバーはHTMLの内容を知っているので次にCSSやJSのリクエストがクライアントから送られることを予想できる．Server Pushを使えばそれらを先に送信することができる．&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/kazuho&#34;&gt;kazuho&lt;/a&gt;さんによる&lt;a href=&#34;https://github.com/h2o/h2o&#34;&gt;H2O&lt;/a&gt;に関する発表を見ているとServer Pushは難しそう．Server Pushで送られたリソースはクライアントでキャッシュされ，クライアントはそのキャッシュを利用することになる．既にキャッシュが存在する場合にPushするのは無駄になるが，それを制御するのは難しい（H2Oでは&lt;a href=&#34;http://www.slideshare.net/kazuho/cache-awareserverpush-in-h2o-version-15&#34;&gt;Cache aware-server-push&lt;/a&gt;をしているとのこと）．&lt;/p&gt;

&lt;p&gt;Go言語ではどうなっているのか．Server Pushを行うときはPUSH_PROMISEというフレームをサーバーは送信する．このフレームを作成する&lt;code&gt;WritePushPromise&lt;/code&gt;というメソッドは準備されている．がServer Pushを行うためのハイレベルなインターフェースは現時点では見当たらなかった．&lt;a href=&#34;https://groups.google.com/forum/?fromgroups#!searchin/golang-nuts/http2/golang-nuts/1ggSbDA_XYI/kJhd35zwDgAJ&#34;&gt;&amp;ldquo;Please test Go&amp;rsquo;s HTTP/2 support&amp;rdquo;&lt;/a&gt;などを読む限り今後のバージョンでのリリースになりそう．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Go1.6に予定されているHTTP2の実装を追ってみた．Server Pushのハイレベルなインターフェースを除いた基本的な機能は実装されている．そしてGo1.5以前と同じインターフェースで利用できることがわかった．&lt;/p&gt;

&lt;p&gt;Go言語のHTTP2をすぐに使うのか? と聞かれるとまだ議論が必要であると感じた．少なくとも現時点ではTLS終端はアプリケーションの前段のnginxにある．最初はnginxなどで利用することから始めると思う．&lt;/p&gt;

&lt;p&gt;PaaSを運用している立場からみると状況はもう少し複雑になる．例えばGoogle App EngineのようにTLSとHTTP2は全てGoogleのサーバーが面倒見るからその上のアプリケーションは何もしなくてもHTTP2が有効になりますと言うこともできる（cf. &lt;a href=&#34;http://googlecloudplatform.blogspot.jp/2015/10/Full-Speed-Ahead-with-HTTP2-on-Google-Cloud-Platform.html&#34;&gt;Full Speed Ahead with HTTP/2 on Google Cloud Platform&lt;/a&gt;）．その一方でServer Pushなどはアプリケーションごとにコントロールしたいかもしれない．そういう場合にどのようにハンドルするべきなのかなど考えることは多い．&lt;/p&gt;

&lt;h3 id=&#34;cf&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/kazuho/http2-51888328&#34;&gt;HTTP/2時代のウェブサイト設計&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/KetoKawakami/http2-51414240&#34;&gt;HTTP/2でも初めてみます？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/Jxck/http2-web-web-over-http2-51943080&#34;&gt;HTTP2 時代の Web - web over http2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://techblog.yahoo.co.jp/infrastructure/http2/introduction_to_http2/&#34;&gt;HTTP/2 入門 - Yahoo! JAPAN Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/magazine/SD/archive/2015/201511&#34;&gt;Software Design 2015年11月号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/http2-server-side-architecture&#34;&gt;HTTP2 時代のサーバサイドアーキテクチャ考察&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/http2-rfc7540&#34;&gt;HTTP2 の RFC7540 が公開されました&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.scutum.jp/information/waf_tech_blog/2015/05/waf-blog-044.html&#34;&gt;HTTP/2のRFCを読んだ感想 - WAF Tech Blog ｜ クラウド型 WAFサービス Scutum 【スキュータム】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mew.org/~kazu/material/2015-warp-http2.pdf&#34;&gt;スレッドプログラミングによる HTTP/2 の実装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/http2-server-side-architecture&#34;&gt;HTTP2 時代のサーバサイドアーキテクチャ考察&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/summerwind/2-deep-dive-priority-and-server-push&#34;&gt;HTTP/2 Deep Dive: Priority &amp;amp; Server Push&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.oracle.com/theaquarium/entry/http_2_and_server_push&#34;&gt;HTTP/2 and Server Push&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.integralist.co.uk/posts/http2.html&#34;&gt;http://www.integralist.co.uk/posts/http2.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://googlecloudplatform.blogspot.jp/2015/10/Full-Speed-Ahead-with-HTTP2-on-Google-Cloud-Platform.html&#34;&gt;Full Speed Ahead with HTTP/2 on Google Cloud Platform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://http2study.connpass.com/event/21161/presentation/&#34;&gt;http2/quic meetup - 資料一覧 - connpass&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mozaic.fm/post/83421293098/2-http2&#34;&gt;mozaic.fm #2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/99/&#34;&gt;Rebuild: 99: The Next Generation Of HTTP (kazuho)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://changelog.com/161/&#34;&gt;#161: HTTP/2 with Ilya Grigorik&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go言語と暗号技術（AESからTLS）</title>
      <link>http://deeeet.com/writing/2015/11/10/go-crypto/</link>
      <pubDate>Tue, 10 Nov 2015 15:53:31 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/11/10/go-crypto/</guid>
      <description>

&lt;p&gt;最近&lt;a href=&#34;http://www.amazon.co.jp/%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0TCP-SSL-TLS%E7%B7%A8-Eric-Rescorla/dp/4274065421&#34;&gt;マスタリングTCP/IP SSL/TLS編&lt;/a&gt;や&lt;a href=&#34;http://www.amazon.co.jp/3-ebook/dp/B015643CPE/&#34;&gt;暗号技術入門&lt;/a&gt;を読んでいた．理解を深めるためにGo言語で標準の&lt;code&gt;crypto&lt;/code&gt;パッケージを触り/実装を読みながら読んだ．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;crypto&lt;/code&gt;パッケージは他の標準パッケージと同様に素晴らしい．Go言語にはどのような暗号化手法が実装されているのか実例を含めてざっとまとめる．なお本文に書ききれなかったものを含め全ての実装例は&lt;a href=&#34;https://github.com/tcnksm/go-crypto&#34;&gt;tcnksm/go-crypto&lt;/a&gt;にある．&lt;/p&gt;

&lt;h2 id=&#34;共通鍵暗号&#34;&gt;共通鍵暗号&lt;/h2&gt;

&lt;p&gt;まずは共通鍵暗号をみる．共通鍵暗号は暗号化と復号化に同じ鍵を用いる暗号化方式である．共通鍵暗号はブロック暗号とストリーム暗号の2種類に分けることができる．ブロック暗号は特定の長さ単位で暗号化を行う方式であり，ストリーム暗号はデータの流れを順次処理していく方式である．&lt;/p&gt;

&lt;p&gt;Go言語にはブロック暗号としてDES（Data Encryption Standard），DESを繰り返すtriple-DES，そしてAES（Advanced Encryption Standard ）が実装されている．ストリーム暗号としてはRC4が実装されている．&lt;/p&gt;

&lt;p&gt;AESはDESに代わる新しい標準のアルゴリズムであり公募により選出された．互換性などを考慮しない限りこれを使うのが良い．実際に&lt;code&gt;plainText&lt;/code&gt;をAESで暗号化/復号化してみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;plainText := []byte(&amp;quot;This is 16 bytes&amp;quot;)

key := []byte(&amp;quot;passw0rdpassw0rdpassw0rdpassw0rd&amp;quot;)

block, err := aes.NewCipher(key)
if err != nil {
    fmt.Printf(&amp;quot;err: %s\n&amp;quot;, err)
    return
}

// Encrypt
cipherText := make([]byte, len(plainText))
block.Encrypt(cipherText, plainText)
fmt.Printf(&amp;quot;Cipher text: %x\n&amp;quot;, cipherText)

// Decrypt
decryptedText := make([]byte, len(cipherText))
block.Decrypt(decryptedText, cipherText)
fmt.Printf(&amp;quot;Decrypted text: %s\n&amp;quot;, string(decryptedText))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AESの鍵長さは16byte，24byte，32byteのいずれかである必要がある（それぞれAES-128，AES-192，AES-256と呼ばれる）．&lt;code&gt;NewCipher&lt;/code&gt;は&lt;code&gt;cipher.Block&lt;/code&gt;インタフェースを返す．このインタフェースには&lt;code&gt;Encrypt()&lt;/code&gt;と&lt;code&gt;Decrypt()&lt;/code&gt;が実装されている．全てのブロック暗号にはこのインタフェースが実装されている（他の例は&lt;a href=&#34;https://github.com/tcnksm/go-crypto/tree/master/symmetric-key&#34;&gt;こちら&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;AESは16byteというブロック単位で暗号化/復号化を行うアルゴリズムである．このままでは例にあるように16byteの固定視長の平文しか暗号化を行えない．これでは使えない．&lt;/p&gt;

&lt;h2 id=&#34;ブロック暗号のモード&#34;&gt;ブロック暗号のモード&lt;/h2&gt;

&lt;p&gt;任意の長さの平文を暗号化するためにはブロック暗号を繰り返し実行する必要がある．ブロック暗号にはそれを繰り返し実行するためのモードがある．&lt;/p&gt;

&lt;p&gt;まず単純に考えると平文を分割してそれぞれにブロック暗号を適用する方法が考えられる．これはECB（Electronic CodeBook mode）モードと呼ばれる．しかし同じ平文ブロックが存在する場合は同じ暗号文ブロックが存在してしまう，かつ攻撃者が暗号文ブロックを入れ替えたら平文の順番も入れ替わってしまうというなどの問題があり実用的ではない．これらの欠点を回避するために各種モードが存在する．&lt;/p&gt;

&lt;p&gt;Go言語では，ブロック暗号の各種モードを&lt;a href=&#34;https://golang.org/pkg/crypto/cipher/&#34;&gt;&lt;code&gt;cipher&lt;/code&gt;パッケージ&lt;/a&gt;に実装している．実装されているモードは以下，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CBC（Cipher Block Chainning）モード - 1つ前の暗号ブロックと平文ブロックの&lt;code&gt;XOR&lt;/code&gt;をとってから暗号化を行う．1番最初の平文ブロックにはIV（Initialization Vector）と&lt;code&gt;XOR&lt;/code&gt;をとる．暗号ブロックの一部が欠損すると以後の平文全てに影響が出る．SSL/TLSに利用されている（3DES_EDE_CBC，AES_256_CBC）．&lt;/li&gt;
&lt;li&gt;CFB（Cipher FeedBack）モード - 1つ前の暗号ブロックを暗号化したもの（Key Stream）と平文ブロックの&lt;code&gt;XOR&lt;/code&gt;をとる．再生攻撃が可能．&lt;/li&gt;
&lt;li&gt;OFB（Output FeedBack）モード - 1つ前の暗号化の出力（Key Stream）を次の暗号化の入力とする．暗号化の出力（Key Stream）と平文で&lt;code&gt;XOR&lt;/code&gt;をとる（Key Streamを事前につくっておくことができる）．もし暗号結果が同じものになったらそれ以後Key Streamは全て同じ値になってしまう．暗号文を1ビット反転させると平文も1ビット反転する&lt;/li&gt;
&lt;li&gt;CTR（CounTeR）モード - 1つずつ増加していくカウンタを暗号化してKey Streamを作り出す．カウンタを暗号化してKey Streamとする．カウンタは暗号化のたびに異なる値（ノンス）をもとにしてつくる．暗号文を1ビット反転させると平文も1ビット反転する．暗号結果が同じになってもそれ以後のKey Streamが同じ値になることがない．&lt;/li&gt;
&lt;li&gt;GCM（Galois/Counter）モード - CTRが暗号文を作り出すと同時に「この暗号文は正しい暗号化によって作られたものである」とう認証子を作り出す．暗号文の偽装を見抜くことができる．TLS1.2で使われる．IVが必要ない．AEAD（Authenticated Encryption with Associated Data）の一種である．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;なおCFB，OFBそしてCTRはブロック暗号を使ってストリーム暗号を作り出しているとみなすことができる．&lt;/p&gt;

&lt;p&gt;実際にAES+CTRモードで&lt;code&gt;plainText&lt;/code&gt;を暗号/復号化してみる．今回は平文が16byteである必要はなく，任意の長さの平文を入力として使うことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;plainText := []byte(&amp;quot;Bob loves Alice. But Alice hate Bob...&amp;quot;)

key := []byte(&amp;quot;passw0rdpassw0rdpassw0rdpassw0rd&amp;quot;)

// Create new AES cipher block
block, err := aes.NewCipher(key)
if err != nil {
    fmt.Printf(&amp;quot;err: %s\n&amp;quot;, err)
}

// Create IV
cipherText := make([]byte, aes.BlockSize+len(plainText))
iv := cipherText[:aes.BlockSize]
if _, err := io.ReadFull(rand.Reader, iv); err != nil {
    fmt.Printf(&amp;quot;err: %s\n&amp;quot;, err)
}

// Encrypt
encryptStream := cipher.NewCTR(block, iv)
encryptStream.XORKeyStream(cipherText[aes.BlockSize:], plainText)
fmt.Printf(&amp;quot;Cipher text: %x \n&amp;quot;, cipherText)

// Decrpt
decryptedText := make([]byte, len(cipherText[aes.BlockSize:]))
decryptStream := cipher.NewCTR(block, cipherText[:aes.BlockSize])
decryptStream.XORKeyStream(decryptedText, cipherText[aes.BlockSize:])
fmt.Printf(&amp;quot;Decrypted text: %s\n&amp;quot;, string(decryptedText))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NewCipher&lt;/code&gt;は&lt;code&gt;cipher.Block&lt;/code&gt;をつくり，それを&lt;code&gt;NewCTR&lt;/code&gt;の入力とする．IV（ストリームの初期値）はユニークでる必要があるが安全である必要はないので暗号文の先頭に差し込んでいる．&lt;code&gt;NewCTR&lt;/code&gt;は&lt;code&gt;cipher.Stream&lt;/code&gt;インタフェースを返す．あとはそれに平文/暗号文を入力として与えれば暗号化/復号化が行われる．&lt;/p&gt;

&lt;h2 id=&#34;公開鍵暗号&#34;&gt;公開鍵暗号&lt;/h2&gt;

&lt;p&gt;共通鍵暗号は強力だが鍵配送問題（いかに安全に共通鍵を交換するか）がある．この問題を解決するのが公開鍵暗号である．公開鍵暗号は，公開鍵で暗号化を行い，秘密鍵で復号化を行う暗号化方式である．Go言語ではRSAと楕円曲線（Elliptic Curve）暗号が実装されている．&lt;/p&gt;

&lt;p&gt;RSAは一番よく知られた公開鍵暗号アルゴリズムである．RSAの暗号化と復号化は，付加するパディングデータの作成や検証の手順などを組み入れた形で行われるため，それら全てを含めて仕様が決まる．Go言語では標準で以下が実装されている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RSA-PKCS1v15 - パディングとしてランダムの値を先頭に追加する．&lt;/li&gt;
&lt;li&gt;RSA-OAEP (Optimal Asymmetric Encryption Padding) - 任意のラベルのハッシュ値と決まった個数の0から作成した認証情報を平文の頭に追加してRSAで暗号化する．複合化ではRSAで復号した後，先頭に正しい「認証情報」が現れなければ「平文」を知ってる人が作成した暗号文ではない，適当に作られた暗号文であると判断しエラーを返すことができる．つまり選択暗号文攻撃に対して安全になる．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際にRSA-PKCS1v15で&lt;code&gt;plainText&lt;/code&gt;を暗号化/復号化を行う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;plainText := []byte(&amp;quot;Bob loves Alice.&amp;quot;)

// size of key (bits)
size := 2048

// Generate private and public key pair
privateKey, err := rsa.GenerateKey(rand.Reader, size)
if err != nil {
    fmt.Printf(&amp;quot;err: %s&amp;quot;, err)
    return
}

// Get public key from private key and encrypt
publicKey := &amp;amp;privateKey.PublicKey

cipherText, err := rsa.EncryptPKCS1v15(rand.Reader, publicKey, plainText)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}
fmt.Printf(&amp;quot;Cipher text: %x\n&amp;quot;, cipherText)

// Decrypt with private key
decryptedText, err := rsa.DecryptPKCS1v15(rand.Reader, privateKey, cipherText)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}
    
fmt.Printf(&amp;quot;Decrypted text: %s\n&amp;quot;, decryptedText)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;乱数と鍵の長さを入力として&lt;code&gt;GenerateKey&lt;/code&gt;で公開鍵と秘密鍵のペアを作る．&lt;code&gt;PrivateKey&lt;/code&gt;の中身を見ると鍵を構成する素数をみることができる．あとは&lt;code&gt;EncryptPKCS1v15&lt;/code&gt;と&lt;code&gt;DecryptPKCS1v15&lt;/code&gt;で暗号化/復号化を行うことができる．&lt;/p&gt;

&lt;p&gt;鍵の長さは1024は新規用途には合わず，2048は2030年まで新規用途に合わず，4096は2031年以降も使うことができると言われている．&lt;/p&gt;

&lt;h2 id=&#34;ハッシュ&#34;&gt;ハッシュ&lt;/h2&gt;

&lt;p&gt;共通鍵暗号や公開鍵暗号を使えばメッセージを暗号化してやりとりすることができる．しかしそれだけではメッセージが途中で改竄されたかを判別することができない．これを解決するために用いられるのがハッシュ関数である．&lt;/p&gt;

&lt;p&gt;Go言語は標準でMD5，SHA-1，SHA-2（SHA-224，SHA-256，SHA-384，SHA-512，SHA-512/224，SHA-512/256）が実装されている．また&lt;a href=&#34;https://godoc.org/golang.org/x/crypto&#34;&gt;golang.org/x/crypto&lt;/a&gt;にはAES同様に公募によって選定されたSHA-3（Keccak）が実装されている．&lt;/p&gt;

&lt;p&gt;実際にSHA-512を使い&lt;code&gt;msg&lt;/code&gt;からハッシュ値を計算する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;msg := []byte(&amp;quot;Bob is dead&amp;quot;)
checksum512 := sha512.Sum512(msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際にSHA-3を使い&lt;code&gt;msg&lt;/code&gt;からハッシュ値を計算する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;msg := []byte(&amp;quot;Alice is dead&amp;quot;)
// A MAC with 64 bytes of output has 512-bit security strength
h := make([]byte, 64)

d := sha3.NewShake256()
d.Write(msg)

d.Read(h)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SHA-1とSHA-2には入力制限があるが，SHA-3にはない．また&lt;code&gt;ShakeHash&lt;/code&gt;を使えば任意長のビット列を生成することができる．&lt;/p&gt;

&lt;p&gt;新規ではSHA-1を使うべきではなく，SHA-2もしくはSHA-3を使うのが良いとされている．&lt;/p&gt;

&lt;p&gt;ハッシュ関数を使えば改竄を検出することができるが，そのメッセージが期待する送信者によるものであるか，なりすましではないかを検出することはできない．&lt;/p&gt;

&lt;h2 id=&#34;メッセージ認証コード-mac&#34;&gt;メッセージ認証コード（MAC）&lt;/h2&gt;

&lt;p&gt;メッセージの改竄とそのメッセージが正しい送信者からのものであるかを検出するのにメッセージ認証コード（MAC）が利用される．MACは任意のメッセージと送信者と受信者が共有する鍵を入力として固定ビット長の出力をする関数である．&lt;/p&gt;

&lt;p&gt;Go言語では標準でHMACが実装されている．&lt;/p&gt;

&lt;p&gt;実際にHMACを使って&lt;code&gt;msg&lt;/code&gt;と&lt;code&gt;key&lt;/code&gt;からMAC値の計算と検証をやってみる．HMACは任意の&lt;code&gt;hash.Hash&lt;/code&gt;関数を使うことができる．ここではSHA-512を用いる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;msg := []byte(&amp;quot;Bob loves Alice.&amp;quot;)
key := []byte(&amp;quot;passw0rd&amp;quot;)

h1 := hmac.New(sha512.New, key)
h1.Write(msg)
mac1 := h1.Sum(nil)
fmt.Printf(&amp;quot;MAC1: %x\n&amp;quot;, mac1)

h2 := hmac.New(sha512.New, key)
h2.Write(msg)
mac2 := h2.Sum(nil)
fmt.Printf(&amp;quot;MAC2: %x\n&amp;quot;, mac2)

fmt.Printf(&amp;quot;Valid? %v\n&amp;quot;, hmac.Equal(mac1, mac2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MACでは「否認」を防止することができない．送信者と受信者が鍵を共有するため送信者だけではなく受信者もMAC値を生成できてしまう．つまり第三者にこれは送信者が生成したMACであることを証明できない（受信者が生成することもできる）．&lt;/p&gt;

&lt;h2 id=&#34;デジタル署名&#34;&gt;デジタル署名&lt;/h2&gt;

&lt;p&gt;「否認」を防止しメッセージの検証を行う方法にデジタル署名がある．デジタル署名は公開鍵暗号の応用であり，メッセージ送信者が秘密鍵で署名を行い，受信者が公開鍵で検証を行う．つまり第三者でもそのメッセージの送信を検証することができる．&lt;/p&gt;

&lt;p&gt;Go言語では標準でDSA（Digital Signature Algorithm），RSA，楕円曲線暗号によるデジタル署名が実装されている．&lt;/p&gt;

&lt;p&gt;実際に楕円曲線暗号を使ってデジタル署名とその検証をしてみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;priv, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}

hashed := []byte(&amp;quot;This is message.&amp;quot;)
r, s, err := ecdsa.Sign(rand.Reader, priv, hashed)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}

if ecdsa.Verify(&amp;amp;priv.PublicKey, hashed, r, s) {
    fmt.Printf(&amp;quot;Verified!\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;楕円曲線暗号は，楕円曲線上の演算に基づく暗号化手法である．&lt;code&gt;crypto/elliptic&lt;/code&gt;に曲線とその演算が定義されている．そして署名には&lt;code&gt;crypto/ecdsa&lt;/code&gt;パッケージを用いる．まず&lt;code&gt;GenerateKey&lt;/code&gt;で公開鍵と秘密鍵を生成する．その際に利用する楕円曲線を指定する．利用できる曲線はP-224，P-256，P-384そしてP-521である．生成した秘密鍵と任意の長さのハッシュ値を入力として&lt;code&gt;Sign&lt;/code&gt;し署名を行う．署名は&lt;code&gt;big.Int&lt;/code&gt;のペアとして返される．これらの値と公開鍵を入力として署名の検証を行う．&lt;/p&gt;

&lt;h2 id=&#34;証明書-x509&#34;&gt;証明書（x509）&lt;/h2&gt;

&lt;p&gt;公開鍵暗号は強力だが，このままでは「その公開鍵が期待する相手のものであるか」が不確かであり，man-in-the-middle攻撃を防ぐことができない．この問題を解決する方法が証明書と認証局（CA）である．サーバーは信頼できる認証局から公開鍵にデジタル署名を受け証明書を作成する．ユーザは認証局局の公開鍵で署名を検証しそのサーバーのものであるかを確認する．&lt;/p&gt;

&lt;p&gt;証明書にはX.509という規格で標準化されている．Go言語では標準で&lt;code&gt;crypto/x509&lt;/code&gt;というパッケージにこのX.509の規格に準じた証明書や鍵のパースや検証が実装されている．&lt;/p&gt;

&lt;p&gt;X.509の証明書はASN.1（Abstract Syntax Notation One）で表記される．ASN.1 は情報の抽象構文を定義するが情報のEncodeのフォーマットは限定しない．X.509ではDER（Distinguished Encoding Rules）でEncodeが行われる（Encodeがユニークに定まる）．Goでは&lt;code&gt;encoding/ans1&lt;/code&gt;パッケージにDERのEncoderが準備されている．またASN.1のよりlow levelの構造のパーサーは&lt;code&gt;crypto/x509/pkix&lt;/code&gt;に定義されている（例えば国名や組織名など）．証明書や鍵はPEM（Privacy Enhanced Mail）形式でEncodeされてファイルに保存されることが多いが，これらのエンコードは&lt;code&gt;encoding/pem&lt;/code&gt;に定義されている．&lt;/p&gt;

&lt;p&gt;または&lt;code&gt;crypto/x509&lt;/code&gt;にはRSA-PKCS1v15と楕円曲線暗号による鍵のASN.1 DER形式のMarshal/Unmarshalも実装されている．&lt;/p&gt;

&lt;p&gt;そんなことは滅多にないと思うが，実際にGo言語でX.509の自己署名証明書を作ってみる．公開鍵暗号としては楕円曲線暗号を使い，PEM形式でファイルに保存する（&lt;code&gt;ca.pem&lt;/code&gt;）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Generate pub &amp;amp; priv key pair by Elliptic Curve Digital Signature
priv, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}

// Create CA certificate template
ca := x509.Certificate{
    IsCA:         true,
    SerialNumber: big.NewInt(1234),
    Subject: pkix.Name{
        Country:      []string{&amp;quot;Japan&amp;quot;},
        Organization: []string{&amp;quot;TCNKSM ECDSA CA Inc.&amp;quot;},
    },

    NotBefore: time.Now(),
    NotAfter:  time.Now().Add(24 * time.Hour),

    KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageKeyEncipherment | x509.KeyUsageCertSign,
    ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
    BasicConstraintsValid: true,
}

// Create Certificate
derBytes, err := x509.CreateCertificate(rand.Reader, &amp;amp;ca, &amp;amp;ca, &amp;amp;priv.PublicKey, priv)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}

certOut, err := os.Create(&amp;quot;ca.pem&amp;quot;)
if err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}
defer certOut.Close()

if err := pem.Encode(certOut, &amp;amp;pem.Block{
    Type:  &amp;quot;CERTIFICATE&amp;quot;,
    Bytes: derBytes,
}); err != nil {
    fmt.Printf(&amp;quot;Err: %s\n&amp;quot;, err)
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;鍵の生成はデジタル署名と同じ．&lt;code&gt;x509.Certificate&lt;/code&gt;に証明書に必要な情報を書く．逆に読み込むときはこのstructにパースされる．あとはそれと署名したい公開鍵と署名するための秘密鍵（今回は自己署名なので生成されたペア）を入力として&lt;code&gt;x509.CreateCertificate&lt;/code&gt;を呼ぶ．&lt;/p&gt;

&lt;p&gt;他にも&lt;code&gt;crypto/x509&lt;/code&gt;パッケージで証明書の検証も行える．それらの実装例は&lt;a href=&#34;https://github.com/tcnksm/go-crypto/blob/master/certificate/x509/ecdsa/verify.go&#34;&gt;ここ&lt;/a&gt;に書いた．また&lt;code&gt;crypto/tls&lt;/code&gt;パッケージのテストを覗くと&lt;a href=&#34;https://golang.org/src/crypto/tls/generate_cert.go&#34;&gt;generate_cert.go&lt;/a&gt;というコードがあり証明書の生成例を見ることができる．&lt;/p&gt;

&lt;h2 id=&#34;tls&#34;&gt;TLS&lt;/h2&gt;

&lt;p&gt;TLSの実装も&lt;code&gt;crypto&lt;/code&gt;パッケージ以下にある．TLSは様々な暗号技術を寄せ集めたハイブリットな暗号技術であると言える．上で見てきた様々な暗号化手法が取り入れられている．通信の暗号化には共通鍵暗号を用い，共通鍵暗号の配送には公開鍵暗号を用いる．また公開鍵を認証するためにデジタル署名を用い，そしてデータの認証にHMACを持ちるなどなど．&lt;/p&gt;

&lt;p&gt;例えばpre-master secret（これをもとにサーバーとクライアントでmaster secretをつくり共通鍵暗号として通信を行う）の暗号化/復号化には公開鍵暗号が用いられる．RSAのkey-agreementの実装を見ると上で見たような暗号化が見られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;encrypted, err := rsa.EncryptPKCS1v15(config.rand(), cert.PublicKey.(*rsa.PublicKey), preMasterSecret)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;preMasterSecret, err := priv.Decrypt(config.rand(), ciphertext, &amp;amp;rsa.PKCS1v15DecryptOptions{SessionKeyLen: 48})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TLSを使ったサーバとクライアントの実装例は&lt;a href=&#34;https://github.com/tcnksm/go-crypto/tree/master/tls&#34;&gt;ここ&lt;/a&gt;にある．またhttpsのサーバとクライアントの実装例は&lt;a href=&#34;https://github.com/tcnksm/go-crypto/tree/master/https&#34;&gt;ここ&lt;/a&gt;にある．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Go言語の暗号化技術をざっと追ってみた．個々の暗号化技術を押さえておくとTLSのような複雑な実装も自分の手に届くようになる．自分なりの最終的目標は&lt;code&gt;crypto/tls&lt;/code&gt;の実装をある程度読めることとしていたが，ある程度読むことができるようになった．「暗号技術入門」を読みつつ実際のコードを読むのはとても面白いのでおすすめです．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hashicorp Ottoを読む</title>
      <link>http://deeeet.com/writing/2015/10/04/otto/</link>
      <pubDate>Sun, 04 Oct 2015 22:07:21 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/10/04/otto/</guid>
      <description>

&lt;p&gt;Hashicorpから2015年秋の新作が2つ登場した．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://hashicorp.com/blog/otto.html&#34;&gt;Otto - HashiCorp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hashicorp.com/blog/nomad.html&#34;&gt;Nomad - HashiCorp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ottoがなかなか面白そうなのでコードを追いつつ，Ottoとは何か? なぜ必要になったのか? どのように動作するのか? を簡単にまとめてみる．&lt;/p&gt;

&lt;p&gt;バージョンは &lt;em&gt;0.1.0&lt;/em&gt; を対象にしている（イニシャルインプレッションである）&lt;/p&gt;

&lt;h2 id=&#34;ottoとは何か&#34;&gt;Ottoとは何か?&lt;/h2&gt;

&lt;p&gt;公式はVagrantの後継と表現されている．が，それはローカル開発環境の構築&lt;strong&gt;も&lt;/strong&gt;担っているという意味で後継であり，自分なりの言葉で表現してみると「OttoはHashicorpの各ツールを抽象化し開発環境の構築からインフラの整備，デプロイまでを一手に担うツール」である．ちなみにOttoという名前の由来は&lt;a href=&#34;https://twitter.com/zembutsu/status/648956697034096641&#34;&gt;Automationと語感が似ているからかつ元々そういう名前のbotがいた&lt;/a&gt;からとのこと．&lt;/p&gt;

&lt;h2 id=&#34;なぜottoか&#34;&gt;なぜOttoか?&lt;/h2&gt;

&lt;p&gt;なぜVagrantでは不十分であったのか? なぜOttoが必要だったのか? 理由をまとめると以下の5つである．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;設定ファイルは似通ったものになる&lt;/li&gt;
&lt;li&gt;設定ファイルは化石化する&lt;/li&gt;
&lt;li&gt;ローカル開発環境と同じものをデプロイしたい&lt;/li&gt;
&lt;li&gt;microservicesしたい&lt;/li&gt;
&lt;li&gt;パフォーマンスを改善したい &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まず各言語/フレームワークの&lt;code&gt;Vagrantfile&lt;/code&gt;は似通ったものになる．&lt;code&gt;Vagrantfile&lt;/code&gt;は毎回似たようなものを書く，もしくはコピペしていると思う．それならツール側が最も適したものを生成したほうがよい．Ottoは各言語のベストプラクティスな設定ファイルを持っておりそれを生成する．&lt;/p&gt;

&lt;p&gt;そして&lt;code&gt;Vagrantfile&lt;/code&gt;は時代とともに古くなる，つまり化石化する．秘伝のソースとして残る．Ottoは生成する設定ファイルを常に最新のものに保つ．つまり今Ottoが生成する設定ファイルは5年後に生成される設定ファイルとは異なるものになる（cf. &lt;a href=&#34;http://blog.bennycornelissen.nl/otto-a-modern-developers-new-best-friend/&#34;&gt;&amp;ldquo;Otto: a modern developer&amp;rsquo;s new best friend&amp;rdquo;&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;そしてローカル開発環境と同じものを本番に構築したい（Environmental parityを担保したい）．現在のVagrantでも&lt;code&gt;provider&lt;/code&gt;の仕組みを使えばIaaSサービスに環境を構築することはできる．が本番に適した形でそれを構築できるとは言い難い．Ottoは開発環境の構築だけではなく，デプロイ環境の構築も担う．&lt;/p&gt;

&lt;p&gt;時代はmicroservicesである．Vagrantは単一アプリ/サービスの構築には強いが複数には弱い．Ottoは依存サービスを記述する仕組みをもつ（&lt;code&gt;Appfile&lt;/code&gt;）．それによりmicroserviceな環境を簡単に構築することができる．&lt;/p&gt;

&lt;p&gt;そしてパフォーマンス．最近のVagrantはどんどん遅くなっている．例えば立ち上げているVMの状態を確認するだけの&lt;code&gt;status&lt;/code&gt;コマンドは2秒もかかる．Ottoはパフォーマンスの改善も目的にしている．&lt;/p&gt;

&lt;h2 id=&#34;ottoは何をするのか&#34;&gt;Ottoは何をするのか?&lt;/h2&gt;

&lt;p&gt;Ottoが行うことは以下の2つに集約できる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hashicorpツールの設定ファイルとスクリプトを生成する&lt;/li&gt;
&lt;li&gt;Hashicorpツールのインストール/実行をする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ottoの各コマンドと合わせてみてみると以下のようになる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compile&lt;/code&gt; - アプリケーションのコンテキスト（e.g., 言語やフレームワーク）の判定と専用の設定ファイルである&lt;code&gt;Appfile&lt;/code&gt;をもとにHashicorpツールの設定ファイル（&lt;code&gt;Vagrantfile&lt;/code&gt;やTerraformの&lt;code&gt;.tf&lt;/code&gt;ファイル，Packerのマシンテンプレート&lt;code&gt;.json&lt;/code&gt;）と各種インストールのためのシェルスクリプトを生成する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dev&lt;/code&gt; - 開発環境を構築する．Vagrantを実行する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;infra&lt;/code&gt; - アプリをデプロイするためのインフラを整備する．例えばAWSならVPCやサブネット，ゲートウェイなどを設定する．&lt;a href=&#34;https://terraform.io/&#34;&gt;Terraform&lt;/a&gt;を実行する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt; - アプリをデプロイ可能なイメージに固める．例えばAMIやDocker Imageなど．&lt;a href=&#34;https://www.packer.io/&#34;&gt;Packer&lt;/a&gt;を実行する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deploy&lt;/code&gt; - 作成したイメージを事前に構築したインフラにデプロイする．Terraformを実行する（OttoのデプロイはImmutable Infrastructureを嗜好する）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ottoがつくるインフラの基礎&#34;&gt;Ottoがつくるインフラの基礎&lt;/h2&gt;

&lt;p&gt;Ottoには&lt;a href=&#34;https://ottoproject.io/docs/concepts/foundations.html&#34;&gt;Foundation&lt;/a&gt;という概念がある（&lt;code&gt;foundation&lt;/code&gt;という言葉は生成される設定ファイルやディレクトリ名に登場する）．これはOttoが構築するインフラの基礎，本番環境にアプリケーションをデプロイするために重要となるレイヤーを示す．このFoundationの例としては，以下のようなものが挙げられる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.consul.io/&#34;&gt;Consul&lt;/a&gt;によるサービスディスカバリー&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://vaultproject.io/&#34;&gt;Vault&lt;/a&gt;によるパスワード管理 (Future)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nomadproject.io/&#34;&gt;Nomad&lt;/a&gt;によるスケジューリング (Future)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このレイヤーはモダンなアーキテクチャーではBest Practiceとされつつも構築はなかなか難しい．OttoはVagrantでローカル開発環境を構築するとき，本番環境のインフラを整備するときにこのレイヤーの整備も一緒に行う．&lt;/p&gt;

&lt;h2 id=&#34;ottoの設定ファイル&#34;&gt;Ottoの設定ファイル&lt;/h2&gt;

&lt;p&gt;単純なことをするならばOttoには設定ファイルは&lt;strong&gt;必要ない&lt;/strong&gt;．プロジェクトのルートディレクトリで&lt;code&gt;compile&lt;/code&gt;を実行すれば言語/フレームワークを判定し，それにあった&lt;code&gt;Vagrantfile&lt;/code&gt;とインフラを整備するためのTerraformの&lt;code&gt;.tf&lt;/code&gt;ファイルなどを生成してくれる．&lt;/p&gt;

&lt;p&gt;より複雑なことをしたければ不十分である．Ottoは専用の&lt;code&gt;Appfile&lt;/code&gt;という設定ファイルでカスタマイズを行うことができる．&lt;code&gt;Appfile&lt;/code&gt;は&lt;a href=&#34;https://github.com/hashicorp/hcl&#34;&gt;HCL&lt;/a&gt;で記述する．例えば，以下のように依存するサービスを記述することができる&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;application {
    dependency {
        source = &amp;quot;github.com/tcnksm-sample/golang-web&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他にも，言語のバージョンを指定したり，デプロイするIaaSサービスやその&lt;code&gt;flavar&lt;/code&gt;（e.g., AWSだと現在&lt;code&gt;simple&lt;/code&gt;と&lt;code&gt;vpc-public-private&lt;/code&gt;がある．&lt;code&gt;simple&lt;/code&gt;は最小限のリソースを使うのみでScalabilityや耐障害性などは犠牲にする．&lt;code&gt;vpc-public-private&lt;/code&gt;だとprivateネットワークやNATなども準備する）を設定することができる．&lt;/p&gt;

&lt;p&gt;基本は適切なデフォルト値と自動で判別される値が存在する．&lt;code&gt;Appfile&lt;/code&gt;はそれを上書きするものである．公式の説明の仕方を借りると&lt;code&gt;Appfile&lt;/code&gt;は「どのようにマシンを設定するのかを記述するのではなく，アプリケーションが何であるかを記述する」ものである．&lt;/p&gt;

&lt;h2 id=&#34;ottoを読む&#34;&gt;Ottoを読む&lt;/h2&gt;

&lt;p&gt;自分が気になった部分のソースコードを軽く読んでみる．&lt;/p&gt;

&lt;h3 id=&#34;概要&#34;&gt;概要&lt;/h3&gt;

&lt;p&gt;上述したように，Ottoは各Hashicorpツールのバイナリを実行しているだけある．大まかには以下のようになる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compile&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;依存サービスがある場合はそれらを全て&lt;code&gt;.otto&lt;/code&gt;以下のディレクトリにfetchする（依存先も&lt;code&gt;Appfile&lt;/code&gt;と&lt;code&gt;.ottoid&lt;/code&gt;を持っている必要がある）&lt;/li&gt;
&lt;li&gt;各&lt;code&gt;Appfile&lt;/code&gt;と言語/フレームワークを判別結果をマージして&lt;code&gt;.otto&lt;/code&gt;ディレクトリ以下に各種設定ファイルを生成する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コマンドごとに&lt;code&gt;otto/compiled&lt;/code&gt;以下の決められたディレクトリ内の設定ファイルをもとにバイナリを実行する

&lt;ul&gt;
&lt;li&gt;e.g., &lt;code&gt;build&lt;/code&gt;を実行するとPackerのマシンテンプレートである&lt;code&gt;.otto/compiled/app/build/template.json&lt;/code&gt;が使われる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;コア&#34;&gt;コア&lt;/h3&gt;

&lt;p&gt;Ottoのコアは&lt;a href=&#34;https://github.com/hashicorp/otto/blob/v0.1.1/otto/core.go&#34;&gt;https://github.com/hashicorp/otto/blob/v0.1.1/otto/core.go&lt;/a&gt;にある．基本的にどのコマンドもここに到達する．やっていることは単純でコンテキストをもとに実行するべき設定ファイルを決めてそれを元にバイナリを実行するだけ．&lt;/p&gt;

&lt;p&gt;以下をみると各バイナリをどのように実行しているかをみることができる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hashicorp/otto/tree/v0.1.1/helper/vagrant&#34;&gt;https://github.com/hashicorp/otto/tree/v0.1.1/helper/vagrant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hashicorp/otto/tree/v0.1.1/helper/terraform&#34;&gt;https://github.com/hashicorp/otto/tree/v0.1.1/helper/terraform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hashicorp/otto/tree/v0.1.1/helper/packer&#34;&gt;https://github.com/hashicorp/otto/tree/v0.1.1/helper/packer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;インストーラー&#34;&gt;インストーラー&lt;/h3&gt;

&lt;p&gt;バイナリがインストールされていなければコマンド実行直後にインストールが実行される．&lt;a href=&#34;https://github.com/hashicorp/otto/tree/v0.1.1/helper/hashitools&#34;&gt;https://github.com/hashicorp/otto/tree/v0.1.1/helper/hashitools&lt;/a&gt;にインストーラーが書かれている．以下の&lt;a href=&#34;bintray.com&#34;&gt;bintray.com&lt;/a&gt;のURLからzipをダウンロードして展開しているだけ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;url := fmt.Sprintf(
    &amp;quot;https://dl.bintray.com/mitchellh/%s/%s_%s_%s_%s.zip&amp;quot;,
    i.Name, i.Name, vsn, runtime.GOOS, runtime.GOARCH)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（なんでmitchellhアカウントなのだろう&amp;hellip;）&lt;/p&gt;

&lt;h3 id=&#34;言語-フレームワークの判定&#34;&gt;言語/フレームワークの判定&lt;/h3&gt;

&lt;p&gt;まず&lt;code&gt;compile&lt;/code&gt;のときにアプリケーションの言語/フレームワークの判定する方法．これはHerokuのBuildpackに似たことをする．アプリケーションに特有なファイル，例えばRubyならば&lt;code&gt;Gemfile&lt;/code&gt;，が存在するかをチェックする．判定のルールは以下のような&lt;code&gt;struct&lt;/code&gt;で保持する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;detectors := []*detect.Detector{
    &amp;amp;detect.Detector{
        Type: &amp;quot;go&amp;quot;,
        File: []string{&amp;quot;*.go&amp;quot;},
    },
    ....    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして以下で判別する．単純．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func (d *Detector) Detect(dir string) (bool, error) {
    for _, pattern := range d.File {
        matches, err := filepath.Glob(filepath.Join(dir, pattern))
        if err != nil {
            return false, err
        }
        if len(matches) &amp;gt; 0 {
            return true, nil
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.hcl&lt;/code&gt;ファイルで&lt;code&gt;Detector&lt;/code&gt;を書いて&lt;code&gt;~/.otto.d/detect&lt;/code&gt;以下に置い読み込むというロジックを見かけたので自分で好きな判定ロジックを定義できるかもしれない．&lt;/p&gt;

&lt;h3 id=&#34;設定ファイル-インストールスクリプトはどこにあるのか&#34;&gt;設定ファイル/インストールスクリプトはどこにあるのか?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/kenjiskywalker/status/648884208572600323&#34;&gt;&amp;ldquo;ハシコープは人類を含む全ての概念をバイナリにして配布した&amp;rdquo;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hashicorp/otto/tree/v0.1.1/builtin/app&#34;&gt;https://github.com/hashicorp/otto/tree/v0.1.1/builtin/app&lt;/a&gt;以下に各言語の&lt;code&gt;Vagrantfile&lt;/code&gt;やpackerのマシンテンプレート，それらが呼び出すインストールスクリプトが存在する．そしてOttoはそれらを&lt;a href=&#34;https://github.com/jteeuwen/go-bindata&#34;&gt;go-bindata&lt;/a&gt;を使ってバイナリとして埋め込んでいる．&lt;code&gt;app.go&lt;/code&gt;の先頭をみるとそのための&lt;code&gt;go generate&lt;/code&gt;文が見える．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;//go:generate go-bindata -pkg=goapp -nomemcopy -nometadata ./data/...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;時代はシェルスクリプト&#34;&gt;時代はシェルスクリプト&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Vagrantfile&lt;/code&gt;のインストールスクリプト，Packerのマシンテンプレートが呼び出す&lt;code&gt;provisioner&lt;/code&gt;のスクリプト，など全てがゴリゴリのシェルスクリプトで書かれている．&lt;code&gt;Dockerfile&lt;/code&gt;以後，時代はシェルスクリプトになっている気がする．大変そう．&lt;/p&gt;

&lt;p&gt;ちなみにデーモンの管理は&lt;code&gt;upstart&lt;/code&gt;が使われている（cf. &lt;a href=&#34;https://github.com/hashicorp/otto/blob/v0.1.1/builtin/foundation/consul/data/common/app-build/upstart.conf.tpl&#34;&gt;https://github.com/hashicorp/otto/blob/v0.1.1/builtin/foundation/consul/data/common/app-build/upstart.conf.tpl&lt;/a&gt;）．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;とりあえず何か始めたいと思うときは便利であるし，期待感はある．が，最後にこれはどうなるんだろうと思ったことをまとめておく．&lt;/p&gt;

&lt;p&gt;設定ファイルをバイナリに含めたら変更が辛くなるのではないか? もし設定ファイルに不備があったらそれを修正して新しくバイナリをリリースしないといけなくなる．利用者は開発者なので問題はなさそうだけど，一度ダウンロードしたものをすぐにアップグレードしてくれるだろうか（一応利用しているバイナリが最新であるかそうでないかを判定し，古い場合には警告を出す&lt;a href=&#34;https://github.com/hashicorp/go-checkpoint&#34;&gt;仕組み&lt;/a&gt;はある）．Atlasを使ってファイルをホストする方式ではだめだったのか? boxを使うのはダメだったのか?（重いかな..）．&lt;/p&gt;

&lt;p&gt;今のところ&lt;code&gt;compile&lt;/code&gt;するたびに&lt;code&gt;.otto&lt;/code&gt;ディレクトリは作り直される．同じ環境であることは担保するのは&lt;code&gt;.ottoid&lt;/code&gt;ファイルしかない．これはどこまで非互換な変更を対処してくれるのか．ローカル開発環境は良いが，デプロイがぶっ壊れることはないだろうか.. （が，これはottoというよりはTerraformの問題な気もする）．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://pocketstudio.jp/log3/2015/10/01/joined-hashiconf-2015-at-portland/&#34;&gt;HashiConf 2015 参加してきました＆KeyNoteまとめ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>プレゼンするときに考えていること</title>
      <link>http://deeeet.com/writing/2015/09/25/talking/</link>
      <pubDate>Fri, 25 Sep 2015 08:48:30 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/09/25/talking/</guid>
      <description>&lt;p&gt;僕はカンファレンスで喋るのが好きだ．好きだが決して得意ではない．むしろ喋るのは苦手なほうだと思う．&lt;/p&gt;

&lt;p&gt;実際に自分でやるまではプレゼンは才能だと思っていた．大学の研究発表などで実際に自分でプレゼンをするようになり，大学の研究室で指導されまくった結果，プレゼンは技術だと認識した（もちろん才能もある）．技術であるということは学ぶことができる．それに気づいてからはたくさんプレゼンに関する本を読んだ．昔は発表前に必ず何か一冊プレゼンに関する本を読みそれを積極的に取り入れるようにした．&lt;/p&gt;

&lt;p&gt;得意でないなりに学んで，発表を繰り返した結果なんとなく毎回考えること/意識することが固まってきた．今後のために簡単にまとめておく．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;聴衆は貴重な時間を割いて会場に来る&lt;/li&gt;
&lt;li&gt;オーガナイザーは貴重な時間を割いてカンファレンスを準備している&lt;/li&gt;
&lt;li&gt;聴衆が誰かを妄想する&lt;/li&gt;
&lt;li&gt;早めに準備する．早めに準備する．早めに準備する．早めに&amp;hellip;&lt;/li&gt;
&lt;li&gt;Keynoteを開く前に概要とトークの流れを書く&lt;/li&gt;
&lt;li&gt;Keynoteを先に開くと流れのない壊滅的な資料ができる&lt;/li&gt;
&lt;li&gt;流れを書きつつここでx分/ここでy分という時間も想定する&lt;/li&gt;
&lt;li&gt;時間超えるのはクソである&lt;/li&gt;
&lt;li&gt;むしろ早く終わった方がよい&lt;/li&gt;
&lt;li&gt;少しでも有意義なものを受け取ってもらいたいから言いたいことは絞る&lt;/li&gt;
&lt;li&gt;言いたいことを絞れば早く終わる&lt;/li&gt;
&lt;li&gt;概要から始まり徐々に詳細に向かう&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/writing/sld012.htm&#34;&gt;逆茂木型&lt;/a&gt;に注意する&lt;/li&gt;
&lt;li&gt;前のスライドから次のスライドが想定できるようにする&lt;/li&gt;
&lt;li&gt;前のスライドから次のスライドが想定できるようなきっかけを書く&lt;/li&gt;
&lt;li&gt;Itemizeは文末を揃える&lt;/li&gt;
&lt;li&gt;例をなるべく使う&lt;/li&gt;
&lt;li&gt;図をなるべく使う&lt;/li&gt;
&lt;li&gt;文字を大きくする&lt;/li&gt;
&lt;li&gt;文字の配置，大きさ，色を一貫させる&lt;/li&gt;
&lt;li&gt;文字の配置，大きさ，色はそれだけで意味を持つ&lt;/li&gt;
&lt;li&gt;作り終わったらちゃんと喋ってこの段階のスライドがゴミであることに気づく&lt;/li&gt;
&lt;li&gt;喋って直す&lt;/li&gt;
&lt;li&gt;喋って詰まるところを喋りやすいように直す&lt;/li&gt;
&lt;li&gt;どうしても詰まるなら軽くメモを書く（書き過ぎない．あくまでメモ）&lt;/li&gt;
&lt;li&gt;会場に向かう前に一度喋っておく&lt;/li&gt;
&lt;li&gt;直前まで微調整する&lt;/li&gt;
&lt;li&gt;プロジェクターの接続テストをする&lt;/li&gt;
&lt;li&gt;アイスブレイクなんて普通は無理．ふざけるな&lt;/li&gt;
&lt;li&gt;デモは何度も練習する&lt;/li&gt;
&lt;li&gt;どんなすごい人でもデモは失敗する&lt;/li&gt;
&lt;li&gt;質問は最後までちゃんと聞く．わからなければ聞き直す&lt;/li&gt;
&lt;li&gt;本当にわけわからん質問はあとで話しましょうと言う．無理しない（昔わけわからんおっさんと戦ったことがあるが無駄だった）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;学術的な学会発表とは違って技術カンファレンスはとても好きだ．テーマは決まっているものの自由に話すことができる．
学会はある程度決められたフォーマットに従っていた．それは聞く側からすればわかりやすさにつながるが，喋る側からすればちょっと堅苦しかった．今は自由な感じで喋れるのを楽しんでいる．&lt;/p&gt;

&lt;p&gt;苦手だけど喋るのはなぜか? こんなん作ったとか，こんなんわかったとかシェアしたいという思いがあるから．ブログで書くのもよいけど，プレゼンはまた違ったフォーマットで伝わり方も変わるから楽しい．あと僕は若干コミュニケーションに問題がある．懇親会などで初対面のひとに喋りに行くとかはほぼ無理だ．が，プレゼンしてると，あれを喋った僕です的な感じで喋りに行くきっかけになる．カンファレンスで喋るモチベーションはここにもある．&lt;/p&gt;

&lt;p&gt;最後にここで書いているのは表層的な話である．本当に大切なのは内容．とにかく自分が喋る内容に対して自分が一番のプロフェッショナルになるのが大切だと思う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Google Omegaとは何か? Kubernetesとの関連は? 論文著者とのQA（翻訳）</title>
      <link>http://deeeet.com/writing/2015/09/17/qa-omega/</link>
      <pubDate>Thu, 17 Sep 2015 18:47:11 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/09/17/qa-omega/</guid>
      <description>

&lt;p&gt;エンタープライズ向けのKubernetesサポートを行っている&lt;a href=&#34;[https://kismatic.com/&#34;&gt;kismatic Inc.&lt;/a&gt;による&lt;a href=&#34;https://blog.kismatic.com/qa-with-malte-schwarzkopf-on-distributed-systems-orchestration-in-the-modern-data-center/&#34;&gt;&amp;ldquo;Omega, and what it means for Kubernetes: a Q&amp;amp;A about cluster scheduling&amp;rdquo;&lt;/a&gt;が非常に良いインタビュー記事だった．Google Omegaとは何か? 今までのスケジューリングと何が違うのか? 何を解決しようとしているのか? 今後クラスタのスケジューリングにはどうなっていくのか? をとてもクリアに理解することができた．&lt;/p&gt;

&lt;p&gt;自分にとってスケジューリングは今後大事になる分野であるし，勉強していきたい分野であるのでKismaticの&lt;a href=&#34;https://twitter.com/asynchio&#34;&gt;@asynchio&lt;/a&gt;氏と論文の共著者である&lt;a href=&#34;http://www.cl.cam.ac.uk/~ms705/&#34;&gt;Malte Schwarzkopf&lt;/a&gt;氏に許可をもらい翻訳させてもらった．&lt;/p&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;2013年に発表された&lt;a href=&#34;http://www.cl.cam.ac.uk/research/srg/netos/papers/2013-omega.pdf&#34;&gt;Omega論文&lt;/a&gt;の共著者である&lt;a href=&#34;http://www.cl.cam.ac.uk/~ms705/&#34;&gt;Malte Schwarzkopf&lt;/a&gt;がGoogle OmegaのShared-stateモデルの主な目的がScalabilityよりもむしろソフトウェア開発における柔軟性であったことを説明する．Shared-stateモデルによるスケジューリングは優先度をもったプリエンプションや競合を意識したスケジューリングを可能にする．&lt;/p&gt;

&lt;p&gt;今までのTwo-levelモデルのスケジューラー（例えば&lt;a href=&#34;http://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html&#34;&gt;YARN&lt;/a&gt;や&lt;a href=&#34;http://mesos.apache.org/&#34;&gt;Mesos&lt;/a&gt;）も同様の柔軟さを提供するが，Omega論文が発表された当時は，すべての状態がクラスタから観測できない問題（information hiding）や&lt;a href=&#34;https://en.wikipedia.org/wiki/Gang_scheduling&#34;&gt;Gang Scheduling&lt;/a&gt;におけるhoardingの問題に苦しんでいた．またなぜGoogleがShare-stateモデルを選択したのか，なぜGoogleは（Mesosのような）厳格な公平性をもったリソース配分を行わないのかについてもコメントする．&lt;/p&gt;

&lt;p&gt;最後にMesosや&lt;a href=&#34;http://kubernetes.io/&#34;&gt;kubernetes&lt;/a&gt;のようにスケジューラーのモジュール化をサポートすることでいかにOSSのクラスター管理にOmegaの利点を持ち込むことができるのかを議論する．そしてより賢いスケジューリングを実現することでユーザはGoogleのインフラと同様の効率性を獲得できること提案する．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2013年の論文の発表時と比べて何が変わったか? 何が変わらないか?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;クラスタのオーケストレーションは動きの早い分野である．しかしOmegaの中心となる原則はむしろよりタイムリーでとても重要であると思う．&lt;/p&gt;

&lt;p&gt;2013年以来の大きな変化として，とりわけKubernetesやMesosのおかげで，Omegaのようなクラスタでインフラを運用するのが一般的になってきたことが挙げられる．2011年や2012年に立ち返ってみるとOmegaのShared-stateモデルによるスケジューリングの基礎となる仮説をGoogle以外の環境で実証するのはなかなかトリッキーなことだとみなされていた．しかし今日では，既存のモジュラーなスケジューラーをハックして新しい手法を試したり，&lt;a href=&#34;https://github.com/google/cluster-data&#34;&gt;Google cluster trace&lt;/a&gt;の公開されたTrace結果を使うことでより簡単にそれができる．&lt;/p&gt;

&lt;p&gt;さらにOmegaで挑んだ，いかにクラスタ内で異なるタイプのタスクを効率良くスケジューリングするのか，いかに異なるチームがクラスタの全ての状態にアクセスし彼ら自身のスケジューラーを実装するのか，といった問題は業界で広く認識されてきた．コンテナにより多くの異なるタイプのアプリケーションを共有クラスタ内にデプロイすることが可能になり，開発者たちは全てのタスクを同じようにスケジューリングすることはできない/するべきではないことを認識し始めた．そしてオーケストレーション（例えばZookeeperやetcd）は共有された分散状態を管理する問題であるであるとみなされるようになった．&lt;/p&gt;

&lt;p&gt;Omegaのコアにある考え方，つまりジョブのスケジューリングのモデリングとShared-stateモデルに基づくより概括的なクラスタのオペレーションは，まだ適切であると信じている．実際Kubernetesの中心にある考え方，ユーザが望むべき状態を指定しKubernetesがクラスタをそのゴールの状態に移行させること，はまさにOmegaにおいてスケジューラーが次の望むべき状態にクラスタの状態の変更を提案するときに起こっていることと全く同じである．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;なぜOmegaのShared-stateモデルは柔軟性があり様々な異なるタスクのリソース管理を効率的に行うことができるのか?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数年前多くの組織が運用していたインフラ環境について考えてみる．例えば1つのHadoopクラスタで複数のユーザによるMapReduceジョブが走っていた．それは非常に簡単なスケジューリングである．全てのマシンにMapReduce worker用にn個のスロットがあり，スケジューラーはmapとreduceタスクを，その全てのスロットが埋まるまでもしくは全てのタスクがなくなるまで，ワーカーに割り当てる．&lt;/p&gt;

&lt;p&gt;しかし，このスロットという単位は非常に荒いスケジューリングの単位である．全てのMapReduceジョブが同じ量のリソースが必要であるわけではなく，全てのジョブが与えられたリソースを使い切るわけではない．実際クラスタのいくつかのサーバーではMapReduce以外のプロセスが動いている場合もある．そのためスロットという単位で静的にマシンのリソースを区切るのではなく，タスクを&lt;a href=&#34;https://en.wikipedia.org/wiki/Bin_packing_problem&#34;&gt;Bin-pack&lt;/a&gt;してリソースを最適化させるのはより良い考え方である．現代のほとんどのスケジューラーはこれを実現している．&lt;/p&gt;

&lt;p&gt;複数のリソース状況に基づく（複数次元の）Bin-packingは非常に難しい（NP完全問題である）．さらに異なるタイプのタスクはそれぞれ別のBin-packingの方法を好むため問題はより難しくなる．例えば，ネットワーク帯域が70%使われているマシンにMapReduceのジョブを割り当てるのは全く問題ないが，webサーバーのジョブをそのマシンに割り当てるのは好ましくない&amp;hellip;&lt;/p&gt;

&lt;p&gt;Omegaではそれぞれのスケジューラーは全ての利用可能なリソース，すでに動いているタスク，クラスタの負荷状況を見ることができ，それに基づきスケジューリングを行うことができる（Shared-stateモデル）．言い方を変えると，それぞれのスケジューラーは好きなBin-packingアルゴリズムを使うことができ，かつ全て同様の情報を共有している．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BorgはScalabilityに制限があるのか? OmegaはBorgの置き換えなのか?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;違う．論文でそれをよりクリアにできたらと思う．多くのフォローアップで「中央集権型のスケジューラーは巨大なクラスタに対してスケールできないため分散スケジューラーに移行するべきである」と述べられてきた．しかしOmegaの開発の主な目的はScalabilityではなくより柔軟なエンジニアリングにある．Omegaのゴールは，様々なチームが独立してスケジューラーを実装できることにあり，これはScalabilityよりも重要な側面だった．スケジューラーの並列化がもたらすScalabilityは付属の利点にすぎない．実際のところちゃんと開発された中央集権型のスケジューラーは巨大なクラスタとタスクを扱えるまでにスケールできる．Borg論文は実際この点について書いている．&lt;/p&gt;

&lt;p&gt;分散スケジューラーが必須になるニッチな状況もある．例えば，既存のワーカーに対して，レイテンシにセンシティブな短いリクエストを送るジョブを高速に配置する必要があるとき．これは&lt;a href=&#34;http://dl.acm.org/citation.cfm?id=2517349.2522716&#34;&gt;Sparrow scheduler&lt;/a&gt;のターゲットであり分散デザインが適切になる．しかしタスクがレイテンシにセンシティブ，もしくはタスクを秒間に数万回も配置する必要がなければ，中央集権型のスケジューラーであっても1万台のマシンを超えても問題ない．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Omega論文内で指摘しているMesosのTwo-levelモデルのスケジューリングの欠点は何か?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;まずOmega論文におけるMesosの説明は2012年当時のMesosに基づいている．それから数年が経っており，論文でのいくつかの指摘はすでに取組まれており，同じように語ることはできない．&lt;/p&gt;

&lt;p&gt;オファーベースのモデル，もしくは別のスケジューラーに対してクラスタ状態のサブセットのみを公開するモデルには大きく2つの欠点がある．これは例えばYARNのようなリクエストベースのデザインにも同様のことが言える．&lt;/p&gt;

&lt;p&gt;まず1つ目はスケジューラーが割り当てらてた/提供されたリソースのみを見ることができることに関連する．Mesosのオファーシステムにおいて，リソースマネージャーはアプケーションスケジューラーに対して「これだけのリソースがあるよ．どれが使いたい?」と尋ね，アプリケーションスケジューラーはその中から選択を行う．しかしそのときアプリケーションスケジューラーはに別の関連する情報を知ることができない．例えば，自分には提供されなかったリソースは誰が使っているのか，より好ましいリソースがあるのか（そのために提供されたリソースを拒否してより良いリソースを待ったほうがよいのか）という情報を知ることができない．これが&lt;strong&gt;information hiding&lt;/strong&gt;の問題である．information hidingによって問題になる他の例には優先度をもったプリエンプションがある．もし優先度の高いタスクが優先度の低いタスクを追い出すことができる必要があるとき，優先度の低いタスクが配置されるどの場所もまた効率的なリソースのオファーがある，がスケジューラーはそれをみることができない．&lt;/p&gt;

&lt;p&gt;もちろんこれは解くことができる問題である．例えばMesosは優先度の低いタスクに利用されているリソースを優先度の高いタスクに提供することができる．もしくはスケジューラーのフィルターでプリエンプション可能なリソースを指定することもできる．しかしこれはリソースマネージャーのAPIとロジックが複雑になる．&lt;/p&gt;

&lt;p&gt;2つ目は&lt;strong&gt;hoarding&lt;/strong&gt;の問題．これは特に&lt;a href=&#34;https://en.wikipedia.org/wiki/Gang_scheduling&#34;&gt;Gang Sheduling&lt;/a&gt;によりスケジューリングされたジョブに影響を与える．このようなジョブは他のジョブが起動する前にリクエストした全てのリソースを獲得しておかなければならない．例えばこのようなジョブにはMPIがあるが，他にもstatefulなストリーム処理は起動するためにパイプライン全体が確保されている必要がある．MesosのようなTwo-levelモデルではこれらのジョブには問題が生じる．アプリケーションスケジューラーは要求したリソースが全て揃うまで待つ（揃わないかもしれない）こともできるし，十分なリソースを蓄積するため少量のオファーを順番に受け入れることもできる．もし後者なら，しばらくの間他のジョブ（例えば優先度の低いMapReduceのジョブなど）に効率良く利用できる可能性があるのにも関わらず，十分な量のリクエストが受け入れられるまでリソースは使われることなく蓄積（hoarding）される．&lt;/p&gt;

&lt;p&gt;最近MesosphereでMesosの開発をしているBen Hindmanとこの問題ついて話したが，彼らはこれらを解決する並列のリソースオファー/予約が可能になるようにコアのオファーモデルを変更する計画があると話していた．例えば，Mesosは複数のスケジューラーに対して同じリソースを&lt;a href=&#34;https://issues.apache.org/jira/browse/MESOS-1607&#34;&gt;Optimistic&lt;/a&gt;に提供し，消失したスケジューラーのオファーを「無効にする」ことが可能になる．これはOmegaと同じ競合の解決が必要になる．その時点で2つのモデルは同じところに到達する．もしMesosがクラスタの全てのリソースをスケジューラーに提供するならそのスケジューラーはOmegaと同じ視点をもつことになる（詳しくは&lt;a href=&#34;https://issues.apache.org/jira/secure/attachment/12656071/optimisitic-offers.pdf&#34;&gt;&amp;ldquo;proposal: Mesos is isomorphic to Omega if makes offers for everything available&amp;rdquo;&lt;/a&gt;）．しかしまだ実装は初期段階にある．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MesosのTwo-levelモデルのスケジューリングはGoogleには適していないのか? クラスタの全てのリソースを全てのスケジューラーに共有するのはなぜ良いのか?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上で挙げた優先度をもったプリエンプションを例に考えてみる．Googleではより重要なタスクのために低い優先度のタスクが停止されるのは普通である．実際，巨大なMapReduceジョブを起動するといくつかのworkerがプリエンプションで失敗する．これは新しいより重要なジョブがあったか，もしくはそのジョブで利用されていた特定のリソースを他のタスクが必要とし（例えばGmailのようなサービスでスパイクがあり）Borgスケジューラーがそのタスクをプリエンプションの対象として選んだためである．しかしタスクを立ち退かせるためにはスケジューラーはそれらの状態を見る必要がある．例えばTwitterのHeronインスタンスは異なるフレームワークであってもHadoopやSparkのジョブを立ち退かせるということをしたい．&lt;/p&gt;

&lt;p&gt;Omega論文で述べた別の例を挙げると，静的にMapReduceジョブを分割するのではなくてクラスタのロードが低いときに動的に割り当てるリソースを増やしたい．なぜそのジョブはしっかり100のworkerを使う必要があるのか? それは単に人間が指定した数にすぎない．スケジューラーはある時間にどれだけの数のworkerを起動するべきがより良く理解できる．実際他のシステムも同様のアイディアを実現してきた．例えばMicrosoftの&lt;a href=&#34;https://kismatic.com/company/qa-with-malte-schwarzkopf-on-distributed-systems-orchestration-in-the-modern-data-center/&#34;&gt;Apolloスケジューラー&lt;/a&gt;はOpportunisticなタスクをサポートしており，&lt;a href=&#34;http://dl.acm.org/citation.cfm?id=2168847&#34;&gt;Jockey&lt;/a&gt;や&lt;a href=&#34;http://dl.acm.org/citation.cfm?id=2541941&#34;&gt;Quasar&lt;/a&gt;のようなresearch systemはAuto-sacalingは非常に大きな違いを生じさせることを示した．しかしそのような決定ができるためには，スケジューラーはクラスタ全体の状態がどうなっているかが見える必要がある．そのためオファーベースでTwo-levelモデルのデザインはGoogleでの要件に合わなかった．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MesosのDominant Resource Fairness（DRF）アルゴリズムについてはどう思うか? なぜGoogleは異なるアプローチを選択したのか?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(DRFアルゴリズムは非常に速くスケジューラーに対して1ms以下でリソースを提供することができMesosで使われている)&lt;/p&gt;

&lt;p&gt;GoogleがDRFアルゴリズムを採用していないのはアルゴリズムの複雑さやパフォーマンスとは全く関係ない．単にしっかりとした公平なリソース配分がGoogleの環境には必要ないだけである．より多くのタスクを終わらせ全体の最適化を行うためにリソースの配分を一時的に不公平にできる柔軟性をGoogleは評価している．もちろん偶然（もしくは故意に）大量のリソースを使って他のタスクが不利になることがないようにはしている．&lt;/p&gt;

&lt;p&gt;これは割り当てシステム（quota system）によって行われる．仮想的な通貨がリソースの購入と予算に使われる．もし高い優先度をもつ100のタスクをそれぞれ20GBのメモリを使って1時間稼働させたとすると，チームの口座から2000GB/hourが借りられることになる．もし貯金を使い果たすとチームは人に頼んで通貨を増やしてもらうか，タスクを終了させる方法を見つけなればならない．つまり1日で1月分の配分を使い果たすのは良い考えではなく，しんどくなる．Borg論文がこのquota systemについて詳しく解説している．&lt;/p&gt;

&lt;p&gt;しかしこのやり方はリソース配分の公平性についてより根本的な疑問を呈した．厳格な公平性をもつが使われていないリソースを放置するのか，より良い最適化やタスクのよりスムーズな終了が持ち込まれたときに一時的な不公平を許容するのか．答えは組織やタスクの種類による．Googleでは効率が厳格な公平性に勝った．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Omegaのような実装がOSSとして公開されることはあるのか?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;今すぐにはない．上で述べたようにOmegaはいくつかのOSSのプロジェクトに影響を与えている．第一にそしてより重要なのはもちろんKubernetesであり，BorgとOmega両方の影響を受けている．Kubernetesにおける重要なアイディアは，ユーザが自分のクラスタの望むべき状態を指定してクラスタマネージャーにそれを託すこと．これはOmegaのアプローチに非常に似ている．その意味でKubernetesはOmegaスタイルのスケジューラーを載せるのには理想的なプラットフォームであると言える．実際Kubernetesのスケジューラーはpluggableなコンポーネントになっているので実現性は高い．&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/docs/design/architecture.md&#34;&gt;ドキュメント&lt;/a&gt;には開発者は「将来的に複数のクラスタスケジューラーとユーザによるスケジューラーをサポートすることを期待している」とある．Kubernetesは完全にコンポーネント化されているので，複数のマスターコントローラーが複数のスケジューラーとやりとりする，もしくはアプリケーションに特化したReplication Controllerがアプリケーションに特化したスケジューラーにリクエストを投げるといった方法が想像できる．&lt;/p&gt;

&lt;p&gt;Omegaの影響を受けたスケジューラーは他にも存在する．例えばMicrosoft Researchは&lt;a href=&#34;http://msr-waypoint.com/pubs/238833/mercury-tr.pdf&#34;&gt;Mercury&lt;/a&gt;を作った．これは，もしかすると古いかもしれない情報に基づき分散で決定をするのか，正確な情報をもとに中央集権的に決定をするのかをタスクが選べるというハイブリッドなスケジューラーである．そのコードはYARNのupstreamに統合されている．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OmegaのようなShared-stateモデルのスケジューラーはkubernetesクラスタにおいても柔軟性や効率を改善することができるのか?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最近KubernetesとMesosをスケジューラーの観点から見てみたが，正直に言うと，GoogleがOmegaやBorgでやっているのと比較するととても単純である．しかしplugabbleなスケジューラーAPIにより最新かつより良いものに改良することができる．基礎はあるのでいろいろなことができる．&lt;/p&gt;

&lt;p&gt;例えばCambridgeでは本格的なスケジューラーマネージャーである&lt;a href=&#34;http://www.cl.cam.ac.uk/research/srg/netos/camsas/firmament/&#34;&gt;Firmament&lt;/a&gt;を研究のために開発した．それによりとても良い結果を得ることができたが，Kubernetesに組み込むことでその研究の成果は他の人たちにも簡単に利用可能になる．&lt;/p&gt;

&lt;p&gt;Share-stateなアプローチはKubernetesクラスタをさらに助けることになると思う．異なるタイプのアプリケーション異なるタイプのPodは異なった方法で配置する必要があり，それらを全てをkube-schdulerに統合するのは悪夢のようだ．そうではなく特別な目的をもった複数のスケジューラーを走らせることができればKubernetesにとって良いオプションになると思う．つまりより良い決定が可能になり，コードを綺麗にかつモジュール化することができる．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;クラスタのスケジューラーにおける他の課題は何か? 次に解くべき困難な問題は何か?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;コンテナもまた異なるタイプのクラスタを作ってきた．Kubernetesや他のコンテナオーケストレーションプラットフォーム（例えばMesosや&lt;a href=&#34;https://tectonic.com/&#34;&gt;Tectonic&lt;/a&gt;，&lt;a href=&#34;https://github.com/docker/machine&#34;&gt;Docker Machine&lt;/a&gt;）によって，MapReduceでmapタスクからネイティブプロセスを起動したり，特定のAPIのためにアプリケーションを再ビルドするといったことを複雑ことをせずに，異なるアプリケーションを同じクラスタ上で動かすことができるようになった．この結果として人々がより賢いスケジューリングに集中し始めることを期待している．今のところOSSではほとんどのプロジェクトがとにかく動かすということをやってきた．これはスケールするのは難しい．より良いスケジューリングの実現が次のハードルであると思う．&lt;/p&gt;

&lt;p&gt;いくつかの困難な課題を挙げる，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;負荷の高いマシンで&lt;strong&gt;co-location interferenceを避ける&lt;/strong&gt;のはとても重要である．貧弱なスケジューリングで特定のマシンのリソース（例えばディスクやネットワーク，L3キャッシュなど）を圧迫するとバッチタスクのパフォーマンスは簡単に悪化する．user-facingのサービスはより被害を被る（例えばレイテンシが非常に大きくなる）．コンテナはCPUやメモリの隔離を可能にするが，基本的にはまだ多くのリソースをk共有している．そのため，どのタスクが同居してよいか，どのタスクか別々になるべきかをよりうまく予測できる必要がある．&lt;/li&gt;
&lt;li&gt;Googleが&lt;strong&gt;&amp;ldquo;resource reclamation&amp;rdquo;&lt;/strong&gt;と呼んでいること，確保ししたが実際には使わなかった余剰のリソースを返還すること，をよりうまくできる必要がある．人間が慎重になりすぎること，アプリケーションに必要になるリソースを過度に見積もってしまうのはよく知られている．しかし良いスケジューラーであれば，あまり使われていないリソースを他の優先度の低いタスクに再配布することができる．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;柔軟性を高める&lt;/strong&gt;ことができると良い．スケジューラーにコンテナを停止させる，移動させる，そして自動的にスケールさせる．例えば，CPUが必要な他のコンテナに場所を譲るためにコンテナをプリエンプションして破棄するのではなくて，効率よく停止させるために優先度の低いコンテナを抑制することもできるが，メモリが圧迫されてなければRAMに状態を保持することもできる．&lt;/li&gt;
&lt;li&gt;スクラッチで自分用のスケジューラーを実装するのではなくて&lt;strong&gt;user-specifiedなスケジューリングポリシー&lt;/strong&gt;を簡単に持てると良い．現実的にはほとんどの組織，小さいもしくは伝統的な組織，にはpluggableのAPIが提供されていたとしてもスケジューラーを書くためのリソースはない．タスクやその組織のためのスケジューリングポリシーを考えることができるSREやDevOps的なエンジニアが必要である．そしてスケジューラーはリソース配分やContainer配置のAPIというよりも，そのポリシーを表現するためのプラットフォームにならなければならない．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述した&lt;a href=&#34;http://camsas.org/firmament&#34;&gt;Firmament&lt;/a&gt;においてこれらの課題のいくつかに挑んだ．例えばそのpluggableなコストモデルにより直感的な方法でスケジューリングのポリシーを簡単に指定することができる．そしてco-location interferenceが発生する前にそれをを避けるコストモデルも開発した．さらに巨大なスケール（数万台のマシン）でも特定のスケジューリングポリシーの最適な決定を非常に速く行うことができる可能性も示した．これらは非常に良いな結果であり，近い将来これについては詳しく述べる．しかし「Google&amp;rsquo;s infrastructure for everyone else」を実現するには多くのひとそして多くの素晴らしいアイディアが必要になる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apache Kafkaに入門した</title>
      <link>http://deeeet.com/writing/2015/09/01/apache-kafka/</link>
      <pubDate>Tue, 01 Sep 2015 18:13:38 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/09/01/apache-kafka/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://kafka.apache.org/&#34;&gt;Apache kafka&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最近仕事で&lt;a href=&#34;http://kafka.apache.org/&#34;&gt;Apache Kafka&lt;/a&gt;の導入を進めている．Kafkaとは何か? どこで使われているのか? どのような理由で作られたのか? どのように動作するのか（特にメッセージの読み出しについて）? を簡単にまとめておく（メッセージングはまだまだ勉強中なのでおかしなところがあればツッコミをいただければ幸いです）．&lt;/p&gt;

&lt;p&gt;バージョンは &lt;em&gt;0.8.2&lt;/em&gt; を対象に書いている．&lt;/p&gt;

&lt;h2 id=&#34;apache-kafkaとは&#34;&gt;Apache Kafkaとは?&lt;/h2&gt;

&lt;p&gt;2011年に&lt;a href=&#34;https://www.linkedin.com/&#34;&gt;LinkedIn&lt;/a&gt;から公開されたオープンソースの分散メッセージングシステムである．Kafkaはウェブサービスなどから発せられる大容量のデータ（e.g., ログやイベント）を高スループット/低レイテンシに収集/配信することを目的に開発されている．公式のトップページに掲載されているセールスポイントは以下の4つ．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Fast&lt;/strong&gt; とにかく大量のメッセージを扱うことができる&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scalable&lt;/strong&gt; Kafkaはシングルクラスタで大規模なメッセージを扱うことができダウンタイムなしでElasticかつ透過的にスケールすることができる&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Durable&lt;/strong&gt; メッセージはディスクにファイルとして保存され，かつクラスタ内でレプリカが作成されるためデータの損失を防げる（パフォーマンスに影響なくTBのメッセージを扱うことができる）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distributed by Design&lt;/strong&gt; クラスタは耐障害性のある設計になっている&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;どこで使われているのか&#34;&gt;どこで使われているのか?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://kafka.apache.org/documentation.html#uses&#34;&gt;Use Cases&lt;/a&gt;をあげると，メッセージキューやウェブサイトのアクティビティのトラッキング（LinkedInのもともとのUse Case），メトリクスやログの収集，&lt;a href=&#34;https://storm.apache.org/&#34;&gt;Storm&lt;/a&gt;や&lt;a href=&#34;http://samza.apache.org/&#34;&gt;Samza&lt;/a&gt;を使ったストリーム処理などがあげられる．&lt;/p&gt;

&lt;p&gt;利用している企業は例えばTwitterやNetflix，Square，Spotify，Uberなどがある（cf. &lt;a href=&#34;https://cwiki.apache.org/confluence/display/KAFKA/Powered+By&#34;&gt;Powered By&lt;/a&gt;）．&lt;/p&gt;

&lt;h2 id=&#34;kafkaの初期衝動&#34;&gt;Kafkaの初期衝動&lt;/h2&gt;

&lt;p&gt;Kafkaのデザインを理解するにはLinkedInでなぜKafkaが必要になったのかを理解するのが早い．それについては2012年のIEEEの論文&lt;a href=&#34;http://sites.computer.org/debull/A12june/pipeline.pdf&#34;&gt;&amp;ldquo;Building LinkedIn&amp;rsquo;s Real-time Activity Data Pipeline&amp;rdquo;&lt;/a&gt;を読むのが良い．簡単にまとめると以下のようになる．&lt;/p&gt;

&lt;p&gt;LinkedInでは大きく2つのデータを扱っている．1つはウェブサイトから集められる大量のユーザのアクティビティデータ．これらをHadoop（バッチ処理）を通して機械学習しレコメンド/ニュースフィードなどサービスの改善に用いている．それだけではなくこれらのデータはサービスの監視（セキュリティなど）にも用いている．2つ目はシステムのログ．これらをリアルタイムで処理してサービスのモニタリングを行っている．これらは近年のウェブサービスではよく見かける風景．&lt;/p&gt;

&lt;p&gt;問題はそれぞれのデータの流れが1本道になっていたこと．アクティビティデータはバッチ処理に特化していたためリアルタイム処理ができない，つまりサービス監視には遅れが生じていた．同様にシステムのログは，リアルタイム処理のみに特化していたため長期間にわたるキャパシティプランニングやシステムのデバッグには使えなかった．サービスを改善するにはそれぞれタイプの異なるデータフィードを最小コストで統合できるようにする必要があった．またLinkedInのようにデータがビジネスのコアになる企業ではそのデータを様々なチームが簡単に利用できる必要があった．&lt;/p&gt;

&lt;p&gt;これら問題を解決するために大ボリュームのあらゆるデータを収集し様々なタイプのシステム（バッチ/リアルタイム）からそれを読めるようにする統一的ななメッセージプラットフォームの構築が始まった．&lt;/p&gt;

&lt;p&gt;最初は既存のメッセージシステム（論文にはActiveMQを試したとある）の上に構築しようとした．しかしプロダクションレベルのデータを流すと以下のような問題が生じた．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;並列でキューのメッセージを読むにはメッセージごとに誰に読まれたかを記録する必要がある（mutex）．そのため大量のデータを扱うとメモリが足りなくなった．メモリが足りなくなると大量のRamdom IOが発生しパフォーマンスに深刻な影響がでた&lt;/li&gt;
&lt;li&gt;バッチ処理/リアルタイム処理の両方でキューを読むには少なくとも2つのデータのコピーが必要になり非効率になった&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このような問題から新しいメッセージシステム，Kafkaの開発が必要になった．Kafkaが目指したのは以下．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;あらゆる種類のデータ/大容量のデータを統一的に扱う&lt;/li&gt;
&lt;li&gt;様々なタイプのシステム（バッチ/リアルタイム）が同じデータを読める&lt;/li&gt;
&lt;li&gt;高スループットでデータを処理する（並列でデータを読める）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;どのように動作するのか-概要&#34;&gt;どのように動作するのか?（概要）&lt;/h2&gt;

&lt;p&gt;KafkaはBroker（クラスタ）とProducer，Consumerという3つのコンポーネントで構成される．Producerはメッセージの配信を行いConsumerはメッセージの購読を行う．そしてKafkaのコアであるBrokerはクラスタを構成しProducerとConsumerの間でメッセージの受け渡しを行うキューとして動作する．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kafka.apache.org/images/producer_consumer.png&#34; /&gt;
&lt;a href=&#34;http://kafka.apache.org/images/producer_consumer.png&#34;&gt;http://kafka.apache.org/images/producer_consumer.png&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;メッセージのやりとり&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;KafkaはTopicを介してメッセージのやりとりを行う．Topicとはメッセージのフィードのようなものである．例えば，検索に関わるデータを&amp;rdquo;Search&amp;rdquo;というTopic名でBrokerに配信しておき，検索に関わるデータが欲しいConsumerは&amp;rdquo;Search&amp;rdquo;というTopic名を使ってそれをBrokerから購読する．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pull vs Push&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;BrokerがConsumerにデータをPushするのか（fluentd，logstash，flume），もしくはConsumerがBrokerからデータをPullするのかはメッセージシステムのデザインに大きな影響を与える．もちろんそれぞれにPros/Consはある．KafkaはPull型のConsumerを採用している．それは以下の理由による．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pushだと様々なConsumerを扱うのが難しく，Brokerがデータの転送量などを意識しないといけない．Kafkaの目標は最大限のスピードでデータを消費することだが，（予期せぬアクセスなどで）転送量を見誤るとConsumerを圧倒してまう．PullだとConsumerが消費量を自らが管理できる．&lt;/li&gt;
&lt;li&gt;Pullだとバッチ処理にも対応できる．Pushだと自らそれを溜め込んだ上でConsumerがそれを扱えるか否かに関わらずそれを送らないといけない&lt;/li&gt;
&lt;li&gt;(PullでしんどいのはBrokerにデータがまだ届いてない場合のコストだがlong pollingなどでそれに対応している)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;メッセージのライフサイクル&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;BrokerはConsumerがメッセージを購読したかに関わらず設定された期間のみ保持してその後削除する．これはKafkaの大きな特徴の1つである．例えば保存期間を2日間に設定すれば配信後2日間のみデータは保持されその後削除される．&lt;/p&gt;

&lt;p&gt;このためConsumerサイドがメッセージをどこまで読んだがを自らが管理する（Brokerが管理する必要がない）．普通は順番にメッセージを読んでいくが，Consumerに問題があれば読む位置を巻き戻して復旧することもできる（最悪どれくらいでConsumerを復旧できるかによりデータの保存期間が決まり保持するデータのサイズが決まる）．&lt;/p&gt;

&lt;p&gt;この2つの特徴のためConsumerはBrokerにも他のBrokerにも大きな影響を与えない．&lt;/p&gt;

&lt;h2 id=&#34;高速にメッセージを消費する&#34;&gt;高速にメッセージを消費する&lt;/h2&gt;

&lt;p&gt;Kafkaで面白いのはConsumerがBrokerから高速にメッセージを読み込むための仕組みであると思う．これをどのように実現しているかを説明する．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;並列でキューを読むのは大変&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;高速にメッセージを消費するにはBrokerのデータを並列に読む必要がある．そもそも&amp;rdquo;初期衝動&amp;rdquo;のところで説明したように複数のConsumerが並列でキューを読むのは大変である．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;重複なく送るためにはメッセージごとにどのConsumerに読まれたかを管理する必要がある&lt;/li&gt;
&lt;li&gt;キューの書き込みまでは順序性が確保されるが並列で読むと複数のConsumerに消費された瞬間順序は失われる&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kafkaのデザインはこれらを解決するようになっている．&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Brokerにおけるメッセージの保存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;まずBrokerのメッセージの保存方法に特徴がある．KafkaはTopicごとに1つ以上のPartitionという単位でメッセージを保存する．メッセージはそれぞれのPartitionの末尾に追記される．これによりPartitionごとにメッセージの順序性が担保される．例えば以下の図はあるTopicの3つのPartitionにメッセージが追記されていることを示す．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kafka.apache.org/images/log_anatomy.png&#34; /&gt;
&lt;a href=&#34;http://kafka.apache.org/images/log_anatomy.png&#34;&gt;http://kafka.apache.org/images/log_anatomy.png&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Partitionの使われ方&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Partitionには大きく以下の2つの目的がある．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;複数のサーバーでメッセージを分散させるため（1つのサーバーのキャパを超えてメッセージを保存できる）&lt;/li&gt;
&lt;li&gt;並列処理のため&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;どのように並列処理するか? Consumerはグループ単位でメッセージを購読する．そして&amp;rdquo;1つのPartitionのデータは1つのConsumerグループ内の1つのConsumerにのみ消費される&amp;rdquo;という制限でこれを実現する（つまりConsumerの並列数はPartition数を超えられない）．以下の図は2つのConsumerグループAとBに属する複数のConsumerが並列にメッセージを購読している様子を示す．グループ内では並列処理だがグループ間で見ると伝統的なPub/Subモデル（1対1）のモデルに見える．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://kafka.apache.org/images/consumer-groups.png&#34;/&gt;
&lt;a href=&#34;http://kafka.apache.org/images/consumer-groups.png&#34;&gt;http://kafka.apache.org/images/consumer-groups.png&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;この仕組みには以下のような利点がある．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;あるPartitionを読むConsumerは特定の1つなので，メッセージが誰にどこまで読まれたかまで記録する必要はなくて，単純にどこまで読まれたかを通知しておけばよい&lt;/li&gt;
&lt;li&gt;読んでるConsumerは1つなのでConsumerはlazyに読んだ場所を記録しておけばよくて処理に失敗したら再びよみにいけば良い（at-least-once）&lt;/li&gt;
&lt;li&gt;どのメッセージが読まれたかをlazilyに記録できるためにパフォーマンスを保証できる（Partitionのオーナーを同じように決められ無い場合はスタティックにConsumerを割り当てるか/ランダムにConsumerをロードバランスするしか無い．ランダムにやると複数のプロセスが同時に同じPartitionを購読するのでmutexが必要になりBrokerの処理が重くなる）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;順序性の補足&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Partition内，つまりConsumer内では順序性が確保される．つまりBrokerに記録された順番で消費される．がPartition間では保証されない．&lt;/p&gt;

&lt;p&gt;ProducerはBrokerにメッセージを配信するときにKeyを指定することができる．このKeyにより同じKeyが指定されたメッセージを同じPartitionに保存することができる．Partition内の順序性とKeyで大抵のアプリケーションには問題ない（とのこと）．完全な順序性を確保したければPartitionを1つにすれば良い（Consumerも一つになってしまうが）．&lt;/p&gt;

&lt;h2 id=&#34;高スループットへの挑戦&#34;&gt;高スループットへの挑戦&lt;/h2&gt;

&lt;p&gt;Brokerへの書き込み/読み込みはとにかく速い．LinkedInのベンチマークでは200万 write/sec（&lt;a href=&#34;https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines&#34;&gt;Benchmarking Apache Kafka: 2 Million Writes Per Second (On Three Cheap Machines)&lt;/a&gt;）とある．なぜこれだけ速いのか．以下の2つを組み合わせることにより実現している．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;write&lt;/strong&gt; バッファ書き込みを自分たちで実装するのではなくてカーネルのメモリキャシュ機構をがっつり使うようにした（Brokerが動いているサーバーのメモリ32GBのうち28-30GBがキャッシュに使われている）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;read&lt;/strong&gt; ページキャッシュからネットワークのsocketへ効率よくデータを受け渡すために&lt;code&gt;sendfile()&lt;/code&gt;を使ってる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;先に紹介した論文&lt;a href=&#34;http://sites.computer.org/debull/A12june/pipeline.pdf&#34;&gt;&amp;ldquo;Building LinkedIn&amp;rsquo;s Real-time Activity Data Pipeline&amp;rdquo;&lt;/a&gt;は他にも面白いことがたくさん書いてあるのでKafkaを使おうとしているひとはぜひ一度目を通してみるといいと思う．&lt;/p&gt;

&lt;p&gt;次回はGo言語を使ってProducerとConsumerを実装する話を書く．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sites.computer.org/debull/A12june/pipeline.pdf&#34;&gt;Building LinkedIn&amp;rsquo;s Real-time Activity Data Pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/Apache-Kafka%E5%85%A5%E9%96%80-%E4%BC%8A%E6%A9%8B-%E6%AD%A3%E7%BE%A9-ebook/dp/B00JU43ONW&#34;&gt;Apache Kafka入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;（&lt;a href=&#34;http://www.confluent.io/blog/apache-kafka-samza-and-the-unix-philosophy-of-distributed-data&#34;&gt;&amp;ldquo;Apache Kafka, Samza, and the Unix Philosophy of Distributed Data&amp;rdquo;&lt;/a&gt;はApache KafkaをUnix哲学/パイプという観点から説明していてわかりやすい）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/miguno/apache-kafka-08-basic-training-verisign&#34;&gt;Apache Kafka 0.8 basic training - Verisign&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines&#34;&gt;Benchmarking Apache Kafka: 2 Million Writes Per Second (On Three Cheap Machines)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://kimutansk.hatenablog.com/entry/20130703/1372803004&#34;&gt;Apache Kafka 0.8.0の新機能／変更点 - 夢とガラクタの集積場&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/jp/news/2014/01/apache-afka-messaging-system&#34;&gt;Apache Kafka, 他とは異なるメッセージングシステム&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://techblog.yahoo.co.jp/programming/storm/&#34;&gt;StormとKafkaによるリアルタイムデータ処理 - Yahoo! JAPAN Tech Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>1コマンドでkubernetesを立ち上げるboot2kubernetesというツールをつくった</title>
      <link>http://deeeet.com/writing/2015/08/17/boot2kubernetes-jp/</link>
      <pubDate>Mon, 17 Aug 2015 23:47:14 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/08/17/boot2kubernetes-jp/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/tcnksm/boot2kubernetes&#34;&gt;tcnksm/boot2kubernetes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://googlecloudplatform.blogspot.jp/2015/07/Kubernetes-V1-Released.html&#34;&gt;kubernetes 1.0がリリースされた&lt;/a&gt;．これから実際に試す機会も増えそうなのでDockerを使って簡単に（1コマンドで）kubernetesクラスタを立てるコマンドをつくった．&lt;/p&gt;

&lt;h2 id=&#34;デモ&#34;&gt;デモ&lt;/h2&gt;

&lt;p&gt;以下はOSX上でシングルNodeのkubernetesクラスタを立てて&lt;code&gt;kubectl&lt;/code&gt;でリクエストを投げるデモ．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/boot2k8s.gif&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;使い方&#34;&gt;使い方&lt;/h2&gt;

&lt;p&gt;以下のコマンドでクラスタを立ち上げる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ boot2k8s up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドで必要なDockerイメージがPullされコンテナが起動する．boot2docker上でDockerを動かしている場合ローカルから&lt;code&gt;kubectl&lt;/code&gt;でクラスタにアクセスするにはport forwardが必要になる．その場合&lt;code&gt;boot2k8s&lt;/code&gt;はport forwardサーバーも同時に起動する．&lt;/p&gt;

&lt;p&gt;終了する（コンテナを削除する）には以下を実行する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ boot2k8s destroy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;boot2k8s&lt;/code&gt;が立ち上げたkubernetesコンテナとkubernetesによって立ち上げられたpodを削除することができる．&lt;/p&gt;

&lt;h2 id=&#34;インストール&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;OSXの場合はHomebrewでインストールできる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ brew tap tcnksm/boot2k8s
$ brew install boot2k8s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他のプラットフォームの場合は&lt;a href=&#34;https://github.com/tcnksm/boot2kubernetes/releases&#34;&gt;リリースページ&lt;/a&gt;にバイナリがある．&lt;/p&gt;

&lt;h2 id=&#34;内部の実装&#34;&gt;内部の実装&lt;/h2&gt;

&lt;p&gt;Dockerを使ってシングルNodeのKubernetesクラスタをローカル開発環境に立てる方法はkubernetesの公式が提供している（cf. &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.0/docs/getting-started-guides/docker.md&#34;&gt;Running Kubernetes locally via Docker&lt;/a&gt;）．基本はこのドキュメントとやっていることは同じで，面倒な部分を含めて全てを1つのコマンドにまとめている．&lt;/p&gt;

&lt;p&gt;同じように1コマンドでKubernetesクラスタを立ち上げる試みとして&lt;a href=&#34;http://sebgoa.blogspot.jp/2015/04/1-command-to-kubernetes-with-docker.html&#34;&gt;&amp;ldquo;1 command to Kubernetes with Docker compose&amp;rdquo;&lt;/a&gt;がある．これは&lt;code&gt;docker-compose&lt;/code&gt;を使っている．同様に&lt;code&gt;boot2k8s&lt;/code&gt;は&lt;code&gt;docker-compose&lt;/code&gt;のGo言語実装である&lt;a href=&#34;https://github.com/docker/libcompose&#34;&gt;libcompose&lt;/a&gt;をライブラリとして利用して複数コンテナを立ち上げている（&lt;code&gt;boot2k8s&lt;/code&gt;のcomposeファイルは&lt;a href=&#34;https://github.com/tcnksm/boot2kubernetes/blob/0.1.0/config/k8s.yml&#34;&gt;k8s.yml&lt;/a&gt;にあるので&lt;code&gt;docker-compose&lt;/code&gt;のみを使いたい人はこれをそのまま利用できる）．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;boot2k8s&lt;/code&gt;は&lt;a href=&#34;https://github.com/jteeuwen/go-bindata&#34;&gt;go-bindata&lt;/a&gt;でcomposeファイルをbyteとして埋め込み&lt;code&gt;libcompose&lt;/code&gt;で起動する．コードで示すと以下のようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// Read .yml file as bytes by go-bindata
compose, _ := config.Asset(&amp;quot;k8s.yml&amp;quot;)

// Setup new docker-compose project
context := &amp;amp;docker.Context{
    Context: project.Context{
        ComposeBytes: compose,
        ProjectName:  &amp;quot;boot2k8s&amp;quot;,
    },
}

project, _ := docker.NewProject(context)

project.Up()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;boot2k8s&lt;/code&gt;の利点はport forwardingやコンテナの削除機能を持っていることが挙げられる．さらに今後はDocker machineと連携して様々な環境でkubernetesを簡単に立ち上げられるようにする予定．&lt;/p&gt;

&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;

&lt;p&gt;バグや意見はGitHubの&lt;a href=&#34;https://github.com/tcnksm/boot2kubernetes/issues&#34;&gt;Issue&lt;/a&gt;，もしくは&lt;a href=&#34;https://twitter.com/deeeet&#34;&gt;@deeeet&lt;/a&gt;までお願いします．&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/rrreeeyyy&#34;&gt;@rrreeeyyy&lt;/a&gt;くんに事前に意見をもらいました．ありがとう．&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sebgoa.blogspot.jp/2015/04/1-command-to-kubernetes-with-docker.html&#34;&gt;&amp;ldquo;1 command to Kubernetes with Docker compose&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rancher.com/our-journey-with-docker-compose-and-the-introduction-of-libcompose/&#34;&gt;&amp;ldquo;Libcompose and our journey with Docker Compose&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Go1.5はクロスコンパイルがより簡単</title>
      <link>http://deeeet.com/writing/2015/07/22/go1_5-cross-compile/</link>
      <pubDate>Wed, 22 Jul 2015 09:54:57 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/07/22/go1_5-cross-compile/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dave.cheney.net/2015/03/03/cross-compilation-just-got-a-whole-lot-better-in-go-1-5&#34;&gt;Cross compilation just got a whole lot better in Go 1.5 | Dave Cheney&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@rakyll/go-1-5-cross-compilation-488092ba44ec&#34;&gt;Go 1.5: Cross compilation — Medium&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go言語の良さの一つにあらゆるOS/Archに対するクロスコンパイルがとても簡単に行えることが挙げられる．今まで（Go1.4以前）も十分に便利だったが&lt;a href=&#34;http://tip.golang.org/doc/go1.5&#34;&gt;Go 1.5&lt;/a&gt;ではさらに良くなる．&lt;/p&gt;

&lt;p&gt;今までの問題を敢えて挙げるとターゲットとするプラットフォーム向けのビルドtool-chain準備する必要があるのが煩雑であった（cf. &lt;a href=&#34;http://qiita.com/Jxck_/items/02185f51162e92759ebe&#34;&gt;Go のクロスコンパイル環境構築 - Qiita&lt;/a&gt;）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd $(go env GOROOT)/src
$ GOOS=${TARGET_OS} GOARCH=${TARGET_ARCH} ./make.bash --no-clean 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ gox -build-toolchain 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この作業は1つの環境で一度だけ行えばよいのでそれほど煩雑ではない．しかし，例えばDockerなどでクロスコンパイル環境を提供すると（e.g., &lt;a href=&#34;https://github.com/tcnksm/dockerfile-gox&#34;&gt;tcnksm/dockerfile-gox&lt;/a&gt;），ビルドに時間がかかったりイメージが無駄に重くなったりという問題がおこる．初めてクロスコンパイルをしようとするひとにとってもつまづいてしまうポイントだったと思う．&lt;/p&gt;

&lt;p&gt;Go1.5ではコンパイラがGoで書き直された（cf. &lt;a href=&#34;http://talks.golang.org/2015/gogo.slide#1&#34;&gt;Go in Go&lt;/a&gt;）ため，この準備作業が不要になる．&lt;code&gt;go&lt;/code&gt;はコンパイル前に必要な標準パッケージを検出しそれらをターゲットのプラットフォーム向けにビルドしてくれる．&lt;/p&gt;

&lt;h2 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h2&gt;

&lt;p&gt;Go1.5を準備する．Go1.5のビルドにはGo1.4が必要．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://go.googlesource.com/go $HOME/go1.5
$ cd $HOME/go1.5 &amp;amp;&amp;amp; git checkout -b 1.5 refs/tags/go1.5beta2
$ cd $HOME/go1.5/src &amp;amp;&amp;amp; GOROOT_BOOTSTRAP=$HOME/go1.4/ ./make.bash
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export PATH=$HOME/go1.5/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mitchellh/gox&#34;&gt;mitchellh/gox&lt;/a&gt;を使ってみる．toolchainの準備なしにすぐに使える．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go get github.com/mitchellh/gox
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd $GOPATH/src/github.com/tcnksm/hello
$ gox
Number of parallel builds: 4

--&amp;gt;       linux/arm: github.com/tcnksm/hello
--&amp;gt;      darwin/386: github.com/tcnksm/hello
--&amp;gt;       linux/386: github.com/tcnksm/hello
--&amp;gt;       plan9/386: github.com/tcnksm/hello
--&amp;gt;     freebsd/386: github.com/tcnksm/hello
--&amp;gt;   freebsd/amd64: github.com/tcnksm/hello
--&amp;gt;     openbsd/386: github.com/tcnksm/hello
--&amp;gt;   openbsd/amd64: github.com/tcnksm/hello
--&amp;gt;     windows/386: github.com/tcnksm/hello
--&amp;gt;   windows/amd64: github.com/tcnksm/hello
--&amp;gt;     freebsd/arm: github.com/tcnksm/hello
--&amp;gt;      netbsd/386: github.com/tcnksm/hello
--&amp;gt;    netbsd/amd64: github.com/tcnksm/hello
--&amp;gt;      netbsd/arm: github.com/tcnksm/hello
--&amp;gt;     linux/amd64: github.com/tcnksm/hello
--&amp;gt;    darwin/amd64: github.com/tcnksm/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちなみに上の例はcgoが必要ない場合，cgoが必要な場合は&lt;code&gt;CC&lt;/code&gt;と&lt;code&gt;CXX&lt;/code&gt;環境変数でCとC++のコンパイラを指定することができる（cf. &lt;a href=&#34;https://medium.com/@rakyll/go-1-5-cross-compilation-488092ba44ec&#34;&gt;Go 1.5: Cross compilation&lt;/a&gt;）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ CGO_ENABLED=1 CC=android-armeabi-gcc CXX=android-armeabi-g++ GOOS=android GOARCH=arm GOARM=7 go build .
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;留意事項&#34;&gt;留意事項&lt;/h2&gt;

&lt;p&gt;(2015年8月7日追記)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-v&lt;/code&gt; オプションをつけてクロスコンパイルをするとわかるが毎回ターゲットプラットホーム向けに標準ライブラリをビルドするためコンパイル時間は長くなる（cf &lt;a href=&#34;https://twitter.com/upthecyberpunks/status/629092265391095809&#34;&gt;&amp;ldquo;https://twitter.com/upthecyberpunks/status/629092265391095809&amp;rdquo;&lt;/a&gt;）．同じ環境で使い回すならば今まで通り標準パッケージを事前にビルドしておくと良い．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ env GOOS=linux GOARCH=amd64 go install std
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>