<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Writings on SOTA</title>
    <link>http://deeeet.com/writing/</link>
    <description>Recent content in Writings on SOTA</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>Copyright (C) 2013-2015 Taichi Nakashima All Right Reserved.</copyright>
    <lastBuildDate>Tue, 01 Nov 2016 11:42:19 +0900</lastBuildDate>
    <atom:link href="http://deeeet.com/writing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>GolangでAPI Clientを実装する</title>
      <link>http://deeeet.com/writing/2016/11/01/go-api-client/</link>
      <pubDate>Tue, 01 Nov 2016 11:42:19 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/11/01/go-api-client/</guid>
      <description>

&lt;p&gt;特定のAPIを利用するコマンドラインツールやサービスを書く場合はClientパッケージ（SDKと呼ばれることも多いが本記事ではClientと呼ぶ）を使うことが多いと思う．広く使われているサービスのAPIであれば大抵はオフィシャルにClientパッケージが提供されている．例えば以下のようなものが挙げられる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/aws/aws-sdk-go&#34;&gt;https://github.com/aws/aws-sdk-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Azure/azure-sdk-for-go&#34;&gt;https://github.com/Azure/azure-sdk-for-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/PagerDuty/go-pagerduty&#34;&gt;https://github.com/PagerDuty/go-pagerduty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hashicorp/atlas-go&#34;&gt;https://github.com/hashicorp/atlas-go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特別使いにくい場合を除けば再実装は避けオフィシャルに提供されているものを使ってしまえばよいと思う（まともなものなら互換性などをちゃんと考慮してくれるはずなので）．一方で小さなサービスや社内のサービスの場合はClientは提供されておらず自分で実装する必要がある．&lt;/p&gt;

&lt;p&gt;自分はこれまでいくつかのAPI client パッケージを実装してきた．本記事ではその実装の自分なりの実装パターン（各人にやりかたはあると思う）といくつかのテクニックを紹介する．&lt;/p&gt;

&lt;h2 id=&#34;clientとは何か&#34;&gt;Clientとは何か?&lt;/h2&gt;

&lt;p&gt;API ClientとはAPIのHTTPリクエストを（言語の）メソッドの形に抽象化したものである．例えば  &lt;a href=&#34;https://api.example.com/users&#34;&gt;https://api.example.com/users&lt;/a&gt; というエンドポイントからユーザ一覧を取得できるとする．API Clientは具体的なHTTPリクエスト（メソッドやヘッダの設定，認証など）を抽象化し &lt;code&gt;ListUsers()&lt;/code&gt;のようなメソッドに落とし込んでその機能を提供する．&lt;/p&gt;

&lt;h2 id=&#34;なぜ-client-を書くべきか&#34;&gt;なぜ Client を書くべきか?&lt;/h2&gt;

&lt;p&gt;そもそも共通化できることが多いため．それぞれのリクエストは独立していても例えばユーザ名やパスワード，Tokenなどは基本は同じものを使うし，ヘッダの設定なども共通して行える．またテストも書きやすくなる．&lt;/p&gt;

&lt;h2 id=&#34;いつclientを書くべきか&#34;&gt;いつClientを書くべきか?&lt;/h2&gt;

&lt;p&gt;複数のエンドポイントに対してリクエストを投げる必要がある場合はClientを書いてしまえばいいと思う．例えば，単一のエンドポイントに決まったリクエストを投げるだけであればClientをわざわざ書く必要はない．自分の場合は3つ以上エンドポイントがあればClientをさっと書いていると思う．&lt;/p&gt;

&lt;h2 id=&#34;基本的な実装パターン&#34;&gt;基本的な実装パターン&lt;/h2&gt;

&lt;p&gt;以下では &lt;a href=&#34;https://api.example.com&#34;&gt;https://api.example.com&lt;/a&gt; （存在しない）のAPI Client パッケージを実装するとする．このAPIでは&lt;code&gt;/users&lt;/code&gt;というパスでユーザの作成と取得，削除が可能であるとする．また各リクエストにはBasic認証が必要であるとする．&lt;/p&gt;

&lt;h3 id=&#34;パッケージの名前をつける&#34;&gt;パッケージの名前をつける&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/effective_go.html#package-names&#34;&gt;https://golang.org/doc/effective_go.html#package-names&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上のEffective Goにも書かれているようにパッケージ名は shortかつconciseかつevocativeのものを選択する．API Clientであればそのサービス名がそのままパッケージ名になると思う．例えば PagerDutyであれば &lt;code&gt;pagerduty&lt;/code&gt;がパッケージ名になる．&lt;/p&gt;

&lt;p&gt;名前については以下でもいくつか述べる．&lt;/p&gt;

&lt;h3 id=&#34;client-struct-を定義する&#34;&gt;Client（struct）を定義する&lt;/h3&gt;

&lt;p&gt;まずは&lt;code&gt;Client&lt;/code&gt; structを実装する．&lt;code&gt;Client&lt;/code&gt;のフィールドにはリクエスト毎に共通に利用する値を持たせるようにする．HTTP APIの場合は例えば以下のようなものが考えられる:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;url.URL&lt;/code&gt; - リクエスト毎にパスは異なるがベースのドメインは基本的には共通になる．例えば今回の場合は &lt;a href=&#34;https://api.example.com&#34;&gt;https://api.example.com&lt;/a&gt; は共通である&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http.Client&lt;/code&gt; - 各HTTP リクエストには&lt;code&gt;net/http&lt;/code&gt;パッケージの&lt;code&gt;Client&lt;/code&gt;を用いる．これは同じものを使い回す&lt;/li&gt;
&lt;li&gt;認証情報 - 認証に利用する情報も基本的には同じになる．例えば今回の場合はBasic認証に必要なユーザ名とパスワードは共通である．他にもTokenなどが考えられる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;log.Logger&lt;/code&gt; - デバッグの出力も共通である．自分はグローバルな&lt;code&gt;log&lt;/code&gt;を使うよりも明示的に指定するのを好む&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の場合は以下のように実装できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Client struct {
    URL        *url.URL
    HTTPClient *http.Client

    Username, Password string

    Logger *log.Logger
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;importのように関連するフィールドでグールピングして記述しておくと読みやすい．&lt;/p&gt;

&lt;p&gt;また名前は&lt;code&gt;Client&lt;/code&gt;で十分である．例えばPagerDutyのAPI Clientを書いているときに&lt;code&gt;PagerDutyClient&lt;/code&gt;という名前にしない．上述したように既にそれはパッケージ名で説明されるはずである．&lt;code&gt;pagerduty.PagerDutyClient&lt;/code&gt;では冗長になる．簡潔な名前を心がける．&lt;/p&gt;

&lt;h3 id=&#34;コンストラクタを実装する&#34;&gt;コンストラクタを実装する&lt;/h3&gt;

&lt;p&gt;次に&lt;code&gt;Client&lt;/code&gt;のコンストラクタを定義する．例えば今回の場合は以下のようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func NewClient(urlStr, username, password string, logger *log.Logger) (*Client, error) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタ内では必須の情報が与えられているか，その値は期待するものかをチェックし，そうでなければエラーを返す（以下では&lt;code&gt;pkg/errros&lt;/code&gt;を使っている）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;if len(username) == 0 {
    return nil, errors.New(&amp;quot;missing  username&amp;quot;)
}

if len(password) == 0 {
    return nil, errors.New(&amp;quot;missing user password&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;parsedURL, err := url.ParseRequestURI(urlStr)
if err != nil {
    return nil, errors.Wrapf(err, &amp;quot;failed to parse url: %s&amp;quot;, urlStr)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必須でないものはデフォルト値を準備しておきそれを使う．例えば今回の場合は&lt;code&gt;Logger&lt;/code&gt;は必須ではない．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var discardLogger = log.New(ioutil.Discard, &amp;quot;&amp;quot;, log.LstdFlags)
if logger == nil {
    logger = discardLogger
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;http.Client&lt;/code&gt;もコンストラクタ内で生成し&lt;code&gt;Client&lt;/code&gt;にセットしておく．デフォルトを使っても良いしProxyや各Timeoutを変更したい場合は独自で準備しても良い（&lt;code&gt;http.DefaultClient&lt;/code&gt;の値はバージョンによって変わるので注意する．独自の設定を使っているとバージョン毎の新しい設定に追従できないことがある）．&lt;/p&gt;

&lt;h3 id=&#34;共通メソッドを定義する1&#34;&gt;共通メソッドを定義する1&lt;/h3&gt;

&lt;p&gt;API Clientでは多くの共通メソッドを定義できる．代表的なのは&lt;code&gt;http.Request&lt;/code&gt;を作成するメソッドである．&lt;code&gt;http.NewRequest&lt;/code&gt;を使い&lt;code&gt;http.Request&lt;/code&gt;を生成しBasic認証の設定やヘッダの設定といった共通の処理を行う．&lt;/p&gt;

&lt;p&gt;例えば今回の場合は以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var userAgent = fmt.Sprintf(&amp;quot;XXXGoClient/%s (%s)&amp;quot;, version, runtime.Version())

func (c *Client) newRequest(ctx context.Context, method, spath string, body io.Reader) (*http.Request, error) {
    u := *c.URL
    u.Path = path.Join(c.URL.Path, spath)

    req, err := http.NewRequest(method, u.String(), body)
    if err != nil {
        return nil, err
    }

    req = req.WithContext(ctx)

    req.SetBasicAuth(c.Username, c.Password)
    req.Header.Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;)
    req.Header.Set(&amp;quot;User-Agent&amp;quot;, userAgent)

    return req, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引数はHTTP メソッドとパス名，そしてリクエストのBody（&lt;code&gt;io.Reader&lt;/code&gt;）である．他にも引数が増える場合は&lt;code&gt;RequestOpts&lt;/code&gt;のようなstructを別途準備して渡すようにするとインターフェースの変更がなくなり，呼び出し側の変更コストをなくすことができる（ref. &lt;a href=&#34;http://go-talks.appspot.com/github.com/yosssi/talks.yoss.si/2015/0220-good-package.slide#1&#34;&gt;Tips for Creating a Good Package&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;さらにGo1.7以降であるなら&lt;code&gt;context.Context&lt;/code&gt;をセットするようにすればモダンになる（ref. &lt;a href=&#34;http://go-talks.appspot.com/github.com/matope/talks/2016/context/context.slide#1&#34;&gt;context パッケージの紹介&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;また&lt;code&gt;User-Agent&lt;/code&gt;をセットしておくとサーバ側に優しい．ClientのバージョンやGoのバージョンをつけておくとより便利である．&lt;/p&gt;

&lt;h3 id=&#34;共通メソッドを定義する2&#34;&gt;共通メソッドを定義する2&lt;/h3&gt;

&lt;p&gt;多くのAPIはレスポンスとしてJSONやXMLなどを返す．これらをGolangのstructへDecodeする処理はAPI Clientでは共通の処理になる．例えばJSONの場合は以下のような関数を準備しておくと良い．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func decodeBody(resp *http.Response, out interface{}) error {
    defer resp.Body.Close()
    decoder := json.NewDecoder(resp.Body)
    return decoder.Decode(out)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと&lt;code&gt;Decoder&lt;/code&gt;を使う．&lt;code&gt;ioutil.ReadAll&lt;/code&gt;などを使うとメモリ効率もパフォーマンスも良くない（ref. &lt;a href=&#34;https://www.datadoghq.com/blog/crossing-streams-love-letter-gos-io-reader&#34;&gt;Crossing Streams: a love letter to Go io.Reader&lt;/a&gt;，&lt;a href=&#34;https://medium.com/go-walkthrough/go-walkthrough-io-package-8ac5e95a9fbd#.xivkrapgz&#34;&gt;Go Walkthrough: io package&lt;/a&gt;）．&lt;/p&gt;

&lt;h3 id=&#34;各メソッドを定義する&#34;&gt;各メソッドを定義する&lt;/h3&gt;

&lt;p&gt;最後にこれらを使って各メソッドを定義する．今回の場合は以下のようなメソッドが考えられる．外部からリクエストをキャンセルできるように&lt;code&gt;context.Context&lt;/code&gt;を渡す．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func (c *Client) GetUser(ctx context.Context, userID string) (*User, error)
func (c *Client) CreateUser(ctx context.Context, name string) error
func (c *Client) DeleteUser(ctx context.Context, userID string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例えば&lt;code&gt;GetUser&lt;/code&gt;は以下のように実装できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func (c *Client) GetUser(ctx context.Context, userID string) (*User, error) {
    spath := fmt.Sprintf(&amp;quot;/users/%s&amp;quot;, userID)
    req, err := c.newRequest(ctx, &amp;quot;GET&amp;quot;, spath, nil)
    if err != nil {
        return nil, err
    }

    res, err := c.HTTPClient.Do(req)
    if err != nil {
        return nil, err
    }
    
    // Check status code here…

    var user User
    if err := decodeBody(res, &amp;amp;user); err != nil {
        return nil, err
    }

    return &amp;amp;user, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リクエストメソッドは上記で定義した共通メソッドで&lt;code&gt;http.Request&lt;/code&gt;を作成し&lt;code&gt;Client&lt;/code&gt;の&lt;code&gt;HTTPClient&lt;/code&gt;を利用して実際のリクエストを実行する．そしてレスポンスのDecodeを行う．異なるのはパス名やリクエストBodyである．ステータスコードのチェックもここで行う．&lt;/p&gt;

&lt;h2 id=&#34;いくつかのテクニック&#34;&gt;いくつかのテクニック&lt;/h2&gt;

&lt;p&gt;以下では自分が実践しているいくつかのテクニックを紹介する．&lt;/p&gt;

&lt;h3 id=&#34;insecureオプション&#34;&gt;insecureオプション&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;のコンストラクタに渡す値として&lt;code&gt;insecure&lt;/code&gt;（&lt;code&gt;bool&lt;/code&gt;）はよく使う．例えば社内の古いサービスやステージング環境だと自己署名証明書を使っている場合があり&lt;code&gt;InsecureSkipVerify&lt;/code&gt;を有効にする必要がある．&lt;code&gt;insecure&lt;/code&gt;はこの設定に使う．例えば以下のように切り替えを行う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;tlsConfig := tls.Config{
    InsecureSkipVerify: insecure,
}

transport := *http.DefaultTransport.(*http.Transport)
transport.TLSClientConfig = &amp;amp;tlsConfig

c.HTTPClient = &amp;amp;http.Client{
    Transport: &amp;amp;transport,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;symmetric-api-testing&#34;&gt;Symmetric API testing&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/symmetric-api-testing-in-go/&#34;&gt;Symmetric API Testing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;API Clientを書くときもテストは大切である．もっとも簡単で確実なのは実際にAPIにリクエストを投げてレスポンスが期待するものであるかを確認する方法である．しかしAPIによってはリクエストに制限があるし，RTTを考えるとテストの時間も長くなる，またオフラインでテストすることができない．これを解決するのがGopher Academyで紹介されていたSymmetric API Testingである．&lt;/p&gt;

&lt;p&gt;詳しくは上記のリンクを読むのが良いが，簡単にいうとAPIのレスポンスをローカルのディスクに保存して次回からそれを使ってテストする方法である．例えば上で紹介した&lt;code&gt;decodeBody&lt;/code&gt;を以下のように変更する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func decodeBody(resp *http.Response, out interface{}, f *os.File) error {
    defer resp.Body.Close()

    if f != nil {
        resp.Body = ioutil.NopCloser(io.TeeReader(resp.Body, f))
        defer f.Close()
    }

    decoder := json.NewDecoder(resp.Body)
    return decoder.Decode(out)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;io.TeeReader&lt;/code&gt;を使い&lt;code&gt;os.File&lt;/code&gt;が渡された場合にDecodeと同時にレスポンスをファイルに書き込む．&lt;/p&gt;

&lt;p&gt;実際にテストを行うときはこのファイルを&lt;code&gt;httptest&lt;/code&gt;で返すようにする．例えば&lt;code&gt;/users/1&lt;/code&gt;のレスポンスを&lt;code&gt;testadata/users-1.json&lt;/code&gt;に保存したとする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;muxAPI := http.NewServeMux()
testAPIServer := httptest.NewServer(muxAPI)
defer testAPIServer.Close()

muxAPI.HandleFunc(&amp;quot;/users/1&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
    http.ServeFile(w, r, &amp;quot;testdata/users-1.json&amp;quot;)
})
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実際のAPIリクエストを避けてテストを行うことができる．&lt;/p&gt;

&lt;h3 id=&#34;ネットワーク関連のデバッグ&#34;&gt;ネットワーク関連のデバッグ&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;を定義するときに&lt;code&gt;log.Logger&lt;/code&gt;を渡すようにしたがこれはデバッグに用いる．API Clientでもデバッグは重要である．リクエストBodyなどはもちろんだが，以下のようにネットワークに関わる情報をデバッグとして出力しておくと問題が起こったときに解決しやすい．&lt;/p&gt;

&lt;p&gt;Goの&lt;code&gt;http.Client&lt;/code&gt;はデフォルトで環境変数（&lt;code&gt;http_proxy&lt;/code&gt;と&lt;code&gt;https_proxy&lt;/code&gt;）を参照しProxyを設定する．複雑なネットワーク環境から使われた場合結局Proxyが問題の原因になってることが多い．そのため以下のようにProxy情報も基本はデバッグで出力されるようにしておくと良い．上でいうと&lt;code&gt;newRequest&lt;/code&gt;にこれは書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;proxy := &amp;quot;no&amp;quot;
if proxyURL, _ := http.ProxyFromEnvironment(req); proxyURL != nil {
    proxy = proxyURL.String()
}
c.Logger.Printf(&amp;quot;[DEBUG] request proxy: %s&amp;quot;, proxy)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTTPリクエストのどこで時間がかかっているかわかると問題の切り分けがしやすい．&lt;a href=&#34;https://github.com/tcnksm/go-httpstat&#34;&gt;tcnksm/go-httpstat&lt;/a&gt;を使うとDNSLookupやTLSHandshakeのレイテンシを簡単に測定することができる．詳しくは&lt;a href=&#34;https://medium.com/@deeeet/trancing-http-request-latency-in-golang-65b2463f548c#.i8unan3sy&#34;&gt;Tracing HTTP request latency in golang&lt;/a&gt; に書いた．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;API Clientは最初に書くGolang パッケージとしても良いと思う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golangにおけるinterfaceをつかったテスト技法</title>
      <link>http://deeeet.com/writing/2016/10/25/go-interface-testing/</link>
      <pubDate>Tue, 25 Oct 2016 09:26:51 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/10/25/go-interface-testing/</guid>
      <description>

&lt;p&gt;最近何度か聞かれたので自分がGolangでCLIツールやAPIサーバーを書くときに実践してるinterfaceを使ったテスト技法について簡単に書いておく．まずはinterfaceを使ったテストの基本について説明し次に自分が実践している簡単なテクニックをいくつか紹介する．&lt;/p&gt;

&lt;p&gt;なおGolangのテストの基本については &lt;a href=&#34;https://twitter.com/suzu_v&#34;&gt;@suzuken&lt;/a&gt; さんによる&lt;a href=&#34;https://www.amazon.co.jp/dp/477418392X&#34;&gt;「みんなのGo言語」&lt;/a&gt; の6章が最高なので今すぐ買ってくれ！&lt;/p&gt;

&lt;h2 id=&#34;前提&#34;&gt;前提&lt;/h2&gt;

&lt;p&gt;自分はテストフレームワークや外部ツールは全く使わない．標準の&lt;code&gt;testing&lt;/code&gt;パッケージのみを使う．&lt;a href=&#34;https://golang.org/doc/faq#Packages_Testing&#34;&gt;https://golang.org/doc/faq#Packages_Testing&lt;/a&gt; にも書かれているようにテストのためのフレームワークを使うことは新たなMini language（DSL）を導入することと変わらない．最初にそれを書く人は楽になるかもしれないが新しくプロジェクトに参入してきたひとにはコストにしかならない（Golang以外も学ぶ必要がある）．例えば自分があるプロジェクトにContributeしようとして見たこともないテストフレームワークが使われているとがっくりする．&lt;/p&gt;

&lt;p&gt;とにかくGolangだけで書くのが気持ちがいい，に尽きる．&lt;/p&gt;

&lt;h2 id=&#34;テストとinterface&#34;&gt;テストとinterface&lt;/h2&gt;

&lt;p&gt;テストという観点からみた場合のinterfaceの利点は何か？ interfaceを使えば「実際の実装」を気にしないで「振る舞い」を渡すことができる．つまり実装の切り替えが可能になる．interfaceを使うことでいわゆる&lt;a href=&#34;https://en.wikipedia.org/wiki/Mock_object&#34;&gt;モック&lt;/a&gt;が実現できる．&lt;/p&gt;

&lt;h2 id=&#34;どこをinterfaceにするのか&#34;&gt;どこをinterfaceにするのか？&lt;/h2&gt;

&lt;p&gt;interfaceはモックポイントと思えば良い．外界とやりとりを行う境界をinterfaceにする，が基本．外界との境界とは例えばDBとやりとりを行う部分や外部APIにリクエストを投げるClientである．他にも考えられるがとりあえずここをinterfaceにする．&lt;/p&gt;

&lt;h2 id=&#34;実例&#34;&gt;実例&lt;/h2&gt;

&lt;p&gt;以下では簡単なAPIサーバーを書くとしてinterfaceによるテスト手法の説明を行う．このAPサーバーはDBとしてRedisを使うとする．なおコードは全てpseudoである．&lt;/p&gt;

&lt;p&gt;まずはDBのinterfaceを定義する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type DB interface {
    Get(key string) string
    Set(key, value string) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に実際のRedisを使った実装を書く．例えば以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Redis struct {
    // 接続情報など
}

func (r *Redis) Get(key string) string 
func (r *Redis) Set(key, value string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;main関数から呼び出すときのことを考えてコンストラクタを実装すると良い（必要な接続情報などが与えられなかった時，もしくは必要な初期化処理に失敗した時にエラーを返せる）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func NewRedis() (DB, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで重要なのは実際の実装である&lt;code&gt;Redis&lt;/code&gt;を返すのではなくinterfaceの&lt;code&gt;DB&lt;/code&gt;を返すこと．サーバー側ではこのinterfaceを使う．&lt;/p&gt;

&lt;p&gt;サーバーの実装は以下のようにする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Server struct {
     DB DB
}

func (s *Server) Start() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Server&lt;/code&gt;はinterfaceの&lt;code&gt;DB&lt;/code&gt;を持ち内部の実装（例えばhandlerなど）ではこのinterfaceを利用する．&lt;/p&gt;

&lt;p&gt;main関数は以下のように書ける（main関数には他にもflagの処理や設定ファイルを読み込みそれを各コンストラクタに渡すという処理が考えられる）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
     redis, err := NewRedis()
     if err != nil {
         log.Fatal(err)
     }

     server := &amp;amp;Server{
         DB: redis,
     }

     if err := server.Start(); err != nil {
         log.Fatal(err)
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では&lt;code&gt;Server&lt;/code&gt;のテストはどうすれば良いか？例えば今であればDockerを使いRedisを準備することを考えるかもしれない．それが容易ではない場合，もしくは外部依存のないテストを書きたい場合はモックを考える．以下のように&lt;code&gt;DB&lt;/code&gt; interfaceを満たすモック実装を準備する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type TestDB struct {
}

func (d *TestDB) Get(key string) string 
func (d *TestDB) Set(key, value string) error 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的な実装は書いてないが例えばフェイクの値やフェイクの&lt;code&gt;error&lt;/code&gt;を返すようにする（これを考えることもより良い実装につながると思う）．&lt;/p&gt;

&lt;p&gt;これを利用すれば&lt;code&gt;Server&lt;/code&gt;のテストは以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func TestServer(t *testing.T) {
     testDB := &amp;amp;TestDB{}

     server := &amp;amp;Server{
         DB: testDB,
     }    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Server&lt;/code&gt;が必要なのは&lt;code&gt;DB&lt;/code&gt; interface（振る舞い）であり実際の実装は何でも良い．これで実際にRedisを準備することなく&lt;code&gt;Server&lt;/code&gt;の動きをテストすることができる．&lt;/p&gt;

&lt;p&gt;以上がinterfaceを使ったテスト手法の基礎である．ここではDBを例にしたが他にも外部APIとやり取りを行うClientなどにも応用できる．また今回はinterfaceから実装したがすでに実際の実装がある場合もそれに対応したinterfaceを定義してしまえば同様のテストを書くことができる．&lt;/p&gt;

&lt;h2 id=&#34;いくつかのテクニック&#34;&gt;いくつかのテクニック&lt;/h2&gt;

&lt;p&gt;以下では自分が実践しているいくつかのテクニックを紹介する．&lt;/p&gt;

&lt;h2 id=&#34;環境変数で切り替える&#34;&gt;環境変数で切り替える&lt;/h2&gt;

&lt;p&gt;毎回全てのテストをモックにすれば良いわけではない．ちゃんと実際の実装によるテストも必要である．自分はこの切り替えに環境変数を使う．環境変数を使うのはCIとの相性が良いからである．&lt;/p&gt;

&lt;p&gt;追記: いくつかこのやり方に誤解があったので．この環境変数の切り替えはテストコード（&lt;code&gt;*_test.go&lt;/code&gt;）内に書く．本番用のコードとは別にコンストラクタを実装して切替を実現する（なので本番のコードで環境変数によってモックが使われてしまうという誤爆はない）．&lt;/p&gt;

&lt;p&gt;例えば以下のようなコンストラクタを準備する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
const (
     EnvTestDSN = &amp;quot;TEST_DSN&amp;quot;
)

func NewTestDB(t *testing.T) (DB, func()) {
     dsn := os.Getenv(EnvTestDSN)
     if len(den) == 0 {
           t.Log(&amp;quot;Use TestDB&amp;quot;)
           return &amp;amp;TestDB{}, func() {}
     }

    db, err := NewPostgreSQL(dsn)
     if err != nil {
         t.Fatal(“NewPostgreSQL failed: ”,err)
      }

     return db, func() {
         pSQL := db.(*PostgreSQL)
         pSQL.DB.DropTable(&amp;amp;SplunkInfo{})
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;環境変数として接続情報（&lt;code&gt;DSN&lt;/code&gt;）が与えられた場合は実際の実装である&lt;code&gt;PosgreSQL&lt;/code&gt;を返し実際のDBでテストし．与えられない場合はモックの実装でテストを行う．&lt;/p&gt;

&lt;p&gt;ちなみに2つ目の返り値はDBをCleanupするための関数で呼び出し側では&lt;code&gt;defer&lt;/code&gt;と一緒に使う（例えばDockerなどでEphemeralなデータストアを使う場合にデータを消してまっさらな状態に戻す）．&lt;/p&gt;

&lt;h2 id=&#34;外部パッケージの一部をinterfaceとして切り出す&#34;&gt;外部パッケージの一部をinterfaceとして切り出す&lt;/h2&gt;

&lt;p&gt;例えば外部のAPIを利用する場合は公式などが提供しているClientパッケージを使ってしまうのが手っ取り早い．特にAPIの場合はリクエストに制限があったり安易に呼び出せないものあるのでモックが大切になる．この場合は自分は必要な部分のみをinterfaceとして切り出すという方法をとる（他にもレスポンスを保存する&lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/symmetric-api-testing-in-go/&#34;&gt;Symmetric API Testing&lt;/a&gt;という方法もある）．&lt;/p&gt;

&lt;p&gt;例えばGitHubのAPIを使いたい場合は &lt;a href=&#34;https://github.com/google/go-github&#34;&gt;https://github.com/google/go-github&lt;/a&gt; を使うが，以下のように必要なものを切り出してしまう．そしてメインロジックではこのinterfaceを利用するようにする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type GitHub interface {
    CreateRelease(ctx context.Context, opt Option) (string, error)
    GetRelease(ctx context.Context, tag string) (string, error)
    DeleteRelease(ctx context.Context, releaseID int) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing-as-public-api&#34;&gt;Testing as Public API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/mitchellh/advanced-testing-with-go&#34;&gt;&amp;ldquo;Advanced Testing with Go&amp;rdquo;&lt;/a&gt; の発表を見てなるほどなあと思い実践始めたのはtest用の関数をAPIとして公開する方法．&lt;/p&gt;

&lt;p&gt;すべてを&lt;code&gt;main&lt;/code&gt;パッケージに実装している間は良いがある程度の規模になるとパッケージの切り出しが大切になる．&lt;code&gt;*_test.go&lt;/code&gt;に記述した関数は別のパッケージからは参照できないためモックの実装をどこに書くかが問題になる（呼び出し側で何度も実装するのは非効率）．この方法は&lt;code&gt;testing.go&lt;/code&gt;や&lt;code&gt;testing_*.go&lt;/code&gt;といったファイルを準備し外部から参照可能なテスト用のヘルパー関数を提供する，つまりテスト関数もAPIとして提供してしまう方法である．&lt;/p&gt;

&lt;p&gt;例えば以下のような関数を準備する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func TestDB(t *testing.T) DB
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func TestConfig(t *testing.T) *Config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで呼び出し側でのテスト用のモックなどの再実装を防ぐことができる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ただしやりすぎると可読性が下がるのでやりすぎには注意する必要がある．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PagerDutyのOn-callを一時的に自分にアサインするdutymeというツールを書いた</title>
      <link>http://deeeet.com/writing/2016/10/24/dutyme/</link>
      <pubDate>Mon, 24 Oct 2016 09:00:14 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/10/24/dutyme/</guid>
      <description>

&lt;p&gt;現在のチームではインシデント管理に&lt;a href=&#34;http://www.pagerduty.com/&#34;&gt;PagerDuty&lt;/a&gt;を使っている．On-callはPrimaryとSecondaryの2人体勢でそれを1週間ごとにローテーションで回している．On-Callにアサインされている場合は夜中であれ日中であれPrimaryにアラートが飛ぶ（Primaryが反応できなければSecondaryにエスカレートされる）．そしてアラートを受けたら何かしらの対応を行う．&lt;/p&gt;

&lt;p&gt;これはうまく回っているが問題もある．業務中（日中）はPrimaryやSecondaryに関係なくチームメンバーはどんどんデプロイしたりProduction環境で作業をしたりする．そしてオペレーションやデプロイ対象のコンポーネントによってはアラートが発生してしまうことがある．つまり作業者に関係なくアラートがPrimaryやSecondaryに飛んでしまう（Slackと連携しているので全員がそれをみることにはなるが）．&lt;/p&gt;

&lt;p&gt;デプロイやオペレーションは各個人の責任でやっているのでまずは本人が対応するべきである．またPrimaryであれインシデントがない場合は自分のタスクに集中しているのでアラートが飛べばDisturbされてしまう（自分がPrimaryの場合は嫌だし自分のオペレーションで誰かをDisturbしたくもない）．そもそもスケジュールの粒度をもう少し細かく簡単に変更したい．&lt;/p&gt;

&lt;p&gt;この問題を解決するために&lt;a href=&#34;https://github.com/tcnksm/dutyme&#34;&gt;&lt;code&gt;dutyme&lt;/code&gt;&lt;/a&gt;というOn-callを一時的に自分にアサインするツールを書いた．以下ではこのツールの簡単な紹介を行う．なおコードは &lt;a href=&#34;https://github.com/tcnksm/dutyme&#34;&gt;tcnksm/dutyme&lt;/a&gt; に公開している．&lt;/p&gt;

&lt;h2 id=&#34;requirement&#34;&gt;Requirement&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;dutyme&lt;/code&gt;を使うには&lt;a href=&#34;https://v2.developer.pagerduty.com/v2/page/api-reference&#34;&gt;PagerDuty API v2&lt;/a&gt;のTokenが必要になる．TokenはReadとWriteの権限を持っている必要がある．詳しくは&lt;a href=&#34;https://support.pagerduty.com/hc/en-us/articles/202829310-Generating-an-API-Key&#34;&gt;&amp;ldquo;Generating an API Key – PagerDuty Support and Help&amp;rdquo;&lt;/a&gt;を参考．&lt;/p&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;使い方は以下．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dutyme start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドを実行し必要な情報（PagerDutyのEmailスケジュール）を入力するだけでアサインが変更される．一度入力した情報はファイルに保存できるので次回からは何も入力することなくアサインを変更できる．&lt;/p&gt;

&lt;p&gt;以下は利用の様子．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/dutyme.gif&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;dutyme&lt;/code&gt;はスケジュールを書き換えているわけではない．Pagedutyの&lt;a href=&#34;https://support.pagerduty.com/hc/en-us/articles/202830170-Creating-and-Deleting-Overrides&#34;&gt;Override&lt;/a&gt;という機能を使ってスケジュールの上書きをしている．なのでベースのスケジュールが壊れる心配はない（Overrideは消すのも簡単）．&lt;/p&gt;

&lt;p&gt;実装はGo言語でclientには &lt;a href=&#34;https://github.com/PagerDuty/go-pagerduty&#34;&gt;https://github.com/PagerDuty/go-pagerduty&lt;/a&gt; を使い（Go言語でPagerDuty関連のツールを作りたい場合はこれを使えば良さそう），tty プロンプトの制御には自分で書いた &lt;a href=&#34;https://github.com/tcnksm/go-input&#34;&gt;https://github.com/tcnksm/go-input&lt;/a&gt; を使っている．&lt;/p&gt;

&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;

&lt;p&gt;インストールは&lt;code&gt;go get&lt;/code&gt;もしくは&lt;code&gt;brew&lt;/code&gt;が使える．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ brew tap tcnksm/dutyme
$ brew install dutyme
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;要望やBugなどは &lt;a href=&#34;https://github.com/tcnksm/dutyme/issues&#34;&gt;https://github.com/tcnksm/dutyme/issues&lt;/a&gt; までお願いします．現状は最低限使うための機能しかないがもう少し機能の追加はする予定．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sync.ErrGroupで複数のgoroutineを制御する</title>
      <link>http://deeeet.com/writing/2016/10/12/errgroup/</link>
      <pubDate>Wed, 12 Oct 2016 09:36:20 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/10/12/errgroup/</guid>
      <description>

&lt;p&gt;Golangの並行処理は強力である一方で同期処理を慎重に実装する必要がある．&lt;a href=&#34;http://motemen.hatenablog.com/entry/2016/05/go-concurrent-building-blocks&#34;&gt;&amp;ldquo;Go 言語における並行処理の構築部材&amp;rdquo;&lt;/a&gt;にまとめられているようにGolangは様々な方法でそれを実装することができる．実現したいタスクに合わせてこれらを適切に選択する必要がある．&lt;/p&gt;

&lt;p&gt;この同期処理の機構として新たに&lt;a href=&#34;https://godoc.org/golang.org/x/sync/errgroup&#34;&gt;golang.org/x/sync/errgroup&lt;/a&gt;というパッケージが登場した．実際に自分のツールで使ってみて便利だったので簡単に紹介する．&lt;/p&gt;

&lt;h2 id=&#34;使いどころ&#34;&gt;使いどころ&lt;/h2&gt;

&lt;p&gt;時間のかかる1つのタスクを複数のサブタスクとして並行実行しそれらが全て終了するのを待ち合わせる処理（Latch）を書きたい場合に&lt;code&gt;errgroup&lt;/code&gt;は使える．その中でも「1つでもサブタスクでエラーが発生した場合に他のサブタスクを全てを終了しエラーを返したい」（複数のサブタスクが全て正常に終了して初めて1つの処理として完結する）場合が主な使いどころである．&lt;/p&gt;

&lt;h2 id=&#34;実例&#34;&gt;実例&lt;/h2&gt;

&lt;p&gt;ここでは例として複数の&lt;code&gt;worker&lt;/code&gt;サブタスクをgoroutineで並行実行しそれらすべての終了を待ち合わせるという処理を考える．最初に今までのやりかたとして&lt;code&gt;sync.WaitGroup&lt;/code&gt;を使った実装を，次に&lt;code&gt;errgroup&lt;/code&gt;を使った実装を紹介する．&lt;/p&gt;

&lt;h3 id=&#34;sync-waitgroup&#34;&gt;sync.WaitGroup&lt;/h3&gt;

&lt;p&gt;goroutineの待機処理としてよく使われるのが&lt;code&gt;sync.WaitGroup&lt;/code&gt;である．その名前の通り指定した数の処理（goroutine）の実行の待ち合わせに利用する．例えば以下のように書くことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var wg sync.WaitGroup
errCh := make(chan error, 1)
for i := 0; i &amp;lt; 10; i++ {
    wg.Add(1)
    go func(i int) {
        defer wg.Done()
        worker(i)
    }(i)
}

wg.Wait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新たなgoroutineを生成する度に&lt;code&gt;Add&lt;/code&gt;でWaitGroupをインクリメントし処理が終了したときに&lt;code&gt;Done&lt;/code&gt;を呼ぶ．そして全ての&lt;code&gt;worker&lt;/code&gt;の処理が終了するまで&lt;code&gt;Wait&lt;/code&gt;で処理をブロックする．これはchannelを使っても実装できるが&lt;code&gt;sync.WaitGroup&lt;/code&gt;を使ったほうが読みやすいことも多い．&lt;/p&gt;

&lt;p&gt;では&lt;code&gt;worker&lt;/code&gt;でのエラーを処理をしたい場合にはどうするのが良いだろうか? sliceでエラーをため終了後にそれを取り出す，&lt;code&gt;error&lt;/code&gt;のchannelを作り外部でそれを受け取るといったパターンが考えられる．何にせよ別途自分で処理を実装する必要がある．&lt;/p&gt;

&lt;h3 id=&#34;sync-errgroup&#34;&gt;sync.ErrGroup&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/sync/errgroup&#34;&gt;errgroup&lt;/a&gt;パッケージを使う以下のように書くことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;eg := errgroup.Group{}
for i := 0; i &amp;lt; 10; i++ {
    i := i
    eg.Go(func() error {
        return worker(i)
    })
}

if err := eg.Wait(); err != nil {
    log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;errgroup&lt;/code&gt;では&lt;code&gt;Go&lt;/code&gt;メソッドを使いサブタスクを実行する．ここに与えられた処理は新たなgoroutineで実行される．&lt;code&gt;Wait&lt;/code&gt;は&lt;code&gt;sync.WaitGroup&lt;/code&gt;と同様に&lt;code&gt;Go&lt;/code&gt;メソッドで実行された全てのサブタスクが終了するまで処理をブロックする．そして（もしあれば）&lt;code&gt;Go&lt;/code&gt;メソッド内で最初に返されたnon-nilの&lt;code&gt;error&lt;/code&gt;を返す．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;errgroup&lt;/code&gt;が強力なのは&lt;code&gt;context&lt;/code&gt;パッケージを使い，1つのサブタスクでエラーが発生したときに他の全てのサブタスクをキャンセルできるところである．例えば以下のように書くことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;eg, ctx := errgroup.WithContext(context.TODO())
for i := 0; i &amp;lt; 10; i++ {
    i := i
    eg.Go(func() error {
        return workerContext(ctx, i)
    })
}

if err := eg.Wait(); err != nil {
    log.Println(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;違いは新たなGroupを&lt;code&gt;WithContext&lt;/code&gt;で生成し，かつ同時に新たな&lt;code&gt;Context&lt;/code&gt;も生成している部分である．また&lt;code&gt;worker&lt;/code&gt;を&lt;code&gt;workerContext&lt;/code&gt;とし&lt;code&gt;Context&lt;/code&gt;を渡せるようにしている．これにより1つのサブタスクでエラーが発生した場合に生成した&lt;code&gt;Context&lt;/code&gt;をキャンセルすることができる．つまり（&lt;code&gt;workerContext&lt;/code&gt;をちゃんと実装すれば）適切なリソース解放を行い処理を終了させることができる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;これだけでなく&lt;a href=&#34;https://godoc.org/golang.org/x/sync/errgroup&#34;&gt;GoDoc&lt;/a&gt;のExampleにも挙げられているようにpipeline処理にも使うことができる．これらの処理はGolangではよく実装するパターンでありもしかしたら標準に仲間入りするかもしれない．&lt;/p&gt;

&lt;p&gt;とりあえずサブタスクを全て実行してしまいたい，発生したエラーは全て取り出したい，といった場合は別のパターンを実装するのが良い．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oreilly.com/learning/run-strikingly-fast-parallel-file-searches-in-go-with-sync-errgroup&#34;&gt;Run strikingly fast parallel file searches in Go with sync.ErrGroup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/matope/talks/2016/context/context.slide#1&#34;&gt;context パッケージの紹介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2016/07/22/context/&#34;&gt;Go1.7のcontextパッケージ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GolangでAmazon EchoのSmart Home Skillを書く</title>
      <link>http://deeeet.com/writing/2016/08/30/alexa-irkit-ac/</link>
      <pubDate>Tue, 30 Aug 2016 09:56:39 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/08/30/alexa-irkit-ac/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/dp/B00X4WHP5E&#34;&gt;Amazon Echo&lt;/a&gt;（以下Alexa）はAmazonが開発・販売している音声アシスタント+Bluetoothスマートスピーカーである．音楽を流す，今日の天気やニュースを聞く，Googleカレンダーの予定を聞く，TODOを追加する，家電を操作するなどなど&amp;hellip; といった多くのことを全て音声を通じて実行することができる（&lt;a href=&#34;https://www.youtube.com/watch?v=KkOCeAtKHIc&#34;&gt;こちらの動画&lt;/a&gt;がわかりやすい）．&lt;/p&gt;

&lt;p&gt;現時点（2016年8月）では音声認識は英語のみで対応地域もUSのみとなっている（例えば天気を聞くと地域を指定しない限りUSの天気が返ってくる）．また連携できるサービスも日本で使えるものは少ない．ただ発表当時から「これは完全に買いだ」と思っており先日&lt;a href=&#34;http://deeeet.com/writing/2016/07/12/gophercon2016-lt/&#34;&gt;GopherCon2016で渡米したとき&lt;/a&gt;にいきおいで購入した（自分は音声アシスタントはSiriなどのスマートフォンに搭載されているものよりも据え置き型のものに未来を感じている．実は大学院では&lt;a href=&#34;http://link.springer.com/chapter/10.1007%2F978-1-4614-8280-2_14&#34;&gt;会話ロボットの研究&lt;/a&gt;をしていたのでこの分野には思うことはたくさんある．がそれは別途書く）．&lt;/p&gt;

&lt;p&gt;Alexaをしばらく使った感想としてはとにかく音声認識がすごい！ Living roomに置いているがどこから話しても認識してくれる（最悪玄関から「Turn-off AC」と叫んでも認識してくれる）．音声認識の研究をしていた身からして一番驚いたのはAlexaのスピーカーから音楽を流していても認識がまともに働くこと．音楽のシグナルと言葉のシグナルを分離する的な研究はあったがここまで実用的になっているのは正直驚いた．また自分は対話システムにおけるバージイン（割り込み）を研究テーマにしていたことがあるがそちらも完璧に実用的である．Alexaの上に乗るアプリケーションにはもちろん感動するが音声対話システムとしての基礎がものすごくしっかりしていることにとても感動した．&lt;/p&gt;

&lt;p&gt;さてAlexaは音楽を流す，天気を聞くといったBuilt-inのSkillに加えてサードパーティが提供するSkillを有効にして機能拡張することができる．そしてSkillは自分で開発することもできる．Skillは&lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/welcome.html&#34;&gt;AWS Lambda&lt;/a&gt;のFunctionとして実装するので現状はLambdaが対応するPython，Node.jsもしくはJavaでの開発が前提となる．がGolangの場合はシングルバイナリをデプロイしてNode.jsから実行するという方法が使えるためGolangも開発の選択肢になる．&lt;/p&gt;

&lt;p&gt;今回Golangを使い実用的なAlexa Skillを書いた．本記事ではその実装方法を簡単に紹介する．なおコードは全て &lt;a href=&#34;https://github.com/tcnksm/alexa-irkit-ac&#34;&gt;https://github.com/tcnksm/alexa-irkit-ac&lt;/a&gt; に公開している．&lt;/p&gt;

&lt;h2 id=&#34;デモ&#34;&gt;デモ&lt;/h2&gt;

&lt;p&gt;以下は今回作成したAlexa Skillのデモ動画．自宅のエアコンのON/OFFを行う．ON/OFFのシグナルの送信には&lt;a href=&#34;http://getirkit.com/&#34;&gt;IRKit&lt;/a&gt;を使っている．&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;https://player.vimeo.com/video/179021210&#34; width=&#34;640&#34; height=&#34;360&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&#34;https://vimeo.com/179021210&#34;&gt;Turn on/off air conditioner by Amazon Echo and IRKit&lt;/a&gt; from &lt;a href=&#34;https://vimeo.com/user5121880&#34;&gt;deeeet&lt;/a&gt; on &lt;a href=&#34;https://vimeo.com&#34;&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;

&lt;h2 id=&#34;実装の概要&#34;&gt;実装の概要&lt;/h2&gt;

&lt;p&gt;Alexaの独自Skillの開発には&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/getting-started-guide&#34;&gt;Alexa Skill Kit&lt;/a&gt;を用いる．Skill Kitには以下の2種類がある．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/overviews/understanding-custom-skills&#34;&gt;Custom Skill&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/overviews/understanding-the-smart-home-skill-api&#34;&gt;Smart Home Skill&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Custom SkillはよりGeneralなリクエストを受けるのに利用する．例えばWeb Seriviceに情報を問い合わせるやピザを注文するなど．若干冗長な言い回しをしないといけないが自由なワードを認識させる事ができる．Smart Home Skillは家電操作に特化したリクエストを受けるのに利用する．受け付ける言い回しは限定されているがより自然な命令ができる．今回はエアコンの操作なのでSmart Home Skillを利用した（Custom Skillを使ったNode.jsの実装はIRKitの作者の&lt;a href=&#34;https://twitter.com/maaash&#34;&gt;@maaash&lt;/a&gt;さんの&lt;a href=&#34;http://maaash.jp/2016/07/alexa-air-conditioner/&#34;&gt;&amp;ldquo;Amazon Alexaにエアコンをつけてもらう&amp;rdquo;&lt;/a&gt;が参考になる）．&lt;/p&gt;

&lt;p&gt;Smart Home Skillのリクエストの流れは以下のようになる．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://developer.amazon.com/public/binaries/content/gallery/developerportalpublic/alexa_smart_home_ecosystem.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;自分で書く必要があるのは4のLambda Functionである．Alexa Serviceからリクエストを受け家電を操作するためのAPI（この場合はIRKitのInternet HTTP API）にリクエストを投げる．&lt;/p&gt;

&lt;p&gt;これに加えてSmart Home Skillの場合は&lt;a href=&#34;https://tools.ietf.org/html/rfc6749&#34;&gt;OAuth 2.0 Authorization Framework&lt;/a&gt;を使った&lt;a href=&#34;https://developer.amazon.com/appsandservices/solutions/alexa/alexa-skills-kit/docs/linking-an-alexa-user-with-a-user-in-your-system&#34;&gt;Account Linking&lt;/a&gt;が必須になる．今回作成したSkillは完全に個人用途なのでAlexa Serviceからのリクエストを最小限でハンドルするシンプルなOAuthサーバーをGoで書いて&lt;a href=&#34;https://console.ng.bluemix.net/&#34;&gt;IBM Bluemix&lt;/a&gt;にPushして済ませた（実はここが一番めんどくさかった．ドキュメントが不足していたので自分でRFCを読まないといけなかった）．&lt;/p&gt;

&lt;p&gt;コードは&lt;a href=&#34;https://gist.github.com/tcnksm/3ca4ad1709da91386c9173ff0d926aa8&#34;&gt;&amp;ldquo;Amazon Alexa Simple Account Linking Server by Golang&amp;rdquo;&lt;/a&gt;に置いた．&lt;/p&gt;

&lt;h2 id=&#34;golangでlambda-functionを書く&#34;&gt;GolangでLambda Functionを書く&lt;/h2&gt;

&lt;p&gt;GolangによるLambda FunctionのデプロイとNode.jsとの連携には&lt;a href=&#34;http://apex.run/&#34;&gt;apex&lt;/a&gt;を利用した．この場合は以下のような&lt;code&gt;HandleFunc&lt;/code&gt;を実装すればよい．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
    apex.HandleFunc(func(event json.RawMessage, ctx *apex.Context) (interface{}, error) {        

    // Handle Request...
    
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alexa Skillの場合は入力の&lt;code&gt;event&lt;/code&gt;はAlexa Serviceからのリクエストで，返り値の&lt;code&gt;interface{}&lt;/code&gt;はAlexa Serviceへのレスポンスである．やることは非常に単純で&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/smart-home-skill-api-reference&#34;&gt;Smart Home Skill API Reference&lt;/a&gt;を参考にjsonを頑張ってパースするだけ．&lt;/p&gt;

&lt;p&gt;今回の場合は少なくとも以下の2つのリクエストを処理できる必要がある．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/smart-home-skill-api-reference#Discovery Messages&#34;&gt;Discovery Messages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/smart-home-skill-api-reference#On/Off Messages&#34;&gt;On/Off Messages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Discovery MessageはユーザがSkillを有効にするときにリクエストされる．このレスポンスでデバイス名前やリクエスト可能なコマンド（e.g., &lt;code&gt;turnOn&lt;/code&gt;と&lt;code&gt;turnOff&lt;/code&gt;）などを返す．On/Off Messageは名前の通りにOn/Offのコマンドの処理を行う．今回の場合はここでIRKitへリクエストを行う．&lt;/p&gt;

&lt;h2 id=&#34;golangでirkitを操作する&#34;&gt;GolangでIRKitを操作する&lt;/h2&gt;

&lt;p&gt;IRKitには&lt;a href=&#34;http://getirkit.com/en/#IRKit-Internet-API&#34;&gt;Internet HTTP API&lt;/a&gt;があり&lt;a href=&#34;https://api.getirkit.com&#34;&gt;api.getirkit.com&lt;/a&gt;経由で自宅のIRKitを操作することができる．これは単純なHTTP Requestなので標準の&lt;code&gt;net/http&lt;/code&gt;パッケージでなんとかなる．が他にもやりたいことがあったのでClientパッケージ &lt;a href=&#34;https://github.com/tcnksm/go-irkit&#34;&gt;tcnksm/go-irkit&lt;/a&gt; を書いた（自分が欲しいものしか書いてないので完全なClientではない）．&lt;/p&gt;

&lt;p&gt;例えばSignalを送るには以下のようにする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;f, err := os.Open(filePath)
if err != nil {
    log.Fatalf(&amp;quot;[ERROR] %s&amp;quot;, err)
}

var msg irkit.Message
decoder := json.NewDecoder(f)
if err := decoder.Decode(&amp;amp;msg); err != nil {
    log.Fatalf(&amp;quot;[ERROR] %s&amp;quot;, err)
}

c := irkit.DefaultInternetClient()
err = c.SendMessages(context.Background(), key, id, &amp;amp;msg)
if err != nil {
    log.Fatalf(&amp;quot;[ERROR] %s&amp;quot;, err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（&lt;code&gt;context&lt;/code&gt;パッケージを使いモダンな感じに仕上げてある）&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Golangを使ったAmazon EchoのSmart Home Skillの開発を紹介した．日本に上陸したときは皆GolangでSkillを書きましょう．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go1.7のSubtestsとSub-benchmarks</title>
      <link>http://deeeet.com/writing/2016/08/02/go1_7-subtest/</link>
      <pubDate>Tue, 02 Aug 2016 09:00:00 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/08/02/go1_7-subtest/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://tip.golang.org/doc/go1.7&#34;&gt;Go1.7&lt;/a&gt;では&lt;a href=&#34;https://github.com/golang/go/wiki/TableDrivenTests&#34;&gt;SubtestsとSub-benchmarks&lt;/a&gt;という機能が&lt;code&gt;testing&lt;/code&gt;パッケージに導入される．これを使うとテスト関数/ベンチマーク関数の中にテスト/ベンチマークを定義できるようになる．テストの場合はテストに階層を持たせることができ，ベンチマークの場合は&lt;a href=&#34;https://github.com/golang/go/wiki/TableDrivenTests&#34;&gt;Table Driven&lt;/a&gt;的にベンチマークを記述することができるようになる．さらに一連のテスト/ベンチマークに対して共通のsetupとtear-downを持たせることもできる．&lt;/p&gt;

&lt;p&gt;テストの場合は&lt;a href=&#34;https://github.com/golang/go/wiki/TableDrivenTests&#34;&gt;Table Driven Tests&lt;/a&gt;で十分なことも多く恩恵は少ないかもしれない．それよりもベンチーマークで効果を発揮することが多い．&lt;/p&gt;

&lt;p&gt;例えば以下のように異なる設定値を使って&lt;code&gt;Foo&lt;/code&gt;のベンチマークをとるとする．今までであればそれぞれ設定値ごとにベンチマーク関数を準備する必要があった．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func BenchmarkFoo1(b *testing.B)   { benchFoo(b, 1) }
func BenchmarkFoo10(b *testing.B)  { benchFoo(b, 10) }
func BenchmarkFoo100(b *testing.B) { benchFoo(b, 100) }

func benchFoo(b *testing.B, base int) {
    for i := 0; i &amp;lt; b.N; i++ {
        Foo(base)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go1.7のSub-benchmarkを使うと以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func BenchmarkFoo(b *testing.B) {
    cases := []struct {
        Base int
    }{
        {Base: 1},
        {Base: 10},
        {Base: 100},
    }

    for _, bc := range cases {
        b.Run(fmt.Sprintf(&amp;quot;%d&amp;quot;, bc.Base), func(b *testing.B) { benchFoo(b, bc.Base) })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず複数の関数を一つの関数にまとめることができる．そして設定値をTable-Driven的に書くことができる．これによりシンプルになりかつ可読性も上がる．Sub-benchmark名はトップレベルの関数名（&lt;code&gt;BenchmarkFoo&lt;/code&gt;）と&lt;code&gt;Run&lt;/code&gt;関数に渡す文字列を&lt;code&gt;/&lt;/code&gt;で繋いだものになる．例えば上の例の場合は&lt;code&gt;BenchmarkFoo/1&lt;/code&gt;&amp;hellip;となる．またforループの前後に&lt;code&gt;BenchmarkFoo&lt;/code&gt;専用のsetup・tear-down処理を記述することもできる．&lt;/p&gt;

&lt;p&gt;標準パッケージの変更を見ていてもSubtestよりもSub-benchmarkで恩恵を得ているのがわかる．例えば以下のような使われ方をしている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://go-review.googlesource.com/#/c/23428/&#34;&gt;https://go-review.googlesource.com/#/c/23428/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://go-review.googlesource.com/#/c/23429/&#34;&gt;https://go-review.googlesource.com/#/c/23429/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://go-review.googlesource.com/#/c/23420/&#34;&gt;https://go-review.googlesource.com/#/c/23420/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;またSubtestsはParallelテストの制御にも使える．&lt;code&gt;t.Parallel()&lt;/code&gt;を使えば個々のテストは並行処理される．そして全てのサブテストが終了した時点でトップレベルの関数に戻る．これを使えば，並行でテストを走らせて全ての処理が終了したら後処理を行うといったことができる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;GopherCon 2016のLT &lt;a href=&#34;http://go-talks.appspot.com/github.com/freeformz/talks/20160712_gophercon/talk.slide#1&#34;&gt;&amp;ldquo;State of Go 2016&amp;rdquo;&lt;/a&gt; によるとベンチマークを書いてるひとは&lt;a href=&#34;http://go-talks.appspot.com/github.com/freeformz/talks/20160712_gophercon/talk.slide#30&#34;&gt;まだ少ない&lt;/a&gt;．この変更でもう少し増えると良い．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go1.7のcontextパッケージ</title>
      <link>http://deeeet.com/writing/2016/07/22/context/</link>
      <pubDate>Fri, 22 Jul 2016 09:12:28 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/07/22/context/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://tip.golang.org/doc/go1.7&#34;&gt;Go1.7&lt;/a&gt;では&lt;a href=&#34;https://godoc.org/golang.org/x/net/context&#34;&gt;golang.org/x/net/context&lt;/a&gt;が&lt;code&gt;context&lt;/code&gt;パッケージとして標準パッケージに仲間入りする．そしていくつかの標準パッケージでは&lt;code&gt;context&lt;/code&gt;パッケージを使ったメソッド/関数も新たに登場する．&lt;code&gt;context&lt;/code&gt;パッケージは今後さらに重要な，Gopherは普通に扱うべき，パッケージになると考えられる．本記事ではそもそも&lt;code&gt;context&lt;/code&gt;パッケージとは何か？なぜ登場したのか？なぜ重要なのか？どのように使うべきか？についてまとめる．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;パッケージが初めて紹介されたのは2014年のThe Go Blogの記事 &lt;a href=&#34;https://blog.golang.org/context&#34;&gt;&amp;ldquo;Go Concurrency Patterns: Context&amp;rdquo;&lt;/a&gt;である．この記事ではなぜGoogleが&lt;code&gt;context&lt;/code&gt;パッケージを開発したのか，どのように使うのか具体的な検索タスクを例に解説されている．まだ読んだことがない人はそちらを先に読むと良い．&lt;/p&gt;

&lt;h2 id=&#34;contextパッケージとは何か&#34;&gt;contextパッケージとは何か&lt;/h2&gt;

&lt;p&gt;ここでは具体的な利用例から&lt;code&gt;context&lt;/code&gt;とは何かを説明する．&lt;/p&gt;

&lt;p&gt;例えばGoの典型的な利用例であるWebアプリケーションを考える．Goのサーバにおいてリクエストはそれぞれ個別のgoroutineで処理される．そしてリクエストHandlerは新たなgoroutineを生成しバックエンドのDBや別のサーバにリクエストを投げ結果を得てユーザに対してレスポンスを返す．&lt;/p&gt;

&lt;p&gt;このような別サーバへのリクエストのように時間のかかる処理をgoroutineで実行する場合どのようなことに注意する必要があるだろうか．まず最初に注意するべきはその処理に適切なTimeoutやDeadlineを設定して処理が停滞するのを防ぐことである．例えば別のサーバにリクエストを投げる場合にネットワークの問題でリクエストに時間がかかってしまうことは大いに考えられる．リクエストにTimeoutを設定して早めにレスポンスを返しリトライを促すべきである．&lt;/p&gt;

&lt;p&gt;次に注意するべきは生成したgoroutineを適切にキャンセルしリソースを解放することである．例えば別のサーバにリクエストを投げる場合に適切なキャンセル処理を行わないとTimeout後もネットワークリソースが使われ続けることになる（CPUやメモリを使い続けるかもしれない）．この場合&lt;code&gt;net/http&lt;/code&gt;パッケージレベルでリクエストをキャンセルするべきである．&lt;/p&gt;

&lt;p&gt;さらにそのgoroutineは別のgoroutineを呼び出しそれがまた別の&amp;hellip;と呼び出しの連鎖は深くなることが考えられる．その場合も親のTimeoutに合わせてその子は全て適切にキャンセルされリソースは解放されるべきである．．&lt;/p&gt;

&lt;p&gt;このようにキャンセル処理は重要である．&lt;code&gt;context&lt;/code&gt;パッケージはこのキャンセルのためのシグナルをAPIの境界を超えて受け渡すための仕組みである．ある関数から別の関数へと，親から子へと，キャンセルを伝搬させる．&lt;/p&gt;

&lt;p&gt;これは&lt;code&gt;context&lt;/code&gt;を使わなくても実現できる．しかし標準パッケージになったことで&lt;code&gt;context&lt;/code&gt;は「キャンセルのためのシグナルの受け渡しの標準的なインターフェース」として使える．この流れは別の標準パッケージに新たに追加された関数に見ることができる．&lt;/p&gt;

&lt;p&gt;（後述するが&lt;code&gt;context&lt;/code&gt;パッケージは限定されたスコープの値，例えば認証情報など，の受け渡しとしても利用できる．しかし筆者はこれは付随的な機能でありキャンセル機構としての&lt;code&gt;context&lt;/code&gt;の方が重要であると考えている）&lt;/p&gt;

&lt;h2 id=&#34;コードで追うcontextパッケージ&#34;&gt;コードで追うcontextパッケージ&lt;/h2&gt;

&lt;p&gt;言葉のみでは伝わりにくいので具体的なサンプルコードを使って&lt;code&gt;context&lt;/code&gt;パッケージの使いどころを説明する．&lt;/p&gt;

&lt;p&gt;以下のような単純なリクエストHandlerを考える．このHandlerはユーザからのリクエストを受けバックエンドのサービスにリクエストを投げる．そして得た結果をユーザに返す（具体的なレスポンスの書き込みなどは省略している）．リクエストは別のgoroutineで投げ，エラーをchannelで受け取る．このコードを改善していく．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    // 新たにgoroutineを生成してバックエンドにリクエストを投げる
    // 結果をerror channelに入れる
    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request()
    }()

    // error channelにリクエストの結果が返ってくるのを待つ
    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず現状のコードはネットワークの問題などで&lt;code&gt;request()&lt;/code&gt;に時間がかかりユーザへのレスポンスが停止してしまう可能性がある．これを防ぐためにはTimeoutを設定するべきである．&lt;code&gt;time&lt;/code&gt;パッケージの&lt;code&gt;time.After&lt;/code&gt;を使うと以下のようにTimeoutを設定することができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request()
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
        
    // Timeout（2秒）を設定する．
    // 例えばしばらく経ってから再度リクエストをするように
    // レスポンスを返す．
    case &amp;lt;-time.After(2 * time.Second):
        log.Println(&amp;quot;failed: timeout&amp;quot;)
        return
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでリクエストがネットワークなどの不調によりリクエストが停滞してしまう問題は解決できた．しかしこれでは不十分である．Timeoutでリクエストをユーザに返した後も&lt;code&gt;request&lt;/code&gt;は別のgoroutineで動き続ける．つまりサーバのリソースを使い続ける．少量であれば問題ないがリクエストが増えれば増えるほど問題になる．これを防ぐには&lt;code&gt;request()&lt;/code&gt;をキャンセル可能にリソースを解放するべきである．&lt;code&gt;context&lt;/code&gt;を使わない場合は，これは例えば以下のように実装できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    // handlerからrequestをキャンセルするためのchannelを準備する
    doneCh := make(chan struct{}, 1)
    
    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request(doneCh)
    }()

    // 別途goroutineを準備してTimeoutを設定する
    go func() {
        &amp;lt;-time.After(2 * time.Second)
        // Timeout後にdoneChをクローズする
        // 参考: https://blog.golang.org/pipelines
        close(doneCh)
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;request()&lt;/code&gt;は以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func request(doneCh chan struct{}) error {
    tr := &amp;amp;http.Transport{}
    client := &amp;amp;http.Client{Transport: tr}
    
    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, backendService, nil)
    if err != nil {
        return err
    }
　　
    // 新たにgoroutineを生成して実際のリクエストを行う
    // 結果はerror channelに投げる
    errCh := make(chan error, 1)
    go func() {
        _, err := client.Do(req)
        errCh &amp;lt;- err
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            return err
        }
    
    // doneChはhandlerからのキャンセル シグナル（close(doneCh)）
    // を待ち受ける
    case &amp;lt;-doneCh:
        // キャンセルが実行されたら適切にリクエストを停止して
        // エラーを返す．
        tr.CancelRequest(req)
        &amp;lt;-errCh
        return fmt.Errorf(&amp;quot;canceled&amp;quot;)
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;パッケージを使うとこれはより簡単に書くことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    // 2秒でTimeoutするcontextを生成する
    // cancelを実行することでTimeout前にキャンセルを実行することができる
    //     
    // また後述するようにGo1.7ではnet/httpパッケージでcontext
    // を扱えるようになる．例えば*http.Requestからそのリクエストの
    // contextを取得できる．
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request3(ctx)
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;request()&lt;/code&gt;は以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func request(ctx context.Context) error {
    tr := &amp;amp;http.Transport{}
    client := &amp;amp;http.Client{Transport: tr}
    
    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, backendService, nil)
    if err != nil {
        return err
    }

    // 新たにgoroutineを生成して実際のリクエストを行う
    // 結果はerror channelに投げる
    errCh := make(chan error, 1)
    go func() {
        _, err := client.Do(req)
        errCh &amp;lt;- err
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            return err
        }
    
    // Timeoutが発生する，もしくはCancelが実行されると
    // Channelが返る
    case &amp;lt;-ctx.Done():
        tr.CancelRequest(req)
        &amp;lt;-errCh
        return ctx.Err()
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;doneCh&lt;/code&gt;と比べると&lt;code&gt;context&lt;/code&gt;を使った場合はよりシンプルに書けているのがわかる．これだけではない．標準パッケージになるということは，今後はこの重要なキャンセル処理を統一的なインターフェースとして書くことができるということである．&lt;/p&gt;

&lt;h2 id=&#34;contextの契約&#34;&gt;contextの契約&lt;/h2&gt;

&lt;p&gt;具体的な使い方は&lt;a href=&#34;https://tip.golang.org/pkg/context/&#34;&gt;ドキュメント&lt;/a&gt;が詳しいのでそれを読むのが良い．大きなパッケージではないのですぐに読めると思う．以下では注意するべきことを簡単にまとめる．&lt;/p&gt;

&lt;p&gt;まず自分で&lt;code&gt;context&lt;/code&gt;を前提としたメソッド/関数を提供する場合は以下の形式を守る．必ずメソッド/関数の第一引数に&lt;code&gt;context.Context&lt;/code&gt;を渡せるようにする．structなどに埋め込んではいけない．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func DoSomething(ctx context.Context, arg Arg) error {
    // ... use ctx ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに&lt;code&gt;context&lt;/code&gt;をもつ関数は適切なキャンセル処理を実装するべきである．この関数を使う側は呼び出し側（つまり親&lt;code&gt;context&lt;/code&gt;）でTimeoutが発生した，もしくは&lt;code&gt;Cancel&lt;/code&gt;を実行した場合に適切にキャンセル処理・リソースの解放が実行されることを期待する．例えば，上のサンプルコードで示したようにHTTPリクエストであれば&lt;code&gt;CancelRequest&lt;/code&gt;を呼び確実に処理を終了させる必要がある．&lt;/p&gt;

&lt;p&gt;内部で別の関数を呼ぶ場合も&lt;code&gt;context&lt;/code&gt;を前提とし親&lt;code&gt;context&lt;/code&gt;からキャンセル可能にするべきである．標準パッケージで&lt;code&gt;context&lt;/code&gt;を前提としたメソッド/関数が実装され始めているのはこの理由によると思う．&lt;/p&gt;

&lt;p&gt;これらがGopherの間の&lt;code&gt;context&lt;/code&gt;の契約になると思う．&lt;/p&gt;

&lt;h2 id=&#34;valueの扱い&#34;&gt;Valueの扱い&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;パッケージは限定されたスコープの値，例えば認証情報など，の受け渡しとしても利用できる．しかしこれはキーと値を&lt;code&gt;interface{}&lt;/code&gt;型で指定するため利用には注意が必要である．ドキュメントにも利用するときの注意点がしっかり書かれている．例えば，値の取り出しには専用のメソッド/関数を準備してちゃんとした型として値を返すようにする，キーは公開しないなどである．&lt;/p&gt;

&lt;p&gt;またどのような値を渡すべきかに関しては&lt;a href=&#34;http://peter.bourgon.org/go-kit/&#34;&gt;go-kit&lt;/a&gt;の開発者である&lt;a href=&#34;https://twitter.com/peterbourgon&#34;&gt;Peter Bourgo&lt;/a&gt;氏のブログが非常に参考になる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://peter.bourgon.org/blog/2016/07/11/context.html&#34;&gt;context&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;標準パッケージの中のcontext&#34;&gt;標準パッケージの中のcontext&lt;/h2&gt;

&lt;p&gt;先にも述べたようにGo1.7ではいくつかの標準パッケージで&lt;code&gt;context&lt;/code&gt;パッケージを使ったメソッド/関数が実装された．実装されたのは&lt;code&gt;net&lt;/code&gt;と&lt;code&gt;net/http&lt;/code&gt;，そして&lt;code&gt;os/exec&lt;/code&gt;である．それぞれ簡単に紹介する．&lt;/p&gt;

&lt;h3 id=&#34;net&#34;&gt;net&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;net&lt;/code&gt;パッケージには&lt;code&gt;Dialer&lt;/code&gt;に新たに&lt;code&gt;DialContext()&lt;/code&gt;メソッドが追加された．これは既存の&lt;code&gt;Dial()&lt;/code&gt;メソッドに&lt;code&gt;context.Context&lt;/code&gt;を渡せるようにしたメソッドである．例えば以下のように使うことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
defer cancel()

var dialer net.Dialer
conn, err := dialer.DialContext(ctx, &amp;quot;tcp&amp;quot;, &amp;quot;google.com:80&amp;quot;)
if err != nil {
    log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;net-http&#34;&gt;net/http&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;net/http&lt;/code&gt;には&lt;code&gt;Request&lt;/code&gt;に新たに&lt;code&gt;Context()&lt;/code&gt;メソッドと&lt;code&gt;WithContext()&lt;/code&gt;メソッドが追加された．&lt;code&gt;Context()&lt;/code&gt;はそのリクエストにおける&lt;code&gt;context.Context&lt;/code&gt;を取得するために，&lt;code&gt;WithContext()&lt;/code&gt;は変更に用いる．&lt;/p&gt;

&lt;p&gt;Clientとしては以下のようにリクエストのキャンセルに使うことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;req, err := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;http://google.com&amp;quot;, nil)
if err != nil {
    log.Fatal(err)
}

ctx, cancel := context.WithTimeout(req.Context(), 100*time.Millisecond)
defer cancel()

req = req.WithContext(ctx)

client := http.DefaultClient
res, err := client.Do(req)
if err != nil {
    log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サーバーとしては以下のように&lt;code&gt;context.WithValue()&lt;/code&gt;を用いて各リクエストのスコープに限定した値の受け渡しなどに使うことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;const tokenKey = &amp;quot;tokenKey&amp;quot;

func withAuth(a Authorizer next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        auth := r.Header.Get(&amp;quot;Authorization&amp;quot;)
        token := a.Auth(auth)
        
        ctx := r.Context()
        ctx = context.WithValue(ctx, tokenKey, token)
        next.ServeHTTP(w, r.WithContext(ctx))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;またデフォルトで&lt;code&gt;ServerContextKey&lt;/code&gt;と&lt;code&gt;LocalAddrContextKey&lt;/code&gt;というキーでリクエストの&lt;code&gt;context.Context&lt;/code&gt;にそれぞれ&lt;code&gt;*http.Server&lt;/code&gt;と&lt;code&gt;net.Addr&lt;/code&gt;の値がセットされておりそれを使うこともできる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    srv := ctx.Value(ServerContextKey)
    ....
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;os-exec&#34;&gt;os/exec&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;os/exec&lt;/code&gt;には&lt;code&gt;CommandContext()&lt;/code&gt;関数が追加された．これは既存の&lt;code&gt;Command()&lt;/code&gt;関数に&lt;code&gt;context.Context&lt;/code&gt;を渡せるようにした関数である．例えば以下のように使うことができる&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;cmd := exec.CommandContext(ctx, &amp;quot;sleep&amp;quot;, &amp;quot;2&amp;quot;)
if err := cmd.Run(); err != nil {
    log.Fatal(err) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;context.Context&lt;/code&gt;が終了すると&lt;code&gt;os.Process.Kill&lt;/code&gt;が実行される．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;は&lt;code&gt;net&lt;/code&gt;関連で主に使われてきたが，そうではない場合であってもタスクにDeadlineやTimeout，Cancelを持たせるための標準的なインターフェースに利用可能であることを示す良い例である．&lt;/p&gt;

&lt;h2 id=&#34;context-leakを避ける&#34;&gt;Context leakを避ける&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;WithCancel&lt;/code&gt;や&lt;code&gt;WithTimeout&lt;/code&gt;，&lt;code&gt;WithDeadline&lt;/code&gt;で返される&lt;code&gt;cancel&lt;/code&gt;が呼ばれないと，その親&lt;code&gt;Context&lt;/code&gt;が&lt;code&gt;cancel&lt;/code&gt;されるまでその子&lt;code&gt;Context&lt;/code&gt;がLeakする（context leak）．Go1.7からの&lt;code&gt;go vet&lt;/code&gt;はそれを検出する（&lt;code&gt;-lostcancel&lt;/code&gt;）．例えば以下のような出力が得られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func leak() {
    var ctx, cancel = context.WithCancel() 
    // the cancel function is not used on all paths 
    // (possible context leak)
    
    // this return statement may be reached 
    // without using the cancel var defined on line x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://go-review.googlesource.com/#/c/24150/13/src/cmd/vet/testdata/lostcancel.go&#34;&gt;こちらの変更&lt;/a&gt;を見ると別の検出パターンもわかる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;どんどん使っていきましょう．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tip.golang.org/doc/go1.7&#34;&gt;Go 1.7 Release Notes DRAFT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dahernan.github.io/2015/02/04/context-and-cancellation-of-goroutines/&#34;&gt;Context and Cancellation of goroutines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://talks.golang.org/2014/gotham-context.slide#1&#34;&gt;Cancelation, Context, and Plumbing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39#.im1d1tr4r&#34;&gt;How to correctly use context.Context in Go 1.7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GopherCon 2016でLTした</title>
      <link>http://deeeet.com/writing/2016/07/12/gophercon2016-lt/</link>
      <pubDate>Tue, 12 Jul 2016 19:04:47 -0600</pubDate>
      
      <guid>http://deeeet.com/writing/2016/07/12/gophercon2016-lt/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://gophercon.com/&#34;&gt;GopherCon 2016&lt;/a&gt;でLTをした．&lt;a href=&#34;https://twitter.com/tenntenn&#34;&gt;@tenntenn&lt;/a&gt;さんがやった通常トーク（50分）はなかなかハードルが高いがLTは初めの一歩として良いと思う．来年もDenverで再び開催されることがアナウンスされているので来年以降に発表するひとのためにどんな感じだったかを簡単に書いておく．&lt;/p&gt;

&lt;h2 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/tcnksm/talks/2016/07/gophercon/gophercon.slide#1&#34;&gt;発表スライド&lt;/a&gt;を見てもらえばわかるが特に新しい話をしたわけではない．日本のミートアップなどで話したこと，ブログに書いたことを英語にしただけにすぎない（ただ実演デモをするという挑戦はした）．&lt;/p&gt;

&lt;p&gt;「大御所たちと同じステージで喋る機会を逃すのはもったいない」（ちなみに当日のLTは僕の次が&lt;a href=&#34;https://twitter.com/robertgriesemer&#34;&gt;Robert Griesemer&lt;/a&gt;氏でその次が&lt;a href=&#34;https://twitter.com/bradfitz&#34;&gt;Brad Fitzpatrick&lt;/a&gt;氏だった！），「日本のGo界隈にこんなやつおるでってのを知ってもらいたい」というモチベーションで発表した．あとなんとなく自分の中でここでぶっ込まないと一生逃げると思ったのもある（通常セッションにしろやって話だが50分喋る良いネタがなかった..）．&lt;/p&gt;

&lt;h2 id=&#34;流れ&#34;&gt;流れ&lt;/h2&gt;

&lt;p&gt;まずLTセッションの募集は会議開催の10日前ほどにアナウンスされた（&lt;a href=&#34;https://blog.gopheracademy.com/gophercon-2016/gophercon2016-lightning-announce/&#34;&gt;&amp;ldquo;GopherCon 2016 - Lightning Talk Annoucement&amp;rdquo;&lt;/a&gt;）．逃さないためにはtwitterの&lt;a href=&#34;https://twitter.com/gophercon&#34;&gt;@GopherCon&lt;/a&gt;や&lt;a href=&#34;https://invite.slack.golangbridge.org/&#34;&gt;Gophers slack&lt;/a&gt;をちゃんとウォッチしておくと良い．&lt;/p&gt;

&lt;p&gt;CFPは&lt;a href=&#34;https://www.papercall.io/gophercon-lightning-talks-2016&#34;&gt;PaperCall&lt;/a&gt;で行われた．タイトルや発表内容をちゃんと書く．&lt;/p&gt;

&lt;p&gt;結果の発表は開催前日に，発表日は通常会議の初日に，発表順は当日その場で発表された．そのため資料の準備と練習の時間はほとんどない．飛行機での移動中などに形だけ資料を完成させ会議の合間に練習するしかない．また事前にディスプレイの接続チェックなどはできないので特殊なことはしないほうがよい．&lt;/p&gt;

&lt;p&gt;発表場所は上の写真のメインルーム．発表時間は6分で，質疑応答は次の発表者の準備が完了するまで行われた．&lt;/p&gt;

&lt;p&gt;LTセッションは通常会議が行われた2日間両方で行われ，発表人数はそれぞれ12名だった．他の発表や自分の発表を考えると採択率は高いと感じた（直前なので申し込む人が少なかったのかもしれない）．&lt;/p&gt;

&lt;p&gt;この流れは来年変わるかもしれないし変わらないかもしれない．もし来年移行挑戦する人がいればぜひ参考にしてください．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;偉そうに書いたが採択されてからひたすら緊張し「聴衆として普通に楽しむだけにすればよかった」と何度も思った．ただ終わってみればやってよかったという気持ちしかない（&lt;a href=&#34;https://twitter.com/___leigh___/status/753005029993381896&#34;&gt;こういうリプライ&lt;/a&gt;もらえたり，終わった後に議論できて良かった）．機会があるひとはどんどん挑戦しましょう．&lt;/p&gt;

&lt;p&gt;ちなみに通常セッションのトークは以下が最高だったのでビデオが公開されたら全部観ましょう．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Understanding nil&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Navigating Unfamiliar Code with the Go Guru&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go for Data Science&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Visualizing Concurrency in Go&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go for Crypto Developers&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Inside the Map Implementation&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go Without the Operating System&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The Design of the Go Assembler&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;cgo: Safely Taming the Beast&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golangの新しいGCアルゴリズム Transaction Oriented Collector（TOC）</title>
      <link>http://deeeet.com/writing/2016/06/29/toc/</link>
      <pubDate>Wed, 29 Jun 2016 10:31:00 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/06/29/toc/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://golang.org/s/gctoc&#34;&gt;http://golang.org/s/gctoc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Goの新しいGCのProposalが出た．まだProposal段階であり具体的な実装はないが簡単にどのようなものであるかをまとめておく．&lt;/p&gt;

&lt;p&gt;GoのGCはGo1.5において単純なStop The World（STW）からConcurrent Mark &amp;amp; Sweepへと変更され大きな改善があった（詳しくは&lt;a href=&#34;http://deeeet.com/writing/2016/05/08/gogc-2016/&#34;&gt;&amp;ldquo;GolangのGCを追う&amp;rdquo;&lt;/a&gt;に書いた）．先の記事に書いたようにGo1.5におけるGCの改善は主にレイテンシ（最大停止時間）に重きが置かれいた．数値目標として10msが掲げられGo1.6においては大きなヒープサイズ（500GB）においてそれを達成していた．&lt;/p&gt;

&lt;p&gt;GCの評価項目はレイテンシのみではない．スループットやヒープの使用効率（断片化の対処）なども重要である．Go1.6までのGCではそれらについて大きく言及されていなかった（と思う）．例えばスループットに関してはハードウェアの進化がそれを改善するはずであるという前提が置かれていた（&lt;a href=&#34;https://blog.golang.org/go15gc&#34;&gt;&amp;ldquo;Go GC: Prioritizing low latency and simplicity&amp;rdquo;&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;今回提案されたTransaction Oriented Collector（TOC）アルゴリズムはGCのスループットを改善するものである．&lt;/p&gt;

&lt;h2 id=&#34;tocアルゴリズムの経験則&#34;&gt;TOCアルゴリズムの経験則&lt;/h2&gt;

&lt;p&gt;Transaction Oriented Collector（TOC）アルゴリズムは「あるTransactionで生成されたオブジェクトはTransactionが終了すると同時にすぐ死ぬことが多い」という経験則に基づくアルゴリズムである．ここでいうTransactionとはいわゆる&lt;a href=&#34;https://en.wikipedia.org/wiki/ACID&#34;&gt;ACID&lt;/a&gt;における不可分な処理単位ではなく，Webサービスなどでリクエスト受けてレスポンスを返すまでの一連の処理を示す．&lt;/p&gt;

&lt;p&gt;この仮定はGenerational GC（世代別GC）が利用している「多くのオブジェクトは生成されてすぐにゴミとなりわずかなオブジェクトだけが長く生き残る」という経験則に似ている．TOCアルゴリズムはこの経験則のGoなりの再解釈のようにも見える．&lt;/p&gt;

&lt;p&gt;このTOCアルゴリズムの経験則はどこから来たか? Goが多くサポートしているCloudアプリケーションである．このようなアプリーションは，他のネットワークや他のGoroutineからメッセージを受け，それをUnmarshalし，それを使い計算をし，結果をMarshalし，それを他のネットワークやGoroutineに投げる．そしてそのGoroutineは死ぬか他のリクエストを受けるために停止状態になる．&lt;/p&gt;

&lt;p&gt;リクエスト中での計算では大きなヒープからデータを読み込むことはあるかもしれないが典型的には書き込みは滅多に起きずヒープはTransaction間で一定になる．そしてGoroutine内で新たにアロケートしたオブジェクトは他のGoroutineに共有される（publish）かもしれないし共有されない（local）かもしれない．TOCアルゴリズムはこの共有されない場合の観測結果を使う，つまり「もしGoroutineがその中でアロケートしたオブジェクトを共有しない場合，そのオブジェクトはGC時に到達不可能になり関連するメモリ領域はすぐにアロケートできる」である．&lt;/p&gt;

&lt;p&gt;TOCアルゴリズムの恩恵を受けるのは&lt;code&gt;net/http#Server&lt;/code&gt;や&lt;code&gt;net/rpc#Server&lt;/code&gt;を使ったアプリケーションであると想像できる．&lt;/p&gt;

&lt;h2 id=&#34;tocアルゴリズムの実装の提案&#34;&gt;TOCアルゴリズムの実装の提案&lt;/h2&gt;

&lt;p&gt;TOCアルゴリズムの実装はProposalの&lt;a href=&#34;https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/edit#heading=h.aqj7hn20fsaw&#34;&gt;Examples&lt;/a&gt;をみるとわかりやすい．&lt;/p&gt;

&lt;p&gt;（まず前提としてGoのGCのMarkはBitmapで管理されている．BitmapはオブジェクトのヘッダにMarkbitを持たせるのではなく関連するメモリ領域をBitのテーブルとして別で集中管理する手法である．これはCopy-On-Writeとの相性が良いなどがある）．&lt;/p&gt;

&lt;p&gt;TOCアルゴリズムでは各Goroutineは2つのPointerをもつ．1つはCurrent Sweep Pointerである．このPointerはどこまでSweepを行ったか（Allocateしたか）を示す．もう1つはInitial Sweep Pointerである．これはそのGoroutine開始時のSweep Pointerを示す．この2つのPointerの間のオブジェクトはMarkされていようがMarkされていまいが「そのGoroutineで新たにアロケートされたオブジェクト」となる．そしてMarkされていないオブジェクトは共有されていない（Publishされていない）オブジェクトであるとする．&lt;/p&gt;

&lt;p&gt;これをどのように実現するか? ライトバリア（Write barrier）を使う．このライトバリアはそのGoroutine内で新たにアロケートされたオブジェクトがInvariantであることを保証する．つまりそのオブジェクトが他に共有されればMarkをつける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;10011110010100101010100001001011010010110100101001011101010111101
　　　　^                 &amp;lt;- before  ^  after -&amp;gt;
　　　　Initial Sweep Pointer        Current Sweep Pointer     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（Proposalの図を拝借させてもらった．1は前回のGCで到達可能であったオブジェクト，もしくはGoroutineで新たにアロケートされそしてPublishされたオブジェクトである．BeforeとInitialの間にある0はアロケートされたがPublishされていないオブジェクトである．Afterにある0はまだアロケートされていないオブジェクトである）&lt;/p&gt;

&lt;p&gt;あとはGoroutine終了時にCurrent Sweep PointerをInitial Sweep Pointerへと戻せば良い．新たにオブジェクトが生成されていようとそれが共有されていなければMarkは立っていないので，次回のGCサイクルを待たずに次回のSweepにおいてアロケートの対象になる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;簡単にGoの新たなGCのProposalを追ってみた．今後の実装とそれによる効果がどうなるかが楽しみである．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GolangでFlame Graphを描く</title>
      <link>http://deeeet.com/writing/2016/05/29/go-flame-graph/</link>
      <pubDate>Sun, 29 May 2016 14:22:17 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/05/29/go-flame-graph/</guid>
      <description>

&lt;p&gt;アプリケーションのパフォーマンス問題の解決やチューニングで大切なのは問題のコアやボトルネックに最短パスで到達することである．&lt;/p&gt;

&lt;p&gt;基本的なパフォーマンス分析の入り口はアプリケーションのスレッドがon-CPUで時間を消費しているかoff-CPUで時間を消費しているかを理解するところから始まる．on-CPUの場合はそれがuserモードかkernelモードかを特定し，さらにCPUプロファイリングによってどのcode pathがCPUを消費しているのかの分析に向かう．off-CPUの場合はI/OやLock，pagingといった問題の分析に向かう．&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;&gt;Flame Graph&lt;/a&gt;はon-CPUでのパフォーマンスの問題が発覚した時に行うCPUプロファイリングを助ける．どのcode pathがボトルネックになっているのかを1つのグラフ上で理解できる．本記事ではFlame Graphとは何か? なぜ必要なのか? を解説しGoのアプリケーションでそれを用いるために方法を解説する．&lt;/p&gt;

&lt;h2 id=&#34;flame-graphとは何か&#34;&gt;Flame Graphとは何か?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;&gt;Flame Graph&lt;/a&gt;はCPUプロファイリング結果をvisualizeしたグラフである．元Joyent，現Netflixの&lt;a href=&#34;http://www.brendangregg.com/index.html&#34;&gt;Brendan Gregg&lt;/a&gt;氏によって開発された．例えば以下はMySQLのCPUプロファイリング結果をFlame Graphで描画したものである．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.brendangregg.com/FlameGraphs/cpu-mysql-filt.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;cpu-プロファイリング&#34;&gt;CPU プロファイリング&lt;/h3&gt;

&lt;p&gt;CPUプロファイリングの共通のテクニックはStack traceのサンプリングである．Stack traceというのは関数コールのリストで，code pathの先祖を追うことができる．例えば，以下はGolangのstack traceで子から親へStackと辿ることができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;syscall.Syscall
syscall.write
syscall.Write
os.(*File).write
os.(*File).Write
log.(*Logger).Output
log.Printf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flame-graphの初期衝動&#34;&gt;Flame Graphの初期衝動&lt;/h3&gt;

&lt;p&gt;CPUプロファイリングの出力は往々にしてverboseである．例えば，Brendan Gregg氏がFlame GraphをつくるきっかけとなったプロダクションのMySQLのプロファイリングの出力は500,000行近くもあったという（&lt;a href=&#34;http://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs/16&#34;&gt;参考画像&lt;/a&gt;&amp;hellip;やばいw）．&lt;/p&gt;

&lt;p&gt;Flame Graphはそのような膨大なCPUプロファイリングを一つのグラフ上で直感的かつ簡単に理解するために開発された．&lt;/p&gt;

&lt;h3 id=&#34;flame-graphの読み方&#34;&gt;Flame Graphの読み方&lt;/h3&gt;

&lt;p&gt;以下はFlame Graphを単純化したものである．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliveryimages.acm.org/10.1145/2930000/2927301/gregg6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stack traceは長方形のボックスの列で表現される．1つ1つのボックスは関数（Stack frame）を示す&lt;/li&gt;
&lt;li&gt;y軸はStackの深さを示す．一番上のボックスはStack traceが収集された時にon-CPUであった関数であり，その下にあるボックスはすべて先祖になる．あるボックスの下にあるボックスはその関数の親である（高いほど悪いわけではない）&lt;/li&gt;
&lt;li&gt;x軸はその関数のSampleの割合を示す．&lt;strong&gt;時間ではない&lt;/strong&gt;．それぞれの関数はアルファベット順にソートされているだけ&lt;/li&gt;
&lt;li&gt;それぞれのボックスの幅はその関数の出現頻度を示す（長いほどStack trace中に多く登場したこと意味する）&lt;/li&gt;
&lt;li&gt;色には特に意味はない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ではこのFlame Graphからどのようなことがわかるか?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Q. 最もon-CPUだったのはどの関数か?

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;g()&lt;/code&gt;（グラフの一番上を見れば良い）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Q. なぜ&lt;code&gt;g()&lt;/code&gt;はon-CPUなのか?

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;a()&lt;/code&gt; -&amp;gt; &lt;code&gt;b()&lt;/code&gt; -&amp;gt; &lt;code&gt;c()&lt;/code&gt; -&amp;gt; &lt;code&gt;e()&lt;/code&gt; -&amp;gt; &lt;code&gt;f()&lt;/code&gt; -&amp;gt; &lt;code&gt;g()&lt;/code&gt;（y軸を見る）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Q. &lt;code&gt;b()&lt;/code&gt;と&lt;code&gt;h()&lt;/code&gt;を比べると?

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;b()&lt;/code&gt;は&lt;code&gt;h()&lt;/code&gt;より多く登場した（およそ5倍）（ボックスの幅を比較する）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Q. なぜ&lt;code&gt;g()&lt;/code&gt;を実行しているのか

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;a()&lt;/code&gt;が&lt;code&gt;b()&lt;/code&gt;を選択し，&lt;code&gt;d()&lt;/code&gt;が&lt;code&gt;f()&lt;/code&gt;を選択したため&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;goでflame-graphを描く&#34;&gt;GoでFlame Graphを描く&lt;/h2&gt;

&lt;p&gt;GoでFlame Graphを描くにはUberの&lt;a href=&#34;https://github.com/uber/go-torch&#34;&gt;go-torch&lt;/a&gt;を使えば良い．Gopherfest Sprint 2016の&lt;a href=&#34;https://github.com/prashantv&#34;&gt;Parashant&lt;/a&gt;氏の発表&lt;a href=&#34;https://www.youtube.com/watch?v=N3PWzBeLX2M&#34;&gt;&amp;ldquo;Profiling and Optimizing Go&amp;rdquo;&lt;/a&gt;でこの&lt;code&gt;go-torch&lt;/code&gt;を使ってパフォーマンスをチューニングする様子が観れる．ライブデモが華麗すぎて感動するので今すぐ観ると良い．&lt;/p&gt;

&lt;h3 id=&#34;goのプロファイリングの基礎&#34;&gt;Goのプロファイリングの基礎&lt;/h3&gt;

&lt;p&gt;Goにはプロファイリングのためのパッケージが標準で準備されている．Webサーバーであれば&lt;code&gt;net/http/pprof&lt;/code&gt;，通常のツールであれば&lt;code&gt;runtime/pprof&lt;/code&gt;を使う．&lt;code&gt;runtime/pprof&lt;/code&gt;についてはRuss Coss氏の&lt;a href=&#34;http://blog.golang.org/profiling-go-programs&#34;&gt;&amp;ldquo;Profiling Go Programs&amp;rdquo;&lt;/a&gt;を読むと良い．ここでは&lt;code&gt;net/http/pprof&lt;/code&gt;を使って解説をする．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;net/http/pprof&lt;/code&gt;を使ってプロファイリングを有効にするのは非常に簡単である．以下をコードに追加すればよい．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;import _ net/http/pprof 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけで&lt;code&gt;/debug/pprof&lt;/code&gt;というエンドポイントが新たに追加される．ここでは現在動いているgoroutineのStackやHeapの状態，GCの実行状況などを確認することができる．&lt;/p&gt;

&lt;p&gt;このエンドポイントを&lt;code&gt;go tool pprof&lt;/code&gt;で解析するには以下のようあコマンドを叩けば良い（&lt;code&gt;go-wrk&lt;/code&gt;などである程度ロードを与えておくと良い）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go tool pprof -seconds 5 http://localhost:9090/debug/pprof/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;するとインタラクティブなモードが始まり，以下のような専用のコマンドでプロファイリング結果を確認できるようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ (pprof) top10
3400ms of 3770ms total (90.19%)
Dropped 60 nodes (cum &amp;lt;= 18.85ms)
Showing top 10 nodes out of 98 (cum &amp;gt;= 30ms)
flat  flat%   sum%        cum   cum%
1680ms 44.56% 44.56%     1680ms 44.56%  syscall.Syscall
1030ms 27.32% 71.88%     1040ms 27.59%  syscall.Syscall6
190ms  5.04% 76.92%      190ms  5.04%  runtime.kevent
140ms  3.71% 80.64%      140ms  3.71%  runtime.indexbytebody
120ms  3.18% 83.82%      120ms  3.18%  runtime.usleep
70ms  1.86% 85.68%       70ms  1.86%  runtime.mach_semaphore_signal
70ms  1.86% 87.53%       70ms  1.86%  runtime.mach_semaphore_wait
50ms  1.33% 88.86%       50ms  1.33%  runtime.memclr
30ms   0.8% 89.66%       30ms   0.8%  net/http.(*ServeMux).match
20ms  0.53% 90.19%       30ms   0.8%  fmt.(*pp).doPrintf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テキストだけではなく，以下のコマンドでグラフ（&lt;code&gt;svg&lt;/code&gt;形式）でプロファイリング結果を表示することもできる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(pprof) web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/pprof.png&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;コードベースが小さければこれだけでも十分強力だが，コードが増えるほどグラフは複雑になり結果を直感的に理解するのが難しくなる．&lt;/p&gt;

&lt;h3 id=&#34;go-torchを使う&#34;&gt;go-torchを使う&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go-torch&lt;/code&gt;を使うには&lt;code&gt;net/http/pprof&lt;/code&gt;によるエンドポイントを有効にしておくだけで良い．そして&lt;code&gt;go tool pprof&lt;/code&gt;を使うのと同じように以下のようなコマンドを叩くだけで&lt;code&gt;.svg&lt;/code&gt;形式のFlame Graphが出力される（&lt;code&gt;go-torch&lt;/code&gt;に加えてBrendan Gregg氏のPerlスクリプト&lt;a href=&#34;https://github.com/brendangregg/FlameGraph&#34;&gt;brendangregg/FlameGraph&lt;/a&gt;をダウンロードして&lt;code&gt;PATH&lt;/code&gt;を通しておく必要がある）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-torch --time 5 --url http://localhost:9090/debug/pprof/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は以下．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/torch.svg&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;（例えば上は単純なWebサーバーの場合である．&lt;code&gt;logRequest&lt;/code&gt;という関数の&lt;code&gt;os.Hostname()&lt;/code&gt;が怪しいのがすぐわかる）&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;グラフの生成はとても簡単なので読み方さえわかればFlame Graphはとても強力である．Flame Graphで問題の原因の大まかなあたりを付け&lt;code&gt;go tool pprof&lt;/code&gt;で詳細な解析をするという流れが良いと思う．&lt;/p&gt;

&lt;p&gt;Flame GraphはJavaやNode，RubyといったVM言語でも使うことができる．またCPUだけではなくてMemoryやIOのプロファイルにも利用することができる．気になる人はいろいろ漁ってみると良さそう．&lt;/p&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/Systems-Performance-Enterprise-Brendan-Gregg-ebook/dp/B00FLYU9T2&#34;&gt;&amp;ldquo;Systems Performance: Enterprise and the Cloud&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://queue.acm.org/detail.cfm?id=2927301&#34;&gt;The Flame Graph - ACM Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs&#34;&gt;Blazing Performance with Flame Graphs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Known unknowns</title>
      <link>http://deeeet.com/writing/2016/05/24/known-unknowns/</link>
      <pubDate>Tue, 24 May 2016 08:07:56 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/05/24/known-unknowns/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.amazon.co.jp/Systems-Performance-Enterprise-Brendan-Gregg-ebook/dp/B00FLYU9T2&#34;&gt;&amp;ldquo;Systems Performance: Enterprise and the Cloud&amp;rdquo;&lt;/a&gt; をずっと読んでいる．この本はNetflixの&lt;a href=&#34;http://www.brendangregg.com/&#34;&gt;Brendan Gregg&lt;/a&gt;氏がJoyent時代に書いた本である．その名の通りLinux（とSolaris）のシステムのパフォーマンスの本である（とにかく一つ一つが丁寧かつ深く解説されておりページをめくるごとに学びしかないのでパフォーマンスに関わるひとは今すぐ読むと良い）．&lt;/p&gt;

&lt;p&gt;この本で一貫して現れてくる，通底するのが，known-knowns，known-unknownsそしてunknown-unknownsという概念である．元ネタは&lt;a href=&#34;https://en.wikipedia.org/wiki/Donald_Rumsfeld&#34;&gt;Donald Rumsfeld&lt;/a&gt; 氏の会見でのコメントだが（cf. &lt;a href=&#34;https://en.wikipedia.org/wiki/There_are_known_knowns&#34;&gt;There are known knowns&lt;/a&gt;），複雑なシステムのパフォーマンスの重要な原則を集約している．良い概念なので簡単に紹介する．&lt;/p&gt;

&lt;p&gt;それぞれをパフォーマンスの観点から説明すると以下のようになる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;known-knowns&lt;/strong&gt; - 知っていること．そのパフォーマンスのメトリクスをチェックするべきことを知っているし，現在の値も知っている．例えば，CPUの利用率をチェックするべきことを知っているし，その平均的な値が10%であることも知っている&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;known-unknowns&lt;/strong&gt; - 「知らないこと」を知っていること．そのパフォーマンスのメトリクスをチェックできること，そのようなサブシステムが存在してることを知っているが，まだそれらを観測したことがない（知らない）．例えば，profilingによって何がCPUを使いまくっているのかチェックできるのを知っているけどまだそれを実施してない．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unknown-unknowns&lt;/strong&gt; - 「知らないこと」を知らないこと．例えば，デバイス割り込みがCPUを多く消費することを知らず，そのためチェックしてないかもしれない．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;パフォーマンスというのは「知れば知るほど知らないことが増える」という分野である．システムについて学べば学ぶほど，unknown-unknownsに気づき，それはknown-unknownになり，次回からはそれをチェックできるようになる．&lt;/p&gt;

&lt;p&gt;そしてこれはパフォーマンスに限った話ではない．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GolangのGCを追う</title>
      <link>http://deeeet.com/writing/2016/05/08/gogc-2016/</link>
      <pubDate>Sun, 08 May 2016 23:01:06 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/05/08/gogc-2016/</guid>
      <description>

&lt;p&gt;Go1.5とGo1.6でGoのGCのレイテンシが大きく改善された．この変更について「ちゃんと」理解するため，アルゴリズムレベルでGoのGCについて追ってみた．&lt;/p&gt;

&lt;p&gt;まずGoのGCの現状をパフォーマンス（レイテンシ）の観点からまとめる．次に具体的なアルゴリズムについて，そして最後に実際の現場でのチューニングはどうすれば良いのかについて解説する．&lt;/p&gt;

&lt;h2 id=&#34;goのgcの今&#34;&gt;GoのGCの今&lt;/h2&gt;

&lt;p&gt;最初にGoのGCの最近の流れ（2016年5月まで）をまとめる．&lt;/p&gt;

&lt;p&gt;Go1.4までは単純なStop The World（STW）GCが実装されていたがGo1.5からは新たなGCアルゴリズムが導入された．導入の際に設定された数値目標は大きなヒープサイズにおいてもレイテンシを10ms以下に抑えることであった．Go1.5で新たなアルゴリムが実装されGo1.6で最適化が行われた．&lt;/p&gt;

&lt;p&gt;以下は公開されているベンチマーク．まずはGo1.5を見る．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.github.com/tcnksm/talks/master/2016/02/go1.6/img/go15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=aiv1JOfMjm0&#34;&gt;GopherCon 2015: Rick Hudson - Go GC: Solving the Latency Problem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;グラフの横軸はヒープサイズで縦軸はレイテンシである（小さいほどよい）．以前のバージョンと比較するとヒープの増加に伴ってレイテンシが3.0sを超えていたのがほぼ0sに抑えらているのがわかる．コミュニティからも以下のようなベンチマークが公開されている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/brianhatfield/status/634166123605331968&#34;&gt;https://twitter.com/brianhatfield/status/634166123605331968&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@robin.verlangen/billions-of-request-per-day-meet-go-1-5-362bfefa0911#.vyckzy74d&#34;&gt;Billions of request per day meet Go 1.5&lt;/a&gt; (The new version of Go reduces our 95-percentile garbage collector from 279 milliseconds down to just 10 ms)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次に以下はGo1.6のベンチマーク．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.github.com/tcnksm/talks/master/2016/02/go1.6/img/go16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/presentations/go-gc-performance&#34;&gt;QCon: Go GC: Prioritizing Low Latency and Simplicity&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;縦軸と横軸はGo1.5と同じ．まずGo1.5のグラフと比べると10倍のヒープサイズでベンチマークが行われているのがわかる．Go1.5が50GBに達する前にレイテンシが増大しているのに対してGo1.6は250GBのヒープに対しても10msのレイテンシで抑えらているのが確認できる．&lt;/p&gt;

&lt;p&gt;Go1.7のリリースが近いが，既に今までと同じくTwitterの&lt;a href=&#34;https://twitter.com/brianhatfield&#34;&gt;@brianhatfield&lt;/a&gt;氏がCanaryテストを行い，さらにGCのレイテンシが改善されたことが報告されている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-dev/n-D2RYU4nIs&#34;&gt;Go 1.7 observed performance changes (production canary@eeca3ba)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらのアップデートからGoにおいてGCのレイテンシは大規模プロダクション環境においても全く問題にならないレベルになっていることがわかる．つまりパフォーマンスに問題があったときに疑うべき場所としては優先度は低いと言える．&lt;/p&gt;

&lt;p&gt;以下ではこれらをどのように達成したのかを追っていく．&lt;/p&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;まず最初に筆者はGCに関してはほぼ初心者であった．GoのGCを少しでも「ちゃんと」理解したいがために勉強したにすぎない．そのためGCの知識は素人に毛が生えた程度でしかない．先に参考文献やリンクをまとめておくので，気になるひとは自分でそれらを追ってみるのが良い．&lt;/p&gt;

&lt;p&gt;まずGCの基礎については以下の書籍が勉強になった．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tatsu-zine.com/books/gcbook&#34;&gt;ガベージコレクションのアルゴリズムと実装&lt;/a&gt; - とにかく初心者はまずこれを読むのが良い．本書はアルゴリズム編と実装編に分かれている．アルゴリズム編では基本となるアルゴリズムが図解と疑似コードで丁寧に解説されておりGCの基礎を抑えることができる．中で述べられているようにGCの基本はGCが登場して50年たってもそれほど変わっていないのでこれらを抑えるだけでもだいぶ話に入っていける．実装編では実際のruntime例えばPythonやV8などをのコードを追っていく．これで「GCのコードの追い方」がなんとなくわかった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B01CYDGUT0&#34;&gt;ガベージコレクション&lt;/a&gt; - こちらは最近（2016年3月）発売されたばかりの本．先に上げた「ガベージコレクションのアルゴリズムと実装」がカジュアルな本であるのに対してこちらは膨大なGC研究がまとめられておりより硬派な本であると言える．基礎アルゴリズムから説明していくのは同じであるが本書は並列・並行処理/マルチコア時代のことが意識されているのが特徴的である．Goで採用されているConcurrent GCはこちらで学んだ．また参照局所性といったハードウェアに対する言及も多い&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次にGoのGCそのものについての解説は以下のRick Hudson氏の一連の発表及びブログ，デザインノートを見るとよい．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=aiv1JOfMjm0&#34;&gt;GopherCon 2015: Rick Hudson - Go GC: Solving the Latency Problem&lt;/a&gt; (&lt;a href=&#34;https://talks.golang.org/2015/go-gc.pdf&#34;&gt;slide&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/go15gc&#34;&gt;Go GC: Prioritizing low latency and simplicity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/16Y4IsnNRCN43Mx0NZc5YXZLovrHvvLhK_h0KN8woTO4&#34;&gt;Go 1.4+ Garbage Collection (GC) Plan and Roadmap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GopherConとQconの内容は基本的に同じだが後者はGo1.6に関するアップデートを幾つか含んでいる．&lt;/p&gt;

&lt;p&gt;以下の論文が参考として挙げられている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://research.microsoft.com/en-us/um/people/lamport/pubs/garbage.pdf&#34;&gt;On-the-Fly Garbage Collection: An Exercise in Cooperation&lt;/a&gt; - 基礎となったアルゴリズムについて述べた論文&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;ftp://ftp.cs.umass.edu/pub/osl/papers/sapphire-2003.pdf&#34;&gt;Sapphire: Copying GC Without Stopping the World&lt;/a&gt; - 上記のアルゴリズムの正確さと完全性，GCが「終了すること」を示した論文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また&lt;a href=&#34;https://golang.org/pkg/runtime/&#34;&gt;runtime package&lt;/a&gt;のソースコード（&lt;code&gt;mgc.go&lt;/code&gt;）にも具体的な実装の解説がコメントで書かれているので参考になる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/mgc.go&#34;&gt;https://golang.org/src/runtime/mgc.go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;またGo1.4以前のGCの歴史はstackovwerflowに良い回答があったのでそちらを見ると良い．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/7823725/what-kind-of-garbage-collection-does-go-use/7824353#7824353&#34;&gt;What kind of Garbage Collection does Go use?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下はこれらを自分の言葉で整理し直したものである．&lt;/p&gt;

&lt;h2 id=&#34;ハードウェアの進化とソフトウェアの進化&#34;&gt;ハードウェアの進化とソフトウェアの進化&lt;/h2&gt;

&lt;p&gt;Rick Hudson氏が発表でもブログでも述べていたことだが，GoのGCは現在だけではなくて10年後も使えるものを目指している．ハードウェアの進化を見据えてソフトウェアを改善している．&lt;/p&gt;

&lt;p&gt;今回のGoのGCの変更で仮定されているのは「将来のハードウェアがGCのスループットを改善する」である．そのためGCが目指したのはレイテンシの改善である（レイテンシのためにスループットを犠牲にされている）．&lt;/p&gt;

&lt;h2 id=&#34;goのgcアルゴリズム&#34;&gt;GoのGCアルゴリズム&lt;/h2&gt;

&lt;p&gt;Go1.5以降のGCアルゴリズムはConcurrent Mark &amp;amp; Sweepである．GC中のオブジェクトの状態の表現にはTri-color markig（三色マーキング）を用いている．&lt;/p&gt;

&lt;h3 id=&#34;mark-sweep&#34;&gt;Mark &amp;amp; Sweep&lt;/h3&gt;

&lt;p&gt;まずMark &amp;amp; Sweepについて説明する．Mark &amp;amp; Sweepは基礎中の基礎のGCアルゴリズムである．アルゴリズムはその名前の通りMarkとSweepという2つのフェーズに分けられる．まずMarkフェーズではルートを起点にポインタを辿りオブジェクトにマークをつけていく．次にSweepフェーズではマークが付けられていないオブジェクトをフリーリストに追加していく．フリーリストに追加された領域は次回のアロケーションで利用可能になる．&lt;/p&gt;

&lt;p&gt;つまりMark &amp;amp; Sweepではルートから到達可能なオブジェクトを生きているオブジェクトとし到達不可能なオブジェクトを死んでいると判別し回収する．オブジェクトがミューテータ（アプリケーション）に実際に使われているか?  といった判別は行わない（つまり全く使われていないにもかかわらずルートから到達できればオブジェクトは掃除されることはない）．&lt;/p&gt;

&lt;h3 id=&#34;gcはなぜ問題になるのか&#34;&gt;GCはなぜ問題になるのか?&lt;/h3&gt;

&lt;p&gt;こう見るとGCは非常に単純に見える．しかしGCは多くのアプリケーションで大きな問題になる．それはStop The World（STW），つまりミューテータの実行を止めること，が必要になるからである．なぜならミューテータはGCがオブジェクトが生きているか死んでいるかを判断している間にヒープのトポロジを変更してしまうからである．&lt;/p&gt;

&lt;p&gt;例えば，GCの途中にミューテータが新たにアロケーションを行ってしまった場合を考える．するとそのオブジェクトはマークされず，生きているのにもかかわらずSweepの対象になってしまうかもしれない．これは大きなバグになる．GCの正確さを保証するためにはミューテータとコレクタの動作を同期させる必要がある．&lt;/p&gt;

&lt;p&gt;この同期のための最も単純な戦略はGCを行っている間はミューテータを完全に止めてしまう方法である．しかしこれではアプリケーションはまともなサービスを提供できなくなる．例えばWebアプリケーションにおいてはしばらくレスポンスを返せないなどといった状況が発生してしまうかもしれない．GCの研究においてSTWをいかに短くするか，レイテンシをいかに小さくするか，もしくは避けるか，は大きな分野である（他には断片化をいかに少なくしてヒープの使用効率を良くするかといった方向もある）．&lt;/p&gt;

&lt;p&gt;Go1.4以前のGCはこの単純なSTWであり，レイテンシが大きな問題になっていた．以下で説明する，Tri-color markingやConcurrent GCはSTWを減らし，レイテンシを改善するための方法である．&lt;/p&gt;

&lt;h3 id=&#34;tri-color-marking&#34;&gt;Tri-color marking&lt;/h3&gt;

&lt;p&gt;一度にGCのプロセスを全て実行するのではなく，GCの実行を分割し，ミューテータと交互に実行させることでレイテンシを小さくすることができる．このように実行するGCをインクリメンタルGCと呼ぶ．Tri-color marking（三色マーキング）は，インクリメンタルGCを可能にするためのオブジェクトの抽象化である．&lt;/p&gt;

&lt;p&gt;Tri-color markingはその名の通りGC中のオブジェクトを状態に応じて以下の3種類に分類する．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;白 - まだ探索されていないオブジェクト&lt;/li&gt;
&lt;li&gt;グレー - 探索途中のオブジェクト&lt;/li&gt;
&lt;li&gt;黒 - 探索済みのオブジェクト&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mark &amp;amp; SweepをTri-color markingを使ってインクリメンタルに実行すると以下の3つのフェーズに分けることができる．GCの開始時点では全てのオブジェクトの色は白である．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ルートスキャンフェーズ - ルートから直接参照可能なオブジェクトをグレーに塗る&lt;/li&gt;
&lt;li&gt;マークフェーズ - グレーのオブジェクトを取り出し，その子オブジェクトをグレーに塗る．全ての子オブジェクトがグレーに塗られたらそのオブジェクトは黒に塗られる&lt;/li&gt;
&lt;li&gt;スイープフェーズ - ヒープ領域をスキャンし白いオブジェクトを死んでいるオブジェクトであると判別してフリーリストに連結する．また黒いオブジェクトは白色に戻す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ルートスキャンフェーズはGCの開始時に一度だけ実行される．マークフェーズでは，全てのグレーオブジェクトを一度に全て処理するのではなく，一定個数だけ処理して中断し，ミューテータの実行を再開する．これを繰り返しグレーのオブジェクトがなくなるまでこのフェーズを続ける．スイープフェーズもヒープを一括でスキャンするのではなく順次スキャンする．ミューテーターは，ルートスキャンフェーズとマークフェーズの間，マークフェーズの間，そしてスイープフェーズの間に実行が再開される．&lt;/p&gt;

&lt;h3 id=&#34;ライトバリア&#34;&gt;ライトバリア&lt;/h3&gt;

&lt;p&gt;マークフェーズを中断しミューテータを再開する場合を考える．この時に何も考慮しないと問題が発生する．&lt;/p&gt;

&lt;p&gt;例えば，ミューテータを再開した際に，グレーのオブジェクトAから参照された白いオブジェクトBがあるとする．ミューテータがこのオブジェクトBを別の黒いオブジェクトCから参照するようにポインタを更新し，かつオブジェクトAからの参照を削除してしまったとする．このままマークフェーズが再開するとどうなるか? 黒いオブジェクトCは「探索済み」である．よってオブジェクトCは再びスキャンされることはない．新たに参照された白いオブジェクトBもスキャンされることはなく「マーク漏れ」が発生する．つまり生きいるのに回収されるという大きな問題が発生してしまう．&lt;/p&gt;

&lt;p&gt;この「マーク漏れ」（オブジェクトの迷子）が発生するのは以下の2つの条件が成立する時である．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ミューテータが白いオブジェクトへのポインタを黒いオブジェクトに書き込む&lt;/li&gt;
&lt;li&gt;すべてのグレーのオブジェクトから，その白いオブジェクトへの経路が削除される&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを防ぐのがライトバリアである．ライトバリアはGenerational GC（世代別GC）などでも使われる手法である．インクリメンタルGCのライトバリアはいくつか提案されている．Dijkstraによって提案された手法では「新たに参照されるオブジェクトが白いオブジェクトであればそれをグレーとする」．上の例だと，白いオブジェクトBを黒いオブジェクトCから参照するときにオブジェクトBをグレーにする．こうすることでBの「マーク漏れ」を防ぐことができる．&lt;/p&gt;

&lt;p&gt;インクリメンタルGCによりミューテータの実行を長時間妨げることはなくなり，レイテンシは大きく改善できる．しかし，このライトバリアによってオーバーヘッドを避けることができない．よってスループットを犠牲にする必要がある．&lt;/p&gt;

&lt;h3 id=&#34;concurrent-mark-sweep&#34;&gt;Concurrent Mark &amp;amp; Sweep&lt;/h3&gt;

&lt;p&gt;これらをConcurentに実行しているのがGoのGCである．並行への移行は単純なステップである．新たに加わる困難はコレクタとミューテータが適切に同期してヒープの一貫したビューを維持することである．&lt;/p&gt;

&lt;p&gt;GoはそれぞれのOSスレッド上にスケジューリングのコンテキストを持つ．このコンテキストはGoroutineのためのローカルのスケジューラであるとみなせ，&lt;code&gt;runtime&lt;/code&gt;のコードではPと呼ばれる（詳しくは&lt;a href=&#34;https://morsmachine.dk/go-scheduler&#34;&gt;&amp;ldquo;The Go scheduler&amp;rdquo;&lt;/a&gt; がわかりやすい）．GCにおいては，フェーズ（スキャンフェーズなど）が変わるたびに，すべてのPからのackを待つことで複数のスレッド間の同期を行っている．&lt;/p&gt;

&lt;p&gt;GCは終了することが重要である．Concurrent GCではミューテータがGCプロセスと同時に動くためオブジェクトは次々に新たにアロケートされていく．このためマークフェーズが収束しない可能性がある．これを解決するためにGoではマークフェーズ後に&lt;code&gt;marktermination&lt;/code&gt;フェーズが存在する．ここでは新たなオブジェクトは全て黒色でアロケートされる．これによりGCは収束に向かう．&lt;/p&gt;

&lt;h2 id=&#34;gogc-goのgcをチューニングする&#34;&gt;GOGC（GOのGCをチューニングする）&lt;/h2&gt;

&lt;p&gt;GCというとJavaのようなたくさんのチューニングパラメーター（&lt;code&gt;xms&lt;/code&gt;や&lt;code&gt;xmx&lt;/code&gt;）を思い浮かべる．Goにはただ1つの&lt;code&gt;GOGC&lt;/code&gt;という環境変数がGCをチューニングするパラメーターとして提供されている．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GOGC&lt;/code&gt;はGoにおける最も古い環境変数の1つである（&lt;a href=&#34;http://dave.cheney.net/2015/11/29/a-whirlwind-tour-of-gos-runtime-environment-variables&#34;&gt;A whirlwind tour of Go&amp;rsquo;s runtime environment variables&lt;/a&gt;）．この環境変数はGCのAggressivenessを決める．&lt;/p&gt;

&lt;p&gt;デフォルト値は&lt;code&gt;100&lt;/code&gt;である．これはある時点でのGC完了後に到達可能であったオブジェクトのサイズよりも100%，つまり2倍大きなヒープサイズが消費されたら次のGCを実行するという意味である．&lt;/p&gt;

&lt;p&gt;どのようにチューニングするか? まずより大きな値，例えば&lt;code&gt;200&lt;/code&gt;をセットする．これはある時点でのGC完了後に到達可能であったあったオブジェクトのサイズよりも200%，つまり3倍のヒープサイズが消費されたら次のGCを実行するという意味である．つまりGCの実行を遅らせることができる．RAMに余裕がありGCに使われる合計時間を減らしたい（スループットを向上させたい）場合は大きな値を設定する．．&lt;/p&gt;

&lt;p&gt;次により小さな値を設定するとGCの実行間隔が短くなる．メモリの使用量を少なくしたい場合は小さな値を設定する（&lt;code&gt;off&lt;/code&gt;を設定するとGCは実行されなくなる）．&lt;/p&gt;

&lt;p&gt;GoのGCはハードウェアの進化が考慮されているのであった．もしハードウェアが進化してRAMの容量が2倍なったらどうするか．&lt;code&gt;GOGC&lt;/code&gt;の値を2倍にすればGCのサイクルを半分にすることができ，チューニングなしでアプリケーションを簡単にスケールさせることができる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;GoのGCの変更について追ってみた．追ってみて他の言語と比べてもシンプルなGCが実装されているなあと感じた．そのためアルゴリズムなどを理解するのは容易だった．シンプルさの思想がGCにもあるのは良いなあと感じた．&lt;/p&gt;

&lt;p&gt;GCにはレイテンシやスループット以外にも解決するべき問題がある．例えばGoの場合は断片化の問題などは考慮されていない．今後その他の問題にどのように対処していくのかも楽しみになった．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golangのエラー処理とpkg/errors</title>
      <link>http://deeeet.com/writing/2016/04/25/go-pkg-errors/</link>
      <pubDate>Mon, 25 Apr 2016 09:00:22 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/04/25/go-pkg-errors/</guid>
      <description>

&lt;p&gt;GoConでは毎回エラー処理について面白い知見が得られる．&lt;a href=&#34;http://gocon.connpass.com/event/9748/&#34;&gt;Go Conference 2014 autumn&lt;/a&gt; においては（実際のトークではないが）居酒屋にて&lt;a href=&#34;https://twitter.com/jxck_&#34;&gt;@Jxck&lt;/a&gt;さんがRob Pike氏から以下のようなテクニックを紹介してもらっていた．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;Errors are values - The Go Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jxck.hatenablog.com/entry/golang-error-handling-lesson-by-rob-pike&#34;&gt;Golang Error Handling lesson by Rob Pike&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これはWrite（やRead）のエラー処理が複数続く場合に&lt;code&gt;errWriter&lt;/code&gt; を定義して複数のエラー処理を一箇所にまとめてコードをすっきりとさせるテクニックであった．&lt;/p&gt;

&lt;p&gt;そして今回の &lt;a href=&#34;http://gocon.connpass.com/event/27521/&#34;&gt;Go Conference 2016 spring&lt;/a&gt; のkeynoteにおいてもDave Cheney氏から（僕にとっては）新たなエラー処理テクニックが紹介された．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dave.cheney.net/paste/gocon-spring-2016.pdf&#34;&gt;Gocon Spring 2016&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;実際に使ってみて/コードを読んでみて（飲み会でもコードとともにいろいろ教えてもらった）自分の抱えている問題を解決できそうで使ってみたいと思えた．&lt;/p&gt;

&lt;p&gt;本記事では現在のエラー処理の問題と発表で紹介された&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;pkg/errors&lt;/a&gt;についてまとめる．なお上記のスライドにはトークノートも書かれているので具体的な内容はそちらを見るのが良い．&lt;/p&gt;

&lt;h2 id=&#34;問題&#34;&gt;問題&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/jxck_&#34;&gt;@Jxck&lt;/a&gt;さんのケースは1つの関数において複数のエラーハンドリングが煩雑になる，言わば縦方向のエラー処理の問題であった．Dave氏のトークで語られているのは深さ方向のエラー処理の問題である．大きく分けて2つの問題がある．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最終的に表示されるエラーメッセージ&lt;/li&gt;
&lt;li&gt;特定のエラーに対する分岐処理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下ではそれらを具体的に説明する．&lt;/p&gt;

&lt;h3 id=&#34;エラーメッセージ&#34;&gt;エラーメッセージ&lt;/h3&gt;

&lt;p&gt;まずはエラーメッセージについて．以下は基本的なGoのエラー処理である．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Foo() error {
    conf, err := ReadConf()
    if err != nil {
        return err
    }
    ...
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Foo()&lt;/code&gt;が&lt;code&gt;ReadConf()&lt;/code&gt;を呼び，&lt;code&gt;ReadConf()&lt;/code&gt;がエラーを返せばそれを&lt;code&gt;err&lt;/code&gt;として返し，そうでなければ&lt;code&gt;conf&lt;/code&gt;をつかった処理を続行し問題がなければ&lt;code&gt;nil&lt;/code&gt;を返す．&lt;/p&gt;

&lt;p&gt;大きなパッケージやツールになるとこの定型的な処理はどんどん連なり深くなる．例えばこの例の場合は&lt;code&gt;ReadConf()&lt;/code&gt;がさらに&lt;code&gt;Write()&lt;/code&gt;といった標準パッケージの関数を呼びそのエラーを返すかもしれないし，&lt;code&gt;Foo()&lt;/code&gt;は別の関数から呼ばれその中でエラーが処理されるかもしれない．&lt;/p&gt;

&lt;p&gt;これらの一連のエラーは最終的にどうなるか? コマンドラインツールやWebサーバーの&lt;code&gt;main()&lt;/code&gt;に戻り以下のように&lt;code&gt;fmt.Printf()&lt;/code&gt;（や&lt;code&gt;log&lt;/code&gt;）を使って適切なエラーメッセージとしてユーザに表示する（&amp;rdquo;べき&amp;rdquo;である）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Printf(&amp;quot;Failed Foo: %s&amp;quot;,err)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この単純な&lt;code&gt;return err&lt;/code&gt;の連鎖は問題を起こす．最終的にユーザに表示されるエラーメッセージにはその後のデバッグに対してなんの情報も提示できないことがある．つまりどの関数のどこでエラーが発生したのか追えなくなる．例えば発表でも触れられていたように&lt;code&gt;no such file or directory&lt;/code&gt;のみ表示されるケースに出会った人は多いと思う．他にもGoのツールだとTLSに関わるエラーなどで困ったひとは多いと思う（これはググるとDockerのGithub Issueが最初に現れるw）．&lt;/p&gt;

&lt;p&gt;この問題に対してできることは&lt;code&gt;fmt.Errorf()&lt;/code&gt;を使って具体的なエラーの状況を付加することである．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Foo() error {
    conf, err := ReadConf()
    if err != nil {
        return fmt.Errorf(&amp;quot;failed to read configuration file: %s&amp;quot;)
    }
    ...
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これはよくPR reviewで指摘することだと思う．これで最終的に提示されるエラーはよりデバッグのしやすいものになる．&lt;/p&gt;

&lt;p&gt;しかし&lt;code&gt;fmt.Errorf()&lt;/code&gt;は&lt;code&gt;error&lt;/code&gt;を別の&lt;code&gt;string&lt;/code&gt;に結合して別の&lt;code&gt;error&lt;/code&gt;をつくり出す．原因となったエラーが特定の型を持っていた場合にそれを隠蔽してしまう．これにより&lt;code&gt;fmt.Errorf()&lt;/code&gt;は次に説明する呼び出し元での分岐処理を難しくする．&lt;/p&gt;

&lt;h3 id=&#34;分岐処理&#34;&gt;分岐処理&lt;/h3&gt;

&lt;p&gt;次に特定のエラーに対する呼び出し元での分岐処理の問題について説明する．関数の呼び元において特定のエラーが返ってきたときに単純にそれを返す，もしくはユーザに表示するのではなく，別の処理をしたいという場合がある．例えばリトライ処理を行うなど．&lt;/p&gt;

&lt;p&gt;これは様々な方法がある．が，以下は避けるべきである．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;error.Error()&lt;/code&gt;して中身をみて&lt;code&gt;string&lt;/code&gt;として使う&lt;/li&gt;
&lt;li&gt;Sentinel error（&lt;code&gt;io.EOF&lt;/code&gt;など）を使う&lt;/li&gt;
&lt;li&gt;自分でError typeを定義してType assertionする&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1つ目は初心者がやりがちだが最も避けるべき方法である．他の2つを避ける理由は呼び出しに別の依存をもたらすことになるのが大きな理由（スライドにはもっと詳しい例があるのでそちらを見るとよい）．無駄なCouplingは避ける．基本的には単純な&lt;code&gt;error&lt;/code&gt;を返すというパッケージ間のContractを破るべきではない．&lt;/p&gt;

&lt;p&gt;ではどうするのが良いか? 型ではなくインターフェースを考える（Assert errors for behaviour, not type）．以下のようにする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type temporary interface {
    Temporary() bool 
}

func IsTemporary(err error) bool { 
   te, ok := err.(temporary) 
   return ok &amp;amp;&amp;amp; te.Temporary() 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;err&lt;/code&gt;が&lt;code&gt;temporary&lt;/code&gt;インターフェースを実装していれば&lt;code&gt;Temporary()&lt;/code&gt;関数で特別な分岐処理をするべきか（例えばリトライするべきか）どうかを判別して返す．していなければ無関係なエラーとして単純に&lt;code&gt;false&lt;/code&gt;を返し特別な処理分岐をスキップする．これは無駄な依存やCouplingを避けることができる．&lt;/p&gt;

&lt;p&gt;しかしこの方法と上述した&lt;code&gt;fmt.Errorf()&lt;/code&gt;によるエラーメッセージ問題を同時に解決することはできない．&lt;code&gt;fmt.Errorf()&lt;/code&gt;がエラーを作り直してしまうからである（元のエラーがインターフェースを持っていたか追えなくなる）．&lt;/p&gt;

&lt;h2 id=&#34;errorsを使う&#34;&gt;errorsを使う&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;errors&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;errors&lt;/code&gt;は上記で説明したエラーメッセージ問題を良い感じに解決しつつ処理分岐にも対応する．&lt;code&gt;errors&lt;/code&gt; パッケージは以下のような関数を持つ．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Wrap(cause error, message string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func Cause(err error) error
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;wrap&#34;&gt;Wrap()&lt;/h3&gt;

&lt;p&gt;まず&lt;code&gt;Wrap()&lt;/code&gt;はオリジナルの&lt;code&gt;error&lt;/code&gt;を具体的なエラーの状況（&lt;code&gt;message&lt;/code&gt;）とともにラップした新たな&lt;code&gt;error&lt;/code&gt;を返す．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;conf, err := ReadConf()
if err != nil {
    return errors.Wrap(err, &amp;quot;failed to read configuration file&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この&lt;code&gt;Error()&lt;/code&gt;の結果は以下の&lt;code&gt;error&lt;/code&gt;と同じである．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Errorf(&amp;quot;failed to read configuration file: %s&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数のインターフェースとしてそのエラーのコンテキスト（annotation）を要求するのがよい．最終的に出力されるエラーメッセージは&lt;code&gt;fmt.Errorf()&lt;/code&gt;と同じ結果になりエラー処理の方法も変わらない．&lt;/p&gt;

&lt;p&gt;これだけではなく&lt;code&gt;Wrap()&lt;/code&gt;は呼ばれたファイルとその行数も同時に内部に記録する．同パッケージの&lt;code&gt;Print&lt;/code&gt;（&lt;code&gt;Fprint&lt;/code&gt;）を使うと以下のような詳細なエラーメッセージを表示することができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;err := fn()
errors.Fprint(os.Stderr, err)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;read.go:3: A.conf is not exist
conf.go:35: failed to read configuration
main.go:100: Failed to run fn()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは単純に&lt;code&gt;fmt.Errorf&lt;/code&gt;を使うより便利なので移行の理由になる．&lt;/p&gt;

&lt;h3 id=&#34;cause&#34;&gt;Cause()&lt;/h3&gt;

&lt;p&gt;次に&lt;code&gt;Cause()&lt;/code&gt;は元となったエラーをそのまま取り出す．&lt;code&gt;fmt.Errorf&lt;/code&gt;はコンテキストを付与できる一方で新しいエラーを返してしまうために呼び出し元での処理の分岐がやりにくくなってしまった．&lt;code&gt;Cause()&lt;/code&gt;は以下のインターフェースを&lt;code&gt;error&lt;/code&gt;に持たせることで元となった&lt;code&gt;error&lt;/code&gt;を取り出す関数である．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Causer interface {
    Cause() error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを使うと上記の&lt;code&gt;temporary&lt;/code&gt;インターフェースの例は以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func IsTemporary(err error) bool { 
    te, ok := errors.Cause(err).(temporary)
    return ok &amp;amp;&amp;amp; te.Temporary() 
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん&lt;code&gt;Wrap()&lt;/code&gt;はデフォルトで元の&lt;code&gt;error&lt;/code&gt;を保持し，かつ&lt;code&gt;Causer&lt;/code&gt;インターフェースを満たすので&lt;code&gt;Cause()&lt;/code&gt;をそのまま使える．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;errors&lt;/a&gt;を使うとエラーにコンテキストを付与しつつ，オリジナルのエラーを保持し呼び出し元において処理の分岐を行うことができる．かつ&lt;code&gt;error&lt;/code&gt;を介すので標準的なContractから外れることもない．&lt;/p&gt;

&lt;p&gt;Canonicalのいくつかのツールでも使われている（&lt;code&gt;juju&lt;/code&gt;も似たパッケージ&lt;a href=&#34;https://github.com/juju/errors&#34;&gt;juju/errors&lt;/a&gt;を使っている）らしい．そして&lt;a href=&#34;https://godoc.org/github.com/pkg/errors&#34;&gt;errors&lt;/a&gt;はそれらのシンプル版とのこと．&lt;/p&gt;

&lt;p&gt;こういう標準パッケージに則した薄いライブラリはとても好きなので使っていきたい．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年振り返り</title>
      <link>http://deeeet.com/writing/2015/12/31/2015/</link>
      <pubDate>Thu, 31 Dec 2015 23:19:18 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/12/31/2015/</guid>
      <description>

&lt;p&gt;2015年の振り返りとして自分が好きだったもの，影響を受けたものを雑多にまとめる．それに合わせて自分の活動についても振り返り，2016年の展望を書く（&lt;a href=&#34;http://blog.fogus.me/&#34;&gt;fogus: Send More Paramedics&lt;/a&gt;の形式が良かったのでそれを真似ている）．&lt;/p&gt;

&lt;h2 id=&#34;blog-posts-read&#34;&gt;Blog posts read&lt;/h2&gt;

&lt;p&gt;今年読んで印象に残った，影響を受けたブログ記事．順不同．&lt;/p&gt;

&lt;h3 id=&#34;japanese&#34;&gt;Japanese&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.sigbus.info/2015/01/p1.html&#34;&gt;コードを書くことは無限の可能性を捨てて一つのやり方を選ぶということ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.kengo-toda.jp/entry/2015/03/22/215005&#34;&gt;7年働いた時点での私の仕事の極意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.jockinsey.com/settingalowbar&#34;&gt;志低く&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://myfinder.hatenablog.com/entry/2015/03/27/141416&#34;&gt;ソフトウェアエンジニアだけでサービス運用できる環境を作って失業した話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mrorii.github.io/blog/2015/04/04/language-of-food/&#34;&gt;食べログの口コミに見る人間心理 -麻薬と性とトラウマと-&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.livedoor.jp/sonots/archives/44075238.html&#34;&gt;運用を楽にするためのアプリケーションコードを書くということ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hb.matsumoto-r.jp/entry/2015/04/20/151743&#34;&gt;Webオペレーションエンジニアのアウトプットと開発力&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hail2u.net/blog/software/patience-time.html&#34;&gt;我慢の期間&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yuuki.hatenablog.com/entry/2015-webserver-architecture&#34;&gt;2015年Webサーバアーキテクチャ序論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://anemone.dodgson.org/2015/07/13/a-million-hello-worlds/&#34;&gt;A Million Hello Worlds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hb.matsumoto-r.jp/entry/2015/08/23/220153&#34;&gt;技術者が研究者のように論文を書くメリットはあるか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://t-wada.hatenablog.jp/entry/active-oss-development-vs-simplicity&#34;&gt;OSS開発の活発さの維持と良いソフトウェア設計の間には緊張関係があるのだろうか?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.twitter.com/ja/2015/buttons&#34;&gt;持続的なプラットフォームのための難しい決断&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://anond.hatelabo.jp/20151117013422&#34;&gt;翻訳は/誰がやっても/間違える&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://steps.dodgson.org/b/2012/12/30/code-review-from-lowland/&#34;&gt;下から目線のコードレビュー&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;english&#34;&gt;English&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.linux.com/news/featured-blogs/200-libby-clark/806347-collaboration-summit-keynote-alex-polvi-coreos&#34;&gt;CoreOS Co-Founder Alex Polvi Talks Containers, Rocket vs. Docker, and More&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mnot.net/blog/2015/02/18/http2&#34;&gt;HTTP/2 is Done&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.shubhro.com/2014/12/27/software-engineers-should-write/&#34;&gt;Software engineers should write&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@darrenrush/after-docker-unikernels-and-immutable-infrastructure-93d5a91c849e#.7x8i5lfvt&#34;&gt;After Docker: Unikernels and Immutable Infrastructure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/199PqyG3UsyXlwieHaqbGiWVa8eMWi8zzAn0YfcApr8Q/edit&#34;&gt;My Philosophy on Alerting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://thenewstack.io/new-stack-mitchell-hashimoto-containers-no-containers-one-question-2015&#34;&gt;Mitchell Hashimoto: Containers or No Containers? That is One Question for 2015&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://coreos.com/blog/cluster-osi-model/&#34;&gt;What makes a cluster a cluster?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.pl-enthusiast.net/2015/03/25/interview-with-gos-russ-cox-and-sameer-ajmani/&#34;&gt;Interview with Go’s Russ Cox and Sameer Ajmani&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.toolshed.com/2015/05/the-failure-of-agile.html&#34;&gt;The Failure of Agile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http/&#34;&gt;Deprecating Non-Secure HTTP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://influxdb.com/blog/2015/06/03/InfluxDB_clustering_design.html&#34;&gt;InfluxDB Clustering Design - neither strictly CP or AP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.circleci.com/its-the-future/&#34;&gt;It&amp;rsquo;s The Future&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mkremins.github.io/blog/unix-not-acceptable-unix/&#34;&gt;Unix is not an acceptable Unix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.parse.com/learn/how-we-moved-our-api-from-ruby-to-go-and-saved-our-sanity/&#34;&gt;How We Moved Our API From Ruby to Go and Saved Our Sanity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mitchellh.com/apple-the-key-to-my-success&#34;&gt;APPLE: My Key to Success&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jmoiron.net/blog/thoughts-on-timeseries-databases/&#34;&gt;Thoughts on Time-series Databases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kismatic.com/company/qa-with-malte-schwarzkopf-on-distributed-systems-orchestration-in-the-modern-data-center/&#34;&gt;Omega, and what it means for Kubernetes: a Q&amp;amp;A about cluster scheduling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://boxfuse.com/blog/no-ssh.html&#34;&gt;Immutable Infrastructure: No SSH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mitchellh.com/automation-obsessed&#34;&gt;Automation Obsessed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jvns.ca/blog/2015/11/21/why-you-should-understand-a-little-about-tcp/&#34;&gt;Why you should understand (a little) about TCP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://misfra.me/2015/07/20/time-series-databases-discussion-notes/&#34;&gt;Time Series Databases Discussion Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dave.cheney.net/2015/11/05/lets-talk-about-logging&#34;&gt;Let&amp;rsquo;s talk about logging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://http2.cloudflare.com/the-story-of-one-latency-spike/&#34;&gt;The story of one latency spike&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html&#34;&gt;Linux Performance Analysis in 60,000 Milliseconds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.cloudflare.com/introducing-http2/&#34;&gt;HTTP/2 is here! Goodbye SPDY? Not quite yet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://composition.al/blog/2015/12/29/refactoring-as-a-way-to-understand-code/&#34;&gt;Refactoring as a way to understand code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.agner.org/optimize/blog/read.php?i=417&#34;&gt;Moores law hits the roof&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;blog-posts-by-me&#34;&gt;Blog posts by me&lt;/h2&gt;

&lt;p&gt;今年は30本の記事を書いた．大体月2-3本くらい．ほとんどが技術関連の記事だったが，趣味のCoffeeに関するものも2本ほど書いた．年間のPVは &lt;strong&gt;275,966&lt;/strong&gt; viewsだった．特に読まれたのは以下の記事．順番はPV順．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/02/17/docker-bad-points/&#34;&gt;Dockerの諸問題とRocket登場の経緯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/09/01/apache-kafka/&#34;&gt;Apache Kafkaに入門した&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/06/26/golang-dependency-vendoring/&#34;&gt;Go言語のDependency/Vendoringの問題と今後．gbあるいはGo1.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/03/17/serverspec-for-automation/&#34;&gt;デプロイ自動化とServerspec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/10/04/otto/&#34;&gt;Hashicorp Ottoを読む&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;特にある分野の現状の問題を整理した記事がよく読まれたと思う．このような記事は自分の頭も書くことで整理されたので良かった．&lt;/p&gt;

&lt;p&gt;2015年は後半になるにつれて長文の記事を書いてしまう傾向があった．2016年はダラダラと書くのではなく短くシンプルな記事を目指していきたい（&lt;a href=&#34;https://twitter.com/omo2009&#34;&gt;@omo2009&lt;/a&gt;さんの記事くらいの長さが目標）．2015年は1本だけ英語の記事を書いた（cf. &lt;a href=&#34;http://deeeet.com/writing/2015/05/11/gox-server/&#34;&gt;Golang Cross Compiler on Heroku (with Docker)&lt;/a&gt;）．2016年は英語の記事の量も増やしていきたい．&lt;/p&gt;

&lt;h2 id=&#34;presentations&#34;&gt;Presentations&lt;/h2&gt;

&lt;p&gt;今年印象に残った，影響を受けた発表．実際にカンファレンスで観れたもの，参加できなくて後日スライドのみを観たものを含む．順不同．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/yutakakinjyo/hackerscample-lt-49900119&#34;&gt;一度死んだ話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/kelseyhightower/cfgmgmtcamp-2015/slides/coreos-kubernetes.slide#1&#34;&gt;Managing Containers at Scale with CoreOS and Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/hayabusa333/ss-16114338&#34;&gt;漏れのある抽象化の法則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://talks.golang.org/2015/gogo.slide#1&#34;&gt;Go in Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/benbjohnson/raft-the-understandable-distributed-consensus-protocol&#34;&gt;Raft: The Understandable Distributed Consensus Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/pirhilton/how-to-name-things-the-hardest-problem-in-programming&#34;&gt;How to name things: the hardest problem in programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/a_matsuda/the-recipe-for-the-worlds-largest-rails-monolith&#34;&gt;he Recipe for the World&amp;rsquo;s Largest Rails Monolith&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/mirakui/developer-productivity-in-cookpad&#34;&gt;Developer Productivity in Cookpad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/taijitsuchiya5/ss-47398248&#34;&gt;なぜネットワーク運用自動化が進まないのか&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/jacopen/openpaas-paas&#34;&gt;ひしめき合うOpen PaaSを徹底解剖！ PaaSの今と未来&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://techblog.netflix.com/2015/08/netflix-at-velocity-2015-linux.html&#34;&gt;Velocity 2015 linux perf tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hitode909.hatenablog.com/entry/2015/08/21/165932&#34;&gt;Perlの上にも三年 〜 ずっとイケてるサービスを作り続ける技術 〜&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chibicode.com/sf-hell/&#34;&gt;#地獄のサンフランシスコ by @chibicode / 上杉周作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;presentations-by-me&#34;&gt;Presentations by me&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/tcnksm/talks&#34;&gt;github.com/tcnksm/talks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今年は9回発表をした．以下がスライド．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/coreoskurasutanidockerkontenawodepuroi-number-dockerjp&#34;&gt;&amp;ldquo;Deploy Docker Containers on CoreOS Cluster&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://connpass.com/event/10318/&#34;&gt;Docker Meetup Tokyo #4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/coreoskurasutafalsedockerkontenafalsejian-shi-number-monitoringcasual&#34;&gt;&amp;ldquo;Monitor Docker Containers on CoreOS Cluster&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://www.zusaar.com/event/9807003&#34;&gt;Monitoring Casual Talks #7&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/aruruo-shou-inhuraenziniafalsexian-zhuang-que-ren-number-wakateinfra&#34;&gt;&amp;ldquo;A wakete infra engineer&amp;rdquo;&lt;/a&gt; at Wakate Infra meetup&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/introduction-of-coreos-at-coreos-meetup-tokyo-number-1-number-coreosjp&#34;&gt;&amp;ldquo;Introduction of CoreOS&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://coreos-meetup-tokyo.connpass.com/event/12596/&#34;&gt;CoreOS meetup Tokyo #1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/what-i-talk-about-when-i-talk-about-cli-tool-by-golang-number-gocon&#34;&gt;&amp;ldquo;What I Talk About When I Talk About CLI Tool By Golang #gocon&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://gocon.connpass.com/event/14063/&#34;&gt;Go Conference 2015 Summer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/tcnksm/how-to-dev-and-ops-internal-paas&#34;&gt;&amp;ldquo;How to Dev&amp;amp;Ops Internal PaaS&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://www.zusaar.com/event/9057007&#34;&gt;Hosting Casual #2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/tcnksm/talks/2015/07/jtf2015.Slide#1&#34;&gt;&amp;ldquo;若手インフラエンジニアたちが語る技術トレンドと数年後の未来&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://2015.techfesta.jp/&#34;&gt;JTF2015&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/tcnksm/talks/2015/08/hashicorp-meetup.slide#1&#34;&gt;&amp;ldquo;Go pakcages from Hashicorp&amp;rdquo;&lt;/a&gt; at &lt;a href=&#34;http://engineer.wantedly.com/2015/08/06/hashicorp-product-meetup.html&#34;&gt;Hashicorp Meetup&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今年は特に&lt;a href=&#34;https://twitter.com/hashtag/wakateinfra&#34;&gt;#wakateinfra&lt;/a&gt;として同年代の人と知り合いになれたのがとても良かった．&lt;/p&gt;

&lt;h2 id=&#34;podcasts&#34;&gt;Podcasts&lt;/h2&gt;

&lt;p&gt;好きだったPodcastエピソード．順不同．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mozaic.fm/post/133930208998/20-browser&#34;&gt;#20 Browser | mozaic.fm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://changelog.com/180/&#34;&gt;#180: Otto, Vagrant, and Automation with Mitchell Hashimoto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://changelog.com/168/&#34;&gt;#168: Prometheus and Service Monitoring with Julius Volz from SoundCloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://changelog.com/151/&#34;&gt;#151: Rust with Steve Klabnik and Yehuda Katz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/101/&#34;&gt;Rebuild: 101: Before And After Refactoring (Dice)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/99/&#34;&gt;Rebuild: 99: The Next Generation Of HTTP (kazuho)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/91/&#34;&gt;Rebuild: 91: The PHP Way (Naoya Ito)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/81/&#34;&gt;Rebuild: 81: Enable The Broken Web (Hajime Morrita)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通勤時間が短くなった影響もあり以前よりも多くを聴けなくなった．2016年は運動をもう少し増やしてその間に聴こうという作戦がある．&lt;/p&gt;

&lt;h2 id=&#34;podcasts-by-me&#34;&gt;Podcasts by me&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://rebuild.fm/83/&#34;&gt;Rebuild: 83: Living In A Container&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2015年の最大のイベントは&lt;a href=&#34;http://rebuild.fm/&#34;&gt;rebuild.fm&lt;/a&gt;に出演したことだと思う．普段やっているプレゼンとは勝手が違いとにかく喋るのは難しかった（NaoyaさんにPodcastでうまく喋る方法をブログに書いてもらいたい）．2016年は自分でもPodcastを始めてみたいという妄想はしている．そういうので喋りを鍛えたい．&lt;/p&gt;

&lt;h2 id=&#34;papers-read&#34;&gt;Papers read&lt;/h2&gt;

&lt;p&gt;今年読んだ論文．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sites.computer.org/debull/A12june/pipeline.pdf&#34;&gt;Building LinkedIn&amp;rsquo;s Real-time Activity Data Pipeline&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ざっと目を通すのはいくつもあったがちゃんと読み込んだのは1本（これをまとめたのが&lt;a href=&#34;http://deeeet.com/writing/2015/09/01/apache-kafka/&#34;&gt;&amp;ldquo;Apache Kafkaに入門した&amp;rdquo;&lt;/a&gt;）．来年はもっと論文のインプットを増やしたい．とりあえず抑えるべき会議を抑え，読む習慣をつけたい．&lt;/p&gt;

&lt;h2 id=&#34;books-read&#34;&gt;Books read&lt;/h2&gt;

&lt;p&gt;今年読んだ本で良かったものをランキングで．&lt;/p&gt;

&lt;h3 id=&#34;tech&#34;&gt;Tech&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B0184N7WWS&#34;&gt;The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4254127057&#34;&gt;オペレーティングシステムの仕組み&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4797382228&#34;&gt;暗号技術入門 第3版 秘密の国のアリス&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;non-tech&#34;&gt;Non-tech&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/425500613X&#34;&gt;暇と退屈の倫理学&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4403120245&#34;&gt;スクリプトドクターの脚本教室・初級篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4576151142&#34;&gt;１４歳からの哲学入門&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4884184432&#34;&gt;職業としての小説家&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/4344026241&#34;&gt;僕がコントや演劇のために考えていること&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;とにかく読書量が少なかった．2016年はアウトプットよりもインプットを重視したい．&lt;/p&gt;

&lt;h2 id=&#34;music&#34;&gt;Music&lt;/h2&gt;

&lt;p&gt;今年好きだった音楽をランキングで．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Oneohtrix Point Never - &lt;a href=&#34;https://www.youtube.com/watch?v=jt5tRaV3iY0&#34;&gt;&amp;ldquo;Garden of Delete&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Swindle - &lt;a href=&#34;http://peaceloveandmusic.info/&#34;&gt;&amp;ldquo;Peace, Love &amp;amp; Music&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Slack - &lt;a href=&#34;https://www.youtube.com/watch?v=OD7s62BTy9M&#34;&gt;&amp;ldquo;My Space&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kamasi Washington - &lt;a href=&#34;https://www.youtube.com/watch?v=NtQRBzSN9Vw&#34;&gt;&amp;ldquo;The Epic&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jam City - &lt;a href=&#34;https://www.youtube.com/watch?v=CiFbb6Waj_A&#34;&gt;&amp;ldquo;Dream A Garden&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Floating Points - &lt;a href=&#34;https://www.youtube.com/watch?v=5ntcVE3AQsg&#34;&gt;&amp;ldquo;Elaenia&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Clap! Clap! - &lt;a href=&#34;https://www.youtube.com/watch?v=5etsDAlRTdg&#34;&gt;&amp;ldquo;Simple&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Battles - &lt;a href=&#34;https://www.youtube.com/watch?v=bkhLzHuUYmo&#34;&gt;&amp;ldquo;La Di Da Di&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jamie xx - &lt;a href=&#34;https://www.youtube.com/watch?v=TP9luRtEqjc&#34;&gt;&amp;ldquo;In Colour&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kitty, Daisy &amp;amp; Lewvis - &lt;a href=&#34;https://www.youtube.com/watch?v=9ASLWuIPXGc&#34;&gt;&amp;ldquo;The third&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;過去&#34;&gt;過去&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/12/31/music-2014/&#34;&gt;Best Music 2014&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2013/12/31/music-2013/&#34;&gt;Best Music 2013&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2012/12/31/music-2012/&#34;&gt;Best Music 2012&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;movie&#34;&gt;Movie&lt;/h2&gt;

&lt;p&gt;今年観て好きだった映画をランキングで．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;George Miller - &lt;a href=&#34;http://www.madmaxmovie.com/&#34;&gt;&amp;ldquo;MAD MAX: FURY ROAD&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;是枝裕和 - &lt;a href=&#34;http://umimachi.gaga.ne.jp/&#34;&gt;&amp;ldquo;海街diary&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Paul Thomas Anderson - &lt;a href=&#34;http://wwws.warnerbros.co.jp/inherent-vice/&#34;&gt;&amp;ldquo;Inherent Vice&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dan Gilroy - &lt;a href=&#34;http://nightcrawler.gaga.ne.jp/&#34;&gt;&amp;ldquo;Nightcrawler&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;J.J. Abrams - &lt;a href=&#34;http://www.starwars.com/the-force-awakens/&#34;&gt;&amp;ldquo;Star Wars: The Force Awakens&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Go言語でファジング</title>
      <link>http://deeeet.com/writing/2015/12/21/go-fuzz/</link>
      <pubDate>Mon, 21 Dec 2015 00:25:30 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2015/12/21/go-fuzz/</guid>
      <description>

&lt;p&gt;この記事は&lt;a href=&#34;http://qiita.com/advent-calendar/2015/go&#34;&gt;Go Advent Calendar 2015&lt;/a&gt;の21日目の記事です．&lt;/p&gt;

&lt;p&gt;今年もGoコミュニティーから多くのツールが登場した．その中でも異彩を放っていたのがGoogleのDynamic testing toolsチームの&lt;a href=&#34;https://twitter.com/dvyukov&#34;&gt;@dvyukov&lt;/a&gt;氏による&lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;go-fuzz&lt;/a&gt;である．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go-fuzz&lt;/code&gt;はGo関数のファジングを行うツールである．このツールはとても強力で標準パッケージで100以上，&lt;a href=&#34;golang.org/x/&#34;&gt;golang.org/x/&lt;/a&gt;パッケージで40以上，その他を含めると300以上のバグを発見するという実績を残している（cf. &lt;a href=&#34;https://github.com/dvyukov/go-fuzz#trophies&#34;&gt;Trophies&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;本記事ではこの&lt;code&gt;go-fuzz&lt;/code&gt;の紹介を行う．&lt;/p&gt;

&lt;h2 id=&#34;ファジングとは&#34;&gt;ファジングとは?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fuzz_testing&#34;&gt;Fuzz testing - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/dev/feature/01/fuzzing&#34;&gt;ソフトウェアの脆弱性検出におけるファジングの活用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;「ファジング」とはソフトウェアのテスト手法である．テスト対象となるソフトウェアにランダムなデータを大量に入力し意図しない挙動を検出する．&lt;/p&gt;

&lt;p&gt;普通のソフトウェアは予期しないデータを受けても適切な処理，例えばエラーを返すなど，を行う．そしてそれはテストされる．しかし予期しない入力をすべてテストすることは難しい．適切に処理しているつもりであっても予期しないデータによりソフトウェアがクラッシュしてしまうことはありうる．このようなテストでファジングは光る．大量のランダムデータを入力し予期しないクラッシュを見つける．&lt;/p&gt;

&lt;p&gt;ファジングの利点に以下が挙げられる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;チープである&lt;/li&gt;
&lt;li&gt;バイアスがない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まずファジングは単純にランダムなデータを放り込むだけなので非常にチープな手法である．使うだけなら特別な知識は必要ない．次にランダムであるためテスターのバイアスがない．そのソフトウェアをつくっているひとほど思い込みが強くなってしまう（と思う）が，そのようなバイアスを排除することができる．&lt;/p&gt;

&lt;p&gt;ファジングで入力となるデータは「ファズ」と呼ばれる．コマンドラインツールであれば引数や環境変数，ウェブサーバーであればHTTPリクエストである．ファジングではこのファズをいかに生成するのかが重要になる．完全にランダムにする，指定の範囲内で連続に値を変化させる，正常なデータの一部を変更させる．ある特定の制御文字列を対象にするといった手法がある．&lt;/p&gt;

&lt;h2 id=&#34;go-fuzzとは&#34;&gt;go-fuzzとは?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;dvyukov/go-fuzz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=a9xrxRsIbSU&#34;&gt;GopherCon 2015: Dmitry Vyukov - Go Dynamic Tools&lt;/a&gt; (&lt;a href=&#34;https://talks.golang.org/2015/dynamic-tools.slide#1&#34;&gt;Slide&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Go言語の関数に対してファジングを行うために開発されたのが&lt;code&gt;go-fuzz&lt;/code&gt;である．&lt;code&gt;go-fuzz&lt;/code&gt;はC/C++の&lt;a href=&#34;http://lcamtuf.coredump.cx/afl/&#34;&gt;afl-fuzz&lt;/a&gt;がベースになっている．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go-fuzz&lt;/code&gt;は完全にランダムなデータを入力するのではなく，正常なデータの一部を変更させランダムなデータを生成する．これにより単純にランダムな値で盲目的にテストをするのではなく，ある程度「ありそうな」データでテストを行うことができる．このためのデータセットをcorpusと呼び，&lt;code&gt;go-fuzz&lt;/code&gt;はテストを繰り返しながらこのcorpusを成長させていく．&lt;/p&gt;

&lt;p&gt;corpusはどのように成長するのか? &lt;code&gt;go-fuzz&lt;/code&gt;は&lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;AST&lt;/a&gt;を使い対象関数のテストのカバレッジ情報を取得する．カバレッジを上げるような入力が得られればそれをcorpusに登録する．これによりテストはより網羅的になる．&lt;/p&gt;

&lt;p&gt;corpusは事前に与えることもできる．例えば対象とする関数の入力が画像データである場合は事前に幾つかの画像データを与えることができる．もしくはユニットテストなどで既にテストしている値を使うこともできる．&lt;/p&gt;

&lt;p&gt;入力を繰り返し意図しない挙動が得られる（例えばpanicが起こる）と&lt;code&gt;go-fuzz&lt;/code&gt;はそれを引き起こした入力とスタックトレースをファイルとして保存する．開発者はその結果をもとに新たにユニットテストを追加しコードを修正していく．&lt;/p&gt;

&lt;h3 id=&#34;使いかた&#34;&gt;使いかた&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go-fuzz&lt;/code&gt;によるファジングには以下の2つが必要である&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fuzz()&lt;/code&gt;関数の準備&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go-fuzz-buid&lt;/code&gt;と&lt;code&gt;go-fuzz&lt;/code&gt;の実行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;まず&lt;code&gt;Fuzz()&lt;/code&gt;関数は以下のような関数である．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Fuzz(data []byte) int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;data&lt;/code&gt;は&lt;code&gt;go-fuzz&lt;/code&gt;によって与えられるランダムな値である（ほとんどはinvalidな値である）．そしてこの値をテストしたい関数に入力として与える．&lt;code&gt;go-fuzz&lt;/code&gt;はこの入力で関数が&lt;code&gt;panic&lt;/code&gt;したりクラッシュしたり，メモリを割り当てすぎてhangしないかを監視する．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Fuzz()&lt;/code&gt;の返り値はcorpusの作成に使われる．以下の3つの値のうちどれかを返す．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt;- 入力がふさわしいデータであると考えられる場合（例えば関数がエラーを返さずに正常に処理された場合その入力はその関数にとってふさわしい入力であると考えることができる．ここから新たなランダムな値を生成すれば新たなエラーを発見できる可能性が高い）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-1&lt;/code&gt; - 入力がカバレッジを上げるようなふさわしい入力であると考えられてもcorpusには追加したくない場合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; - 上記以外の場合（例えばエラーが返った場合）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;関数が書けたら以下で専用のバイナリをつくる．&lt;code&gt;zip&lt;/code&gt;形式で出力される．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-fuzz-build pkg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして以下でテストを実行する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-fuzz -bin=pkg_fuzz.zip -workdir=dir 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-bin&lt;/code&gt;に上で生成したバイナリを指定する．テストは止めるまで無限に実行される．corpusやテストの結果は&lt;code&gt;-workdir&lt;/code&gt;で指定するディレクトリに出力される．例えばプログラムをクラッシュさせるような入力が得られた場合は&lt;code&gt;crashers/&lt;/code&gt;ディレクトリ内にその値とスタックトレースがファイルとして出力される．&lt;/p&gt;

&lt;p&gt;ちなみに作成されたcorpusはバージョン管理システムに保存するべきである．そうすれば他の人もそれを再利用することができる．&lt;/p&gt;

&lt;h2 id=&#34;使ってみる&#34;&gt;使ってみる&lt;/h2&gt;

&lt;p&gt;言葉だけでは分かり難いので実際に使ってみる．例えば以下のような関数をテストしてみる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func CoolFunc(str string) error {

if len(str) &amp;lt; 1 {
    return fmt.Errorf(&amp;quot;Input must not be empty&amp;quot;)
}

if str[0] != &#39;A&#39; {
    return fmt.Errorf(&amp;quot;Input must start with A&amp;quot;)
}

// Super cool processing.

// Bug hard to find !
if str == &amp;quot;ABCD&amp;quot; {
    panic(&amp;quot;input must not be ABCD&amp;quot;)
}

return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この関数は文字列を受け取ってめちゃめちゃクールな処理を行う．長さ0の文字列の入力は許容しない．また&lt;code&gt;A&lt;/code&gt;で始まる文字列ではエラーが発生することまではわかっていおり適切にハンドルがされている．そして&lt;code&gt;ABCD&lt;/code&gt;という値が入力されたときのみなぜか関数がクラッシュするというバグが混入しているとする．以下ではこのバグをファジングで発見する（当たり前だが普通はそもそもこのようなバグがあることは事前にわからない）．&lt;/p&gt;

&lt;p&gt;まず&lt;code&gt;Fuzz()&lt;/code&gt;は以下のようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// +build gofuzz

func Fuzz(data []byte) int {
    if err := CoolFunc(string(data)); err != nil {
        return 0
    }
    return 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;エラーのときはすでにそれは適切にハンドルされているので&lt;code&gt;0&lt;/code&gt;を返す．正常に動作した場合は&lt;code&gt;1&lt;/code&gt;を返してcorpusの生成に利用するようにする．&lt;/p&gt;

&lt;p&gt;ビルドしてファジングを実行する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-fuzz-build github.com/tcnksm-sample/go-fuzz
$ go-fuzz -bin=pkg-fuzz.zip -workdir=workdir
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実行すると以下のような出力が得られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;2015/12/20 21:23:54 slaves: 4, corpus: 3 (2s ago), crashers: 1, restarts: 1/0, execs: 0 (0/sec), cover: 0, uptime: 3s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;crashers:　1&lt;/code&gt;とあり関数をクラッシュさせるような入力が得られたことがわかる．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;workdir/crashers&lt;/code&gt;をみると以下のようなファイルが生成されている．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;workdir/crashers
├── fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6
├── fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6.output
└── fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6.quoted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず拡張子がないファイルは具体的に関数をクラッシュさせた入力が含まれている（&lt;code&gt;.quoted&lt;/code&gt;はその入力を&amp;rdquo;&amp;ldquo;で囲ったもの）．この場合は&lt;code&gt;ABCD&lt;/code&gt;が得られる．そして&lt;code&gt;.output&lt;/code&gt;ファイルにはその際のスタックトレースが出力される．今回は以下のような出力が得られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat workdir/crashers/fb2f85c88567f3c8ce9b799c7c54642d0c7b41f6.output
panic: input must not be ABCD

goroutine 1 [running]:
github.com/tcnksm-sample/go-fuzz.CoolFunc(0x820267e78, 0x4, 0x0, 0x0)
....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;クラッシュが得られたどうするか? まずユニットテストにその入力を追加する．そしてコードを修正し適切にハンドルされるようにする．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;自分のつくっているいくつかのツールでも試してみたが残念ながら面白いバグを発見することはできなかった（特に複雑なことをしていないというものあるが..）．&lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/go-fuzz/&#34;&gt;ユーザの入力を受けるソフトウェアはすべてファジングするべき&lt;/a&gt;という意見もある．会社で書いているソフトウェアにもファジングを導入していきたいと思う．ファジングはとにかく簡単なので導入は容易だと思う．&lt;/p&gt;

&lt;p&gt;OSSのツールに対してファジングでバグを発見してコミットを行う実践的な方法は&lt;a href=&#34;https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c#.2s399y3sg&#34;&gt;&amp;ldquo;go-fuzz github.com/arolek/ase&amp;rdquo;&lt;/a&gt;が詳しい．&lt;/p&gt;

&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dvyukov/go-fuzz&#34;&gt;dvyukov/go-fuzz&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fuzz_testing&#34;&gt;Fuzz testing - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gihyo.jp/dev/feature/01/fuzzing&#34;&gt;ソフトウェアの脆弱性検出におけるファジングの活用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=a9xrxRsIbSU&#34;&gt;GopherCon 2015: Dmitry Vyukov - Go Dynamic Tools&lt;/a&gt; (&lt;a href=&#34;https://talks.golang.org/2015/dynamic-tools.slide#1&#34;&gt;Slide&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lcamtuf.coredump.cx/afl/&#34;&gt;american fuzzy lop (1.96b)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.cloudflare.com/dns-parser-meet-go-fuzzer/&#34;&gt;DNS parser, meet Go fuzzer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/filosottile/automated-testing-with-go-fuzz&#34;&gt;Automated Testing with go-fuzz // Speaker Deck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c#.2s399y3sg&#34;&gt;go-fuzz github.com/arolek/ase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/go-fuzz/&#34;&gt;Go Fuzz&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>