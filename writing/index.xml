<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Writings on SOTA</title>
    <link>http://deeeet.com/writing/index.xml</link>
    <description>Recent content in Writings on SOTA</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>Copyright (C) 2013-2015 Taichi Nakashima All Right Reserved.</copyright>
    <lastBuildDate>Thu, 12 Jan 2017 17:06:29 +0900</lastBuildDate>
    <atom:link href="http://deeeet.com/writing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Writing An Interpreter In Goを読んだ</title>
      <link>http://deeeet.com/writing/2017/01/12/go-interpreter/</link>
      <pubDate>Thu, 12 Jan 2017 17:06:29 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2017/01/12/go-interpreter/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://twitter.com/thorstenball&#34;&gt;Thorsten Ball&lt;/a&gt;による&lt;a href=&#34;https://interpreterbook.com/&#34;&gt;&amp;ldquo;Writing An Interpreter In Go&amp;rdquo;&lt;/a&gt;を読んだ．&lt;/p&gt;

&lt;p&gt;技術界隈のブログを見ているとたまにSteve Yeggeの「If you don’t know how compilers work, then you don’t know how computers work」という言葉に出会う．その度に学生のときにコンパイラの授業を受けなかったこと後悔し，社会人になって挑戦しようとして挫折したことを思い出して悲しい気持ちになる．&lt;a href=&#34;https://twitter.com/rui314&#34;&gt;@rui314&lt;/a&gt;さんの&lt;a href=&#34;http://qiita.com/ruiu/items/4d471216b71ab48d8b74&#34;&gt;Cコンパイラをスクラッチから開発してみた&lt;/a&gt;を読んではかっこいいなと思いつつ僕には無理だなあと心が折れていた．&lt;/p&gt;

&lt;p&gt;どの言語を書いていてもコンパイラ（もしくはInterpreter）は切っても離せないものであり内部の動きがどうなっているかを知っておきたいという欲求はプログラマーなら誰しもあると思う（少なくとも僕にはある）．では他にも学ぶことがたくさんあるという時間制約の中でベストな学習リソースは何かと言われると自分の観測範囲ではなかなか良いものに出会うことはなかった．&lt;a href=&#34;https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools&#34;&gt;Dragon Book&lt;/a&gt;は重すぎるしLispの処理系をx行のRubyで書いて見ました系ブログは軽すぎる．&lt;/p&gt;

&lt;p&gt;本書&lt;a href=&#34;https://interpreterbook.com/&#34;&gt;&amp;ldquo;Writing An Interpreter In Go&amp;rdquo;&lt;/a&gt;はその1000ページのコンパイラ本と個人ブログのギャップを埋めるために書かれた本である．紙の本にした200ページ程度でさっと読める．なんちゃって言語を実装するのではなくMonkeyという本書のためにデザインされたある程度まともな言語（C言語っぽい）を実装する．スクラッチから初めてLexer，Parser， Evaluationを実装していく（HostにGolangを使うのでアセンブラなどまでは踏み込まない）．テストまでちゃんと書くとだいたい2000行程度で実装できた（時間にするとだいたい1週間程度）．&lt;/p&gt;

&lt;p&gt;本書の利点を挙げると，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;サンプルコードがGolangで書かれている（かつ標準パッケージのみが使われている）．Golangはとにかく言語仕様のシンプルであるため本書のサンプルコードを読むのはとても簡単である．また自分の好きな言語に移植するのも容易であると思う．&lt;/li&gt;
&lt;li&gt;サンプルコードを動かしながら読み進めることができる．最新のGolangのruntimeで動かすことができるので環境を準備するのはたやすい．Lexerを書けばここまでできて，Parserを書けばここまでできて&amp;hellip;と読むことができて理解度が高い．&lt;/li&gt;
&lt;li&gt;テスト駆動で書かれている．本書に登場するコードはすべてテストもセットになっている．テストのおかげで何を期待するのかをすぐに理解することができた．またテストはGolangのベストプラクティスである&lt;a href=&#34;https://github.com/golang/go/wiki/TableDrivenTests&#34;&gt;Table Driven Tests&lt;/a&gt;が採用されているため読みやすい（ただし途中でテストも写経するのはめんどくなった&amp;hellip;）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらの利点以上に感動したのが本書の書き方である．そもそも作者はコンパイラを職業にしているひとではない．個人的なpassionでコンパイラについて知識を深めてきたひとである（詳しくは作者が出演した&lt;a href=&#34;https://changelog.com/gotime/28&#34;&gt;Go time #28&lt;/a&gt; を参考）．そのために前提がとても優しい．僕のようなゴリゴリのCS出身ではないプログラマが疑問に思うことを一つ一つちゃんと拾ってくれる（書き方も柔らかくて「これ疑問に思ったっしょ？次にちゃんと説明するから！」的に書かれていて良い）．&lt;/p&gt;

&lt;p&gt;表層的な部分だけでなくて内容に少し触れておくと，本書で一番面白かった・感動したのはParserの実装である．Paserは実装するのではなくyaccやbisonなどのParser generatorを使うのが一般的らしいが本書ではそれらのツールを使わない．すべて自分で1から実装する．特にExpressionをParseするための&lt;a href=&#34;http://javascript.crockford.com/tdop/tdop.html&#34;&gt;Pratt parser&lt;/a&gt;（JSLintで使われている）は他のParserを知らないため比較はできないがとにかくシンプルで感動した（デバッグとかしんどいしPaser generator使わなくてもシンプルにできるよという話もある&lt;a href=&#34;https://blog.gopheracademy.com/advent-2014/parsers-lexers/&#34;&gt;Handwritten Parsers &amp;amp; Lexers in Go&lt;/a&gt;．実際自分で書いたりGolangの実装を覗いたりしてみるとシンプルなものなら自分で書いても良いのでは?という気持ちにはなった）．&lt;/p&gt;

&lt;p&gt;あとGolangを書いているひとにオススメなのはGolangのコンパイラ実装である&lt;a href=&#34;https://golang.org/pkg/go/&#34;&gt;https://golang.org/pkg/go/&lt;/a&gt;と合わせて読むこと．名前のつけ方が似てるので比較しながらコードを追うことができとても勉強になる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;コンパイラのことがわかったのかと言われるとまだまだ自信を持ってYesとは答えられない．が全く知らないという状況は抜け出したと思う．前よりも恐れがなくなったというか身近に感じている．これを入り口にしてさらに専門的な本を読んでみようという意欲も湧いている．とにかく読んでよかった．&lt;/p&gt;

&lt;p&gt;少しでもコンパイラに興味があり入り口が見つけられない人は是非手にとると良いと思う．オススメです！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2016年振り返り</title>
      <link>http://deeeet.com/writing/2016/12/31/2016/</link>
      <pubDate>Sat, 31 Dec 2016 13:16:08 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/12/31/2016/</guid>
      <description>

&lt;p&gt;最初に今年やったことなどをつらつらと書いてみる．&lt;/p&gt;

&lt;p&gt;2月．Dave Cheneyが中心となりGo1.6のRelease Partyが世界各地で開催されることになった（&lt;a href=&#34;https://github.com/golang/go/wiki/Go-1.6-release-party&#34;&gt;Go 1.6 release party&lt;/a&gt;）．東京でもやりたかったのでOrganizerとなりHatenaのオフィスを借りて&lt;a href=&#34;https://gocon.connpass.com/event/26572/&#34;&gt;開催した&lt;/a&gt;．8月のGo1.7のリリース時は特に世界規模でやる流れはなかったがフォーマットだけは借りて再びHatenaのオフィスで&lt;a href=&#34;https://gocon.connpass.com/event/37332/&#34;&gt;開催した&lt;/a&gt;．この時&lt;a href=&#34;http://go-talks.appspot.com/github.com/tcnksm/talks/2016/08/go1.7/go1.7.slide#1&#34;&gt;リリースの概要をまとめたスライド&lt;/a&gt;を作ったが&lt;a href=&#34;https://twitter.com/bradfitz&#34;&gt;@bradfitz&lt;/a&gt;がそれを改変して&lt;a href=&#34;https://www.youtube.com/watch?v=8cQcPnzfkLk&#34;&gt;別のMeetupの発表資料に使ってくれた&lt;/a&gt;嬉しかった．2017年2月にリリース予定のGo1.8のリリース時は再び世界規模でやるかってのをDaveと話したのでぜひ参加してください．&lt;/p&gt;

&lt;p&gt;5月．&lt;a href=&#34;https://www.amazon.co.jp/dp/477418392X&#34;&gt;みんなのGo言語&lt;/a&gt;の執筆を主に行っていた．自分はコマンドラインツールに関する章を担当した．今まで発表やブログ記事の集大成的に書けたので良かった．（村上春樹の手法を真似て）朝5時に起きて午前中のみ/決められた分量のみに集中するという方法で書き進めたがうまくいった気がする．9月に販売したが概ね高評価でとても嬉しい（ブログなどは基本見つけたものは目を通してます！ありがとうございます）．日本語だけどDaveやGo teamの&lt;a href=&#34;https://twitter.com/rakyll&#34;&gt;@rakyll&lt;/a&gt;にも&lt;a href=&#34;https://twitter.com/rakyll/status/776227124642353152&#34;&gt;手に取ってもらえた&lt;/a&gt;．&lt;/p&gt;

&lt;p&gt;6月．ドイツのBambergにある支社で2週間ほど働いた．本社のメインチームと離れてリモート側になった時の&lt;a href=&#34;https://twitter.com/deeeet/status/743747017340444672&#34;&gt;問題&lt;/a&gt;を身にしみて感じた．Bambergはかなり田舎でみながゆっくりと生活していた．同僚とひたすらビールを飲んでいた．Berlinも休日を使って訪問したが町中からエネルギーを感じて良い街だった．いつか住んでみたい．&lt;/p&gt;

&lt;p&gt;7月．Devenverで開催されたGopherConに参加した．有名な（プロジェクトの）開発者が普通にうろうろしている状況でとても刺激的だった．自分もLTの舞台で発表した（詳しくは&lt;a href=&#34;http://deeeet.com/writing/2016/07/12/gophercon2016-lt/&#34;&gt;GopherCon 2016でLTした&lt;/a&gt;に書いた．&lt;a href=&#34;https://www.youtube.com/watch?v=PaVyMSgWUmk&amp;amp;t=1s&amp;amp;index=15&amp;amp;list=PL2ntRZ1ySWBfdNd2SHwX2eMyFWKW_zfAq&#34;&gt;動画もある&lt;/a&gt;）．次は通常セッションで参加したい．&lt;/p&gt;

&lt;p&gt;12月．golang.tokyoで&lt;a href=&#34;https://talks.godoc.org/github.com/tcnksm/talks/2016/12/golang-tokyo/golang-tokyo.slide#1&#34;&gt;テストしやすいGoコードのデザイン&lt;/a&gt;という発表をした．自分が今のチームでコードを書く時に/レビューをするときに意識してきたことをまとめて発表する良い機会だった．こちらも良いフィードバックをもらえたので嬉しかった．&lt;/p&gt;

&lt;p&gt;そして12月31日をもってRakutenを退職した．新天地でも引き続きやっていきます！&lt;/p&gt;

&lt;h2 id=&#34;書いた記事&#34;&gt;書いた記事&lt;/h2&gt;

&lt;p&gt;今年はアウトプットよりもインプットを重視したため去年の半分の14本だった．年間PVは&lt;strong&gt;229,231&lt;/strong&gt; viewsだった．特に読まれたのは以下の記事．順番はPV順．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2016/04/25/go-pkg-errors/&#34;&gt;Golangのエラー処理とpkg/errors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2016/05/08/gogc-2016/&#34;&gt;GolangのGCを追う&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2016/11/01/go-api-client/&#34;&gt;GolangでAPI Clientを実装する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2016/07/22/context/&#34;&gt;Go1.7のcontextパッケージ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2016/10/25/go-interface-testing/&#34;&gt;Golangにおけるinterfaceをつかったテスト技法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;英語で書いた記事は&lt;a href=&#34;https://medium.com/@deeeet/trancing-http-request-latency-in-golang-65b2463f548c#.hhiryhd62&#34;&gt;Tracing HTTP request latency in golang&lt;/a&gt;が多く読まれた．&lt;/p&gt;

&lt;p&gt;来年も引き続きインプット重視の予定なので今年同様に月1本程度書けると良い．&lt;/p&gt;

&lt;h2 id=&#34;公開したoss&#34;&gt;公開したOSS&lt;/h2&gt;

&lt;p&gt;OSSとしては以下を書いた．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tcnksm/gotests&#34;&gt;https://github.com/tcnksm/gotests&lt;/a&gt; (★254)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tcnksm/go-input&#34;&gt;https://github.com/tcnksm/go-input&lt;/a&gt; (★147)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tcnksm/go-httpstat&#34;&gt;https://github.com/tcnksm/go-httpstat&lt;/a&gt; (★115)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tcnksm/dutyme&#34;&gt;https://github.com/tcnksm/dutyme&lt;/a&gt; (★17)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tcnksm/go-irkit&#34;&gt;https://github.com/tcnksm/go-irkit&lt;/a&gt; (★6)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上の3つは&lt;a href=&#34;http://golangweekly.com/&#34;&gt;Go Newsletter&lt;/a&gt;でも取り上げてもらえた．&lt;/p&gt;

&lt;h2 id=&#34;良かった記事&#34;&gt;良かった記事&lt;/h2&gt;

&lt;p&gt;良いと思った記事や発表はブクマで記録してるが今年は1000ほどあった．その中でも特に印象に残ったのは以下（Golangに関しては多かったので別途まとめた &lt;a href=&#34;http://qiita.com/deeeet/items/abf95bca835b1af146dd&#34;&gt;良かったGolangの記事/発表（2016年）&lt;/a&gt;）．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.joyent.com/blog/unikernels-are-unfit-for-production&#34;&gt;Unikernels are unfit for production - Blog - Joyent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://techblog.netflix.com/2016/02/evolution-of-netflix-data-pipeline.html&#34;&gt;The Netflix Tech Blog: Evolution of the Netflix Data Pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yosuke-furukawa.hatenablog.com/entry/2016/03/27/152500&#34;&gt;JavaScriptの文化とleftpadの話とpadStartについて - from scratch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/the-mission/your-life-is-tetris-stop-playing-it-like-chess-4baac6b2750d#.kotsna4zo&#34;&gt;Your Life Is Tetris. Stop Playing It Like Chess. – The Mission – Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yunazuno.hatenablog.com/entry/2016/02/29/090001&#34;&gt;ロードバランサのアーキテクチャいろいろ - yunazuno.log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.cloudflare.com/cloudflares-impact-on-the-http-2-universe/&#34;&gt;CloudFlare’s Impact On The HTTP/2 “Universe”&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mikeperham.com/2016/02/09/kill-your-dependencies/&#34;&gt;Kill Your Dependencies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.allthingsdistributed.com/2016/03/10-lessons-from-10-years-of-aws.html&#34;&gt;10 Lessons from 10 Years of Amazon Web Services - All Things Distributed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudplatform.googleblog.com/2016/04/lessons-from-a-Google-App-Engine-SRE-on-how-to-serve-over-100-billion-requests-per-day.html&#34;&gt;Google Cloud Platform Blog: Lessons from a Google App Engine SRE on how to serve over 100 billion requests per day&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mizzy.org/blog/2016/04/22/1/&#34;&gt;Infrastructure as Code 再考 - Gosuke Miyashita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.instagram.com/continuous-deployment-at-instagram-1e18548f01d1#.159uroj58&#34;&gt;Continuous Deployment at Instagram&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://lowreal.net/2016/04/13/2&#34;&gt;筋の悪さ | Wed, Apr 13. 2016 - 氾濫原&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.posteriorscience.net/?p=206&#34;&gt;Programming by poking: why MIT stopped teaching SICP | posterior science&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.yuuk.io/entry/google-linux-distribution-live-upgrade&#34;&gt;Googleが数千台もある10年前のLinuxディストリをライブアップグレードした話 - ゆううきブログ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://code.facebook.com/posts/218678814984400/scaling-mercurial-at-facebook/&#34;&gt;Scaling Mercurial at Facebook | Engineering Blog | Facebook Code | Facebook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/&#34;&gt;Long Names Are Long – journal.stuffwithstuff.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/jvns/learning-systems-programming-with-rust&#34;&gt;Learning systems programming with Rust by Julia Evans&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.facebook.com/notes/kent-beck/mastering-programming/1184427814923414/&#34;&gt;Mastering Programming by Kent Beck&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jvns.ca/blog/2016/10/26/running-container-without-docker/&#34;&gt;Running containers without Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stripe.com/blog/service-discovery-at-stripe&#34;&gt;Service discovery at Stripe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lucumr.pocoo.org/2016/11/5/be-careful-about-what-you-dislike/&#34;&gt;Be Careful About What You Dislike | Armin Ronacher&amp;rsquo;s Thoughts and Writings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@adriaandejonge/moving-from-docker-to-rkt-310dc9aec938#.awtsfebd3&#34;&gt;Moving from Docker to rkt — Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudplatform.googleblog.com/2016/09/bringing-Pokemon-GO-to-life-on-Google-Cloud.html&#34;&gt;Google Cloud Platform Blog: Bringing Pokémon GO to life on Google Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@voluntas/http-api-%E3%81%AE%E8%A8%AD%E8%A8%88%E6%96%B9%E5%90%91-7ccaca671d9d#.7tj2xw7es&#34;&gt;HTTP API の設計方向 – Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cockroachlabs.com/blog/cockroachdb-stability-from-1-node-to-100-nodes/&#34;&gt;CockroachDB Stability Post-Mortem: From 1 Node to 100 Nodes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docker-saigon.github.io/post/Docker-Internals/&#34;&gt;Docker Internals &amp;ndash; Docker Saigon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.lucas-nussbaum.net/blog/?p=916&#34;&gt;The Linux 2.5, Ruby 1.9 and Python 3 release management anti-pattern | Lucas Nussbaum’s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bellflower.dodgson.org/%E4%B8%8D%E7%A2%BA%E5%AE%9F%E3%81%95%E3%82%92%E5%8F%97%E3%81%91%E5%85%A5%E3%82%8C%E3%82%8B-a17y-1-2640c529bc61#.yxpcp380g&#34;&gt;不確実さを受け入れる — A17Y (1) – To Phantasien&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;良かった本&#34;&gt;良かった本&lt;/h2&gt;

&lt;p&gt;今年読んで良かった技術関連の本は以下の3冊が良かった．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/Systems-Performance-Enterprise-Brendan-Gregg-ebook/dp/B00FLYU9T2&#34;&gt;Systems Performance: Enterprise and the Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://interpreterbook.com/&#34;&gt;Writing An Interpreter In Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4048930508&#34;&gt;Unix考古学 Truth of the Legend&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;とにかく今年の1冊はSystems Performanceだった（&lt;a href=&#34;http://deeeet.com/writing/2016/11/07/systems-performance/&#34;&gt;Systems Performance読んだ&lt;/a&gt;）．かなり重厚な本だったので読むのに半年以上かかった．こんな本に毎年出会いたい．&lt;/p&gt;

&lt;p&gt;技術以外では以下の5冊が良かった．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4903908763&#34;&gt;映画を撮りながら考えたこと&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4309264948&#34;&gt;ブラックマシンミュージック ディスコ、ハウス、デトロイトテクノ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4105393065&#34;&gt;数学者たちの楽園: 「ザ・シンプソンズ」を作った天才たち&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4773814047&#34;&gt;メキシコ麻薬戦争: アメリカ大陸を引き裂く「犯罪者」たちの叛乱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/dp/4781611001&#34;&gt;映画術 その演出はなぜ心をつかむのか&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;あと今読んでいる&lt;a href=&#34;https://www.amazon.co.jp/dp/B01LW7JZLC&#34;&gt;サピエンス全史&lt;/a&gt;が&lt;a href=&#34;https://www.amazon.co.jp/dp/4794218788&#34;&gt;銃・病原菌・鉄&lt;/a&gt;に匹敵する面白さだ．&lt;/p&gt;

&lt;h2 id=&#34;良かった映画&#34;&gt;良かった映画&lt;/h2&gt;

&lt;p&gt;今年は新旧含めて70-80本程度の映画を観た．今年公開の映画ベスト10は以下．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;永い言い訳&lt;/li&gt;
&lt;li&gt;ディストラクションベイビーズ&lt;/li&gt;
&lt;li&gt;サウルの息子&lt;/li&gt;
&lt;li&gt;カルテルランド&lt;/li&gt;
&lt;li&gt;この世界の片隅に&lt;/li&gt;
&lt;li&gt;シンゴジラ&lt;/li&gt;
&lt;li&gt;シビルウォー&lt;/li&gt;
&lt;li&gt;オデッセイ&lt;/li&gt;
&lt;li&gt;スティーブジョブズ&lt;/li&gt;
&lt;li&gt;追憶の森&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;やはり邦画が圧倒的にすごくて他にも良かったのは「ヒメアノ〜ル」「海よりもまだ深く」「日本で1番悪い奴ら」．洋画は「レヴェナント」「デッドプール」「コップカー」「ディーパンの闘い」辺りが好きだった．旧作で今年出会って良かったのは「イントゥザワイルド」「プレイスビヨンドザパインズ」「コングレス未来会議」「恋人たち」（シンゴジラ関連で観た）「日本のいちばん長い日」などなど．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;また来年もよろしくお願いします．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2015/12/31/2015/&#34;&gt;2015年振り返り&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Systems Performanceを読んだ</title>
      <link>http://deeeet.com/writing/2016/11/07/systems-performance/</link>
      <pubDate>Mon, 07 Nov 2016 09:25:18 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/11/07/systems-performance/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.brendangregg.com/&#34;&gt;Brendan Gregg&lt;/a&gt;による&lt;a href=&#34;https://www.amazon.co.jp/Systems-Performance-Enterprise-Brendan-Gregg-ebook/dp/B00FLYU9T2&#34;&gt;&amp;ldquo;Systems Performance: Enterprise and the Cloud&amp;rdquo;&lt;/a&gt;を読んだ．&lt;/p&gt;

&lt;p&gt;Linux（Solaris）のパフォーマンスの分野でBrendan Greggという名前を聞いたことがあるひとは多いと思う．名前を知らなくてもが書いている&lt;a href=&#34;http://www.brendangregg.com/blog/index.html&#34;&gt;ブログ&lt;/a&gt;やカンファレンスでの&lt;a href=&#34;http://www.slideshare.net/brendangregg&#34;&gt;発表資料&lt;/a&gt;を見かけたことはあると思う．また彼が開発した&lt;a href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;&gt;Flame Graph&lt;/a&gt;にお世話になってるひともいるのではないか（ref. &lt;a href=&#34;http://deeeet.com/writing/2016/05/29/go-flame-graph/&#34;&gt;GolangでFlame Graphを描く&lt;/a&gt;）．とにかくパフォーマンスに関して常に先端にいるひとである．&lt;/p&gt;

&lt;p&gt;そんな彼がSystems（ここでいうSystemsとはCPUやメモリといったハードウェアとKernelやOSといったソフトウェアを指す）のパフォーマンスについて内部のアーキテクチャーを含め徹底的に解説したのが本書である．面白いに決まってる．&lt;/p&gt;

&lt;p&gt;本書の根底にある考え方は前書きに書かれているknown-knowns，known-unknownsそしてunknown-unknownsという考え方である（詳しくは&lt;a href=&#34;http://deeeet.com/writing/2016/05/24/known-unknowns/&#34;&gt;Known unknowns&lt;/a&gt;に書いた）．パフォーマンスのチューニングやボトルネックについて考えるとき僕らは何がknownで何がunknownであるかに意識的にならないといけない．このような前提があり本書は各コンポーネントやソフトウェアを低位なレベルから詳細に紐解いていく．&lt;/p&gt;

&lt;p&gt;詳細であるから良いというわけではない．僕はLinuxについてより深い理解を得たいと思ったときにO&amp;rsquo;Reillyの&lt;a href=&#34;https://www.amazon.co.jp/dp/4873113628&#34;&gt;Linuxシステムプログラミング&lt;/a&gt;や&lt;a href=&#34;https://www.amazon.co.jp/dp/487311313X&#34;&gt;詳解Linuxカーネル&lt;/a&gt;といった本に助けを求めた．これらは学びはたくさんあったが淡々と事実が並べられるだけで素直に面白いとは思えなかった（特に詳解&amp;hellip;は全てを読むことはやめてリファレンス的にしか使っていない．それゆえ辞書と呼ばれるのだろう）．&lt;/p&gt;

&lt;p&gt;本書が面白いのは「パフォーマンス」という明確なゴールをもった上で低位な部分を解説しているところだと思う．例えばCPUについてアーキテクチャーはこうでスケジューラーはこうなっていてと説明をしながらここがパフォーマンスで問題になるといった説明をする．なぜこれが良いか？を考えた時に結局そこが日々の業務に直結するからだろうと思った．闇雲に深いレベルことを学んでも知識にはなっても業務には生かせない（もちろん大切なことだと思う）．&lt;/p&gt;

&lt;p&gt;目次は以下のようになっている．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Intro&lt;/li&gt;
&lt;li&gt;Methodology&lt;/li&gt;
&lt;li&gt;Operating Systems&lt;/li&gt;
&lt;li&gt;Observability Tools&lt;/li&gt;
&lt;li&gt;Applications&lt;/li&gt;
&lt;li&gt;CPUs&lt;/li&gt;
&lt;li&gt;Memory&lt;/li&gt;
&lt;li&gt;File Systems&lt;/li&gt;
&lt;li&gt;Disks&lt;/li&gt;
&lt;li&gt;Network&lt;/li&gt;
&lt;li&gt;Cloud Computing&lt;/li&gt;
&lt;li&gt;Benchmarking&lt;/li&gt;
&lt;li&gt;Case Study&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本書はまずMethodology（方法論）から始まる．これが良い．パフォーマンスの何が難しいって「どこから始めるか？」である．もちろん熟練したひとたちにはそれなりのスタイルなどはあると思う．例えばNetflix（これはBrendanが書いてるが）の &lt;a href=&#34;http://techblog.netflix.com/2015/11/linux-performance-analysis-in-60s.html&#34;&gt;Linux Performance Analysis in 60,000 Milliseconds&lt;/a&gt;や&lt;a href=&#34;https://twitter.com/y_uuk1&#34;&gt;@y_uuk1&lt;/a&gt;くんの&lt;a href=&#34;http://blog.yuuk.io/entry/linux-server-operations&#34;&gt;Linuxサーバにログインしたらいつもやっているオペレーション&lt;/a&gt;がある（これは本書だとTool Methodになるかな）．これらは会社ごとに特化したものであって，よりGeneralなものは明確に言語化されてるとは言いがたいのではないかと思う．だから適当にググってヒットしたコマンドをとりあえず試してみる，といったことになる．方法論は僕のようにパフォーマンスに苦手意識を持っている人間に道筋を与えてくれるものだった．例えば&lt;a href=&#34;http://www.brendangregg.com/usemethod.html&#34;&gt;USE Method&lt;/a&gt;はすぐに役に立っている．&lt;/p&gt;

&lt;p&gt;それ以降はOSやCPU，メモリそしてネットワークに関しての詳細な説明が続く．各章の枠組みは一致していて基本的な用語の解説から始まり，コンセプト，アーキテクチャー，そしてそのコンポーネントで使える方法論（具体的なコマンドなど）が説明される．どのコンポーネントも徹底的に解説され非常に勉強になる．本書で特徴的なのはLinuxだけではなくSolarisについても言及されるところだろう．別のOSについての理解/比較は今自分が使っているOSへの深い理解にもつながる（Solarisについては流す程度で読んだけどあのTracabilityは良いなあと思ってしまったよ！）．&lt;/p&gt;

&lt;p&gt;そしてCloud Computingの解説もある．これは近年避けられないテーマだ．OS virtualizationとHardware virtulizationそれぞれについて解説し比較が行われる．ホスト側とゲスト側の両方の視点がある．もちろんパフォーマスに関して留意するべきことも紹介される．&lt;/p&gt;

&lt;p&gt;Benchmarkingの章は「There are lies, damn lies and then there are performance measures」という言葉から始まる．ベンチマークを行う側，そして読む側が何に気をつければ良いかについて理解できる．「ベンチマークの結果についてその結果の分析に1週間かけていなければそれはきっと間違っている」とまで言い切っている．&lt;/p&gt;

&lt;p&gt;最後のCase Studyもとても面白かった．この章は前章で解説してきたことの集大成的な章になっている．ここではBrendannが実際に対応したパフォーマンスの問題について，彼が何を考え，どのような方法論でそれに立ち向かい，誤り，そしてそこからどのように解決に向かったが語られる．ここは結構彼の人となりが出ていて笑いながら読んだ（どんなけDtrace使いたくなってるんだとかね）．熟練のひとが何を考えているのか知れるのは方法論とは違った道筋を与えてくれる．また初心者はこの章を先に読んでも良いと勧められている．本書で解説されるものごとの意義がより伝わりやすくなるからだろう．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;紙の本で700ページ以上もあり他の本に浮気しつつ読むのに半年以上もかかってしまった．それでも上でべた褒めしたようにどのページをめくっても学びしかなかった．僕はこの本を何度も読み直すと思うし多くのひとに勧めたいと思う．少し高いがそれ以上の価値はあると思う．今後インフラ界隈（DevOpsやSRE）の必読書になっていくでしょう．オススメです．&lt;/p&gt;

&lt;p&gt;もともとは&lt;a href=&#34;https://twitter.com/y_uuk1&#34;&gt;@y_uuk1&lt;/a&gt;が読んでいたのを見て読み始めた．本当に良い本を紹介してくれてありがとう&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GolangでAPI Clientを実装する</title>
      <link>http://deeeet.com/writing/2016/11/01/go-api-client/</link>
      <pubDate>Tue, 01 Nov 2016 11:42:19 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/11/01/go-api-client/</guid>
      <description>

&lt;p&gt;特定のAPIを利用するコマンドラインツールやサービスを書く場合はClientパッケージ（SDKと呼ばれることも多いが本記事ではClientと呼ぶ）を使うことが多いと思う．広く使われているサービスのAPIであれば大抵はオフィシャルにClientパッケージが提供されている．例えば以下のようなものが挙げられる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/aws/aws-sdk-go&#34;&gt;https://github.com/aws/aws-sdk-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Azure/azure-sdk-for-go&#34;&gt;https://github.com/Azure/azure-sdk-for-go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/PagerDuty/go-pagerduty&#34;&gt;https://github.com/PagerDuty/go-pagerduty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hashicorp/atlas-go&#34;&gt;https://github.com/hashicorp/atlas-go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特別使いにくい場合を除けば再実装は避けオフィシャルに提供されているものを使ってしまえばよいと思う（まともなものなら互換性などをちゃんと考慮してくれるはずなので）．一方で小さなサービスや社内のサービスの場合はClientは提供されておらず自分で実装する必要がある．&lt;/p&gt;

&lt;p&gt;自分はこれまでいくつかのAPI client パッケージを実装してきた．本記事ではその実装の自分なりの実装パターン（各人にやりかたはあると思う）といくつかのテクニックを紹介する．&lt;/p&gt;

&lt;h2 id=&#34;clientとは何か&#34;&gt;Clientとは何か?&lt;/h2&gt;

&lt;p&gt;API ClientとはAPIのHTTPリクエストを（言語の）メソッドの形に抽象化したものである．例えば  &lt;a href=&#34;https://api.example.com/users&#34;&gt;https://api.example.com/users&lt;/a&gt; というエンドポイントからユーザ一覧を取得できるとする．API Clientは具体的なHTTPリクエスト（メソッドやヘッダの設定，認証など）を抽象化し &lt;code&gt;ListUsers()&lt;/code&gt;のようなメソッドに落とし込んでその機能を提供する．&lt;/p&gt;

&lt;h2 id=&#34;なぜ-client-を書くべきか&#34;&gt;なぜ Client を書くべきか?&lt;/h2&gt;

&lt;p&gt;そもそも共通化できることが多いため．それぞれのリクエストは独立していても例えばユーザ名やパスワード，Tokenなどは基本は同じものを使うし，ヘッダの設定なども共通して行える．またテストも書きやすくなる．&lt;/p&gt;

&lt;h2 id=&#34;いつclientを書くべきか&#34;&gt;いつClientを書くべきか?&lt;/h2&gt;

&lt;p&gt;複数のエンドポイントに対してリクエストを投げる必要がある場合はClientを書いてしまえばいいと思う．例えば，単一のエンドポイントに決まったリクエストを投げるだけであればClientをわざわざ書く必要はない．自分の場合は3つ以上エンドポイントがあればClientをさっと書いていると思う．&lt;/p&gt;

&lt;h2 id=&#34;基本的な実装パターン&#34;&gt;基本的な実装パターン&lt;/h2&gt;

&lt;p&gt;以下では &lt;a href=&#34;https://api.example.com&#34;&gt;https://api.example.com&lt;/a&gt; （存在しない）のAPI Client パッケージを実装するとする．このAPIでは&lt;code&gt;/users&lt;/code&gt;というパスでユーザの作成と取得，削除が可能であるとする．また各リクエストにはBasic認証が必要であるとする．&lt;/p&gt;

&lt;h3 id=&#34;パッケージの名前をつける&#34;&gt;パッケージの名前をつける&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/effective_go.html#package-names&#34;&gt;https://golang.org/doc/effective_go.html#package-names&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上のEffective Goにも書かれているようにパッケージ名は shortかつconciseかつevocativeのものを選択する．API Clientであればそのサービス名がそのままパッケージ名になると思う．例えば PagerDutyであれば &lt;code&gt;pagerduty&lt;/code&gt;がパッケージ名になる．&lt;/p&gt;

&lt;p&gt;名前については以下でもいくつか述べる．&lt;/p&gt;

&lt;h3 id=&#34;client-struct-を定義する&#34;&gt;Client（struct）を定義する&lt;/h3&gt;

&lt;p&gt;まずは&lt;code&gt;Client&lt;/code&gt; structを実装する．&lt;code&gt;Client&lt;/code&gt;のフィールドにはリクエスト毎に共通に利用する値を持たせるようにする．HTTP APIの場合は例えば以下のようなものが考えられる:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;url.URL&lt;/code&gt; - リクエスト毎にパスは異なるがベースのドメインは基本的には共通になる．例えば今回の場合は &lt;a href=&#34;https://api.example.com&#34;&gt;https://api.example.com&lt;/a&gt; は共通である&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http.Client&lt;/code&gt; - 各HTTP リクエストには&lt;code&gt;net/http&lt;/code&gt;パッケージの&lt;code&gt;Client&lt;/code&gt;を用いる．これは同じものを使い回す&lt;/li&gt;
&lt;li&gt;認証情報 - 認証に利用する情報も基本的には同じになる．例えば今回の場合はBasic認証に必要なユーザ名とパスワードは共通である．他にもTokenなどが考えられる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;log.Logger&lt;/code&gt; - デバッグの出力も共通である．自分はグローバルな&lt;code&gt;log&lt;/code&gt;を使うよりも明示的に指定するのを好む&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今回の場合は以下のように実装できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Client struct {
    URL        *url.URL
    HTTPClient *http.Client

    Username, Password string

    Logger *log.Logger
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;importのように関連するフィールドでグールピングして記述しておくと読みやすい．&lt;/p&gt;

&lt;p&gt;また名前は&lt;code&gt;Client&lt;/code&gt;で十分である．例えばPagerDutyのAPI Clientを書いているときに&lt;code&gt;PagerDutyClient&lt;/code&gt;という名前にしない．上述したように既にそれはパッケージ名で説明されるはずである．&lt;code&gt;pagerduty.PagerDutyClient&lt;/code&gt;では冗長になる．簡潔な名前を心がける．&lt;/p&gt;

&lt;h3 id=&#34;コンストラクタを定義する&#34;&gt;コンストラクタを定義する&lt;/h3&gt;

&lt;p&gt;次に&lt;code&gt;Client&lt;/code&gt;のコンストラクタを定義する．例えば今回の場合は以下のようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func NewClient(urlStr, username, password string, logger *log.Logger) (*Client, error) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コンストラクタ内では必須の情報が与えられているか，その値は期待するものかをチェックし，そうでなければエラーを返す（以下では&lt;code&gt;pkg/errors&lt;/code&gt;を使っている）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;if len(username) == 0 {
    return nil, errors.New(&amp;quot;missing  username&amp;quot;)
}

if len(password) == 0 {
    return nil, errors.New(&amp;quot;missing user password&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;parsedURL, err := url.ParseRequestURI(urlStr)
if err != nil {
    return nil, errors.Wrapf(err, &amp;quot;failed to parse url: %s&amp;quot;, urlStr)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必須でないものはデフォルト値を準備しておきそれを使う．例えば今回の場合は&lt;code&gt;Logger&lt;/code&gt;は必須ではない．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var discardLogger = log.New(ioutil.Discard, &amp;quot;&amp;quot;, log.LstdFlags)
if logger == nil {
    logger = discardLogger
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;http.Client&lt;/code&gt;もコンストラクタ内で生成し&lt;code&gt;Client&lt;/code&gt;にセットしておく．デフォルトを使っても良いしProxyや各Timeoutを変更したい場合は独自で準備しても良い（&lt;code&gt;http.DefaultClient&lt;/code&gt;の値はバージョンによって変わるので注意する．独自の設定を使っているとバージョン毎の新しい設定に追従できないことがある）．&lt;/p&gt;

&lt;h3 id=&#34;共通メソッドを定義する1&#34;&gt;共通メソッドを定義する1&lt;/h3&gt;

&lt;p&gt;API Clientでは多くの共通メソッドを定義できる．代表的なのは&lt;code&gt;http.Request&lt;/code&gt;を作成するメソッドである．&lt;code&gt;http.NewRequest&lt;/code&gt;を使い&lt;code&gt;http.Request&lt;/code&gt;を生成しBasic認証の設定やヘッダの設定といった共通の処理を行う．&lt;/p&gt;

&lt;p&gt;例えば今回の場合は以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var userAgent = fmt.Sprintf(&amp;quot;XXXGoClient/%s (%s)&amp;quot;, version, runtime.Version())

func (c *Client) newRequest(ctx context.Context, method, spath string, body io.Reader) (*http.Request, error) {
    u := *c.URL
    u.Path = path.Join(c.URL.Path, spath)

    req, err := http.NewRequest(method, u.String(), body)
    if err != nil {
        return nil, err
    }

    req = req.WithContext(ctx)

    req.SetBasicAuth(c.Username, c.Password)
    req.Header.Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;)
    req.Header.Set(&amp;quot;User-Agent&amp;quot;, userAgent)

    return req, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引数はHTTP メソッドとパス名，そしてリクエストのBody（&lt;code&gt;io.Reader&lt;/code&gt;）である．他にも引数が増える場合は&lt;code&gt;RequestOpts&lt;/code&gt;のようなstructを別途準備して渡すようにするとインターフェースの変更がなくなり，呼び出し側の変更コストをなくすことができる（ref. &lt;a href=&#34;http://go-talks.appspot.com/github.com/yosssi/talks.yoss.si/2015/0220-good-package.slide#1&#34;&gt;Tips for Creating a Good Package&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;さらにGo1.7以降であるなら&lt;code&gt;context.Context&lt;/code&gt;をセットするようにすればモダンになる（ref. &lt;a href=&#34;http://go-talks.appspot.com/github.com/matope/talks/2016/context/context.slide#1&#34;&gt;context パッケージの紹介&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;また&lt;code&gt;User-Agent&lt;/code&gt;をセットしておくとサーバ側に優しい．ClientのバージョンやGoのバージョンをつけておくとより便利である．&lt;/p&gt;

&lt;h3 id=&#34;共通メソッドを定義する2&#34;&gt;共通メソッドを定義する2&lt;/h3&gt;

&lt;p&gt;多くのAPIはレスポンスとしてJSONやXMLなどを返す．これらをGolangのstructへDecodeする処理はAPI Clientでは共通の処理になる．例えばJSONの場合は以下のような関数を準備しておくと良い．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func decodeBody(resp *http.Response, out interface{}) error {
    defer resp.Body.Close()
    decoder := json.NewDecoder(resp.Body)
    return decoder.Decode(out)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ちゃんと&lt;code&gt;Decoder&lt;/code&gt;を使う．&lt;code&gt;ioutil.ReadAll&lt;/code&gt;などを使うとメモリ効率もパフォーマンスも良くない（ref. &lt;a href=&#34;https://www.datadoghq.com/blog/crossing-streams-love-letter-gos-io-reader&#34;&gt;Crossing Streams: a love letter to Go io.Reader&lt;/a&gt;，&lt;a href=&#34;https://medium.com/go-walkthrough/go-walkthrough-io-package-8ac5e95a9fbd#.xivkrapgz&#34;&gt;Go Walkthrough: io package&lt;/a&gt;）．&lt;/p&gt;

&lt;h3 id=&#34;各メソッドを定義する&#34;&gt;各メソッドを定義する&lt;/h3&gt;

&lt;p&gt;最後にこれらを使って各メソッドを定義する．今回の場合は以下のようなメソッドが考えられる．外部からリクエストをキャンセルできるように&lt;code&gt;context.Context&lt;/code&gt;を渡す．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func (c *Client) GetUser(ctx context.Context, userID string) (*User, error)
func (c *Client) CreateUser(ctx context.Context, name string) error
func (c *Client) DeleteUser(ctx context.Context, userID string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例えば&lt;code&gt;GetUser&lt;/code&gt;は以下のように実装できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func (c *Client) GetUser(ctx context.Context, userID string) (*User, error) {
    spath := fmt.Sprintf(&amp;quot;/users/%s&amp;quot;, userID)
    req, err := c.newRequest(ctx, &amp;quot;GET&amp;quot;, spath, nil)
    if err != nil {
        return nil, err
    }

    res, err := c.HTTPClient.Do(req)
    if err != nil {
        return nil, err
    }
    
    // Check status code here…

    var user User
    if err := decodeBody(res, &amp;amp;user); err != nil {
        return nil, err
    }

    return &amp;amp;user, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;リクエストメソッドは上記で定義した共通メソッドで&lt;code&gt;http.Request&lt;/code&gt;を作成し&lt;code&gt;Client&lt;/code&gt;の&lt;code&gt;HTTPClient&lt;/code&gt;を利用して実際のリクエストを実行する．そしてレスポンスのDecodeを行う．異なるのはパス名やリクエストBodyである．ステータスコードのチェックもここで行う．&lt;/p&gt;

&lt;h2 id=&#34;いくつかのテクニック&#34;&gt;いくつかのテクニック&lt;/h2&gt;

&lt;p&gt;以下では自分が実践しているいくつかのテクニックを紹介する．&lt;/p&gt;

&lt;h3 id=&#34;insecureオプション&#34;&gt;insecureオプション&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;のコンストラクタに渡す値として&lt;code&gt;insecure&lt;/code&gt;（&lt;code&gt;bool&lt;/code&gt;）はよく使う．例えば社内の古いサービスやステージング環境だと自己署名証明書を使っている場合があり&lt;code&gt;InsecureSkipVerify&lt;/code&gt;を有効にする必要がある．&lt;code&gt;insecure&lt;/code&gt;はこの設定に使う．例えば以下のように切り替えを行う．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;tlsConfig := tls.Config{
    InsecureSkipVerify: insecure,
}

transport := *http.DefaultTransport.(*http.Transport)
transport.TLSClientConfig = &amp;amp;tlsConfig

c.HTTPClient = &amp;amp;http.Client{
    Transport: &amp;amp;transport,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;symmetric-api-testing&#34;&gt;Symmetric API testing&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/symmetric-api-testing-in-go/&#34;&gt;Symmetric API Testing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;API Clientを書くときもテストは大切である．もっとも簡単で確実なのは実際にAPIにリクエストを投げてレスポンスが期待するものであるかを確認する方法である．しかしAPIによってはリクエストに制限があるし，RTTを考えるとテストの時間も長くなる，またオフラインでテストすることができない．これを解決するのがGopher Academyで紹介されていたSymmetric API Testingである．&lt;/p&gt;

&lt;p&gt;詳しくは上記のリンクを読むのが良いが，簡単にいうとAPIのレスポンスをローカルのディスクに保存して次回からそれを使ってテストする方法である．例えば上で紹介した&lt;code&gt;decodeBody&lt;/code&gt;を以下のように変更する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func decodeBody(resp *http.Response, out interface{}, f *os.File) error {
    defer resp.Body.Close()

    if f != nil {
        resp.Body = ioutil.NopCloser(io.TeeReader(resp.Body, f))
        defer f.Close()
    }

    decoder := json.NewDecoder(resp.Body)
    return decoder.Decode(out)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;io.TeeReader&lt;/code&gt;を使い&lt;code&gt;os.File&lt;/code&gt;が渡された場合にDecodeと同時にレスポンスをファイルに書き込む．&lt;/p&gt;

&lt;p&gt;実際にテストを行うときはこのファイルを&lt;code&gt;httptest&lt;/code&gt;で返すようにする．例えば&lt;code&gt;/users/1&lt;/code&gt;のレスポンスを&lt;code&gt;testadata/users-1.json&lt;/code&gt;に保存したとする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;muxAPI := http.NewServeMux()
testAPIServer := httptest.NewServer(muxAPI)
defer testAPIServer.Close()

muxAPI.HandleFunc(&amp;quot;/users/1&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
    http.ServeFile(w, r, &amp;quot;testdata/users-1.json&amp;quot;)
})
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで実際のAPIリクエストを避けてテストを行うことができる．&lt;/p&gt;

&lt;h3 id=&#34;ネットワーク関連のデバッグ&#34;&gt;ネットワーク関連のデバッグ&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;を定義するときに&lt;code&gt;log.Logger&lt;/code&gt;を渡すようにしたがこれはデバッグに用いる．API Clientでもデバッグは重要である．リクエストBodyなどはもちろんだが，以下のようにネットワークに関わる情報をデバッグとして出力しておくと問題が起こったときに解決しやすい．&lt;/p&gt;

&lt;p&gt;Goの&lt;code&gt;http.Client&lt;/code&gt;はデフォルトで環境変数（&lt;code&gt;http_proxy&lt;/code&gt;と&lt;code&gt;https_proxy&lt;/code&gt;）を参照しProxyを設定する．複雑なネットワーク環境から使われた場合結局Proxyが問題の原因になってることが多い．そのため以下のようにProxy情報も基本はデバッグで出力されるようにしておくと良い．上でいうと&lt;code&gt;newRequest&lt;/code&gt;にこれは書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;proxy := &amp;quot;no&amp;quot;
if proxyURL, _ := http.ProxyFromEnvironment(req); proxyURL != nil {
    proxy = proxyURL.String()
}
c.Logger.Printf(&amp;quot;[DEBUG] request proxy: %s&amp;quot;, proxy)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTTPリクエストのどこで時間がかかっているかわかると問題の切り分けがしやすい．&lt;a href=&#34;https://github.com/tcnksm/go-httpstat&#34;&gt;tcnksm/go-httpstat&lt;/a&gt;を使うとDNSLookupやTLSHandshakeのレイテンシを簡単に測定することができる．詳しくは&lt;a href=&#34;https://medium.com/@deeeet/trancing-http-request-latency-in-golang-65b2463f548c#.i8unan3sy&#34;&gt;Tracing HTTP request latency in golang&lt;/a&gt; に書いた．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;API Clientは最初に書くGolang パッケージとしても良いと思う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golangにおけるinterfaceをつかったテスト技法</title>
      <link>http://deeeet.com/writing/2016/10/25/go-interface-testing/</link>
      <pubDate>Tue, 25 Oct 2016 09:26:51 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/10/25/go-interface-testing/</guid>
      <description>

&lt;p&gt;最近何度か聞かれたので自分がGolangでCLIツールやAPIサーバーを書くときに実践してるinterfaceを使ったテスト技法について簡単に書いておく．まずはinterfaceを使ったテストの基本について説明し次に自分が実践している簡単なテクニックをいくつか紹介する．&lt;/p&gt;

&lt;p&gt;なおGolangのテストの基本については &lt;a href=&#34;https://twitter.com/suzu_v&#34;&gt;@suzuken&lt;/a&gt; さんによる&lt;a href=&#34;https://www.amazon.co.jp/dp/477418392X&#34;&gt;「みんなのGo言語」&lt;/a&gt; の6章が最高なので今すぐ買ってくれ！&lt;/p&gt;

&lt;h2 id=&#34;前提&#34;&gt;前提&lt;/h2&gt;

&lt;p&gt;自分はテストフレームワークや外部ツールは全く使わない．標準の&lt;code&gt;testing&lt;/code&gt;パッケージのみを使う．&lt;a href=&#34;https://golang.org/doc/faq#Packages_Testing&#34;&gt;https://golang.org/doc/faq#Packages_Testing&lt;/a&gt; にも書かれているようにテストのためのフレームワークを使うことは新たなMini language（DSL）を導入することと変わらない．最初にそれを書く人は楽になるかもしれないが新しくプロジェクトに参入してきたひとにはコストにしかならない（Golang以外も学ぶ必要がある）．例えば自分があるプロジェクトにContributeしようとして見たこともないテストフレームワークが使われているとがっくりする．&lt;/p&gt;

&lt;p&gt;とにかくGolangだけで書くのが気持ちがいい，に尽きる．&lt;/p&gt;

&lt;h2 id=&#34;テストとinterface&#34;&gt;テストとinterface&lt;/h2&gt;

&lt;p&gt;テストという観点からみた場合のinterfaceの利点は何か？ interfaceを使えば「実際の実装」を気にしないで「振る舞い」を渡すことができる．つまり実装の切り替えが可能になる．interfaceを使うことでいわゆる&lt;a href=&#34;https://en.wikipedia.org/wiki/Mock_object&#34;&gt;モック&lt;/a&gt;が実現できる．&lt;/p&gt;

&lt;h2 id=&#34;どこをinterfaceにするのか&#34;&gt;どこをinterfaceにするのか？&lt;/h2&gt;

&lt;p&gt;interfaceはモックポイントと思えば良い．外界とやりとりを行う境界をinterfaceにする，が基本．外界との境界とは例えばDBとやりとりを行う部分や外部APIにリクエストを投げるClientである．他にも考えられるがとりあえずここをinterfaceにする．&lt;/p&gt;

&lt;h2 id=&#34;実例&#34;&gt;実例&lt;/h2&gt;

&lt;p&gt;以下では簡単なAPIサーバーを書くとしてinterfaceによるテスト手法の説明を行う．このAPサーバーはDBとしてRedisを使うとする．なおコードは全てpseudoである．&lt;/p&gt;

&lt;p&gt;まずはDBのinterfaceを定義する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type DB interface {
    Get(key string) string
    Set(key, value string) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に実際のRedisを使った実装を書く．例えば以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Redis struct {
    // 接続情報など
}

func (r *Redis) Get(key string) string 
func (r *Redis) Set(key, value string) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;main関数から呼び出すときのことを考えてコンストラクタを実装すると良い（必要な接続情報などが与えられなかった時，もしくは必要な初期化処理に失敗した時にエラーを返せる）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func NewRedis() (DB, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで重要なのは実際の実装である&lt;code&gt;Redis&lt;/code&gt;を返すのではなくinterfaceの&lt;code&gt;DB&lt;/code&gt;を返すこと．サーバー側ではこのinterfaceを使う．&lt;/p&gt;

&lt;p&gt;サーバーの実装は以下のようにする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type Server struct {
     DB DB
}

func (s *Server) Start() error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Server&lt;/code&gt;はinterfaceの&lt;code&gt;DB&lt;/code&gt;を持ち内部の実装（例えばhandlerなど）ではこのinterfaceを利用する．&lt;/p&gt;

&lt;p&gt;main関数は以下のように書ける（main関数には他にもflagの処理や設定ファイルを読み込みそれを各コンストラクタに渡すという処理が考えられる）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
     redis, err := NewRedis()
     if err != nil {
         log.Fatal(err)
     }

     server := &amp;amp;Server{
         DB: redis,
     }

     if err := server.Start(); err != nil {
         log.Fatal(err)
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;では&lt;code&gt;Server&lt;/code&gt;のテストはどうすれば良いか？例えば今であればDockerを使いRedisを準備することを考えるかもしれない．それが容易ではない場合，もしくは外部依存のないテストを書きたい場合はモックを考える．以下のように&lt;code&gt;DB&lt;/code&gt; interfaceを満たすモック実装を準備する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type TestDB struct {
}

func (d *TestDB) Get(key string) string 
func (d *TestDB) Set(key, value string) error 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的な実装は書いてないが例えばフェイクの値やフェイクの&lt;code&gt;error&lt;/code&gt;を返すようにする（これを考えることもより良い実装につながると思う）．&lt;/p&gt;

&lt;p&gt;これを利用すれば&lt;code&gt;Server&lt;/code&gt;のテストは以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func TestServer(t *testing.T) {
     testDB := &amp;amp;TestDB{}

     server := &amp;amp;Server{
         DB: testDB,
     }    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Server&lt;/code&gt;が必要なのは&lt;code&gt;DB&lt;/code&gt; interface（振る舞い）であり実際の実装は何でも良い．これで実際にRedisを準備することなく&lt;code&gt;Server&lt;/code&gt;の動きをテストすることができる．&lt;/p&gt;

&lt;p&gt;以上がinterfaceを使ったテスト手法の基礎である．ここではDBを例にしたが他にも外部APIとやり取りを行うClientなどにも応用できる．また今回はinterfaceから実装したがすでに実際の実装がある場合もそれに対応したinterfaceを定義してしまえば同様のテストを書くことができる．&lt;/p&gt;

&lt;h2 id=&#34;いくつかのテクニック&#34;&gt;いくつかのテクニック&lt;/h2&gt;

&lt;p&gt;以下では自分が実践しているいくつかのテクニックを紹介する．&lt;/p&gt;

&lt;h2 id=&#34;環境変数で切り替える&#34;&gt;環境変数で切り替える&lt;/h2&gt;

&lt;p&gt;毎回全てのテストをモックにすれば良いわけではない．ちゃんと実際の実装によるテストも必要である．自分はこの切り替えに環境変数を使う．環境変数を使うのはCIとの相性が良いからである．&lt;/p&gt;

&lt;p&gt;追記: いくつかこのやり方に誤解があったので．この環境変数の切り替えはテストコード（&lt;code&gt;*_test.go&lt;/code&gt;）内に書く．本番用のコードとは別にコンストラクタを実装して切替を実現する（なので本番のコードで環境変数によってモックが使われてしまうという誤爆はない）．&lt;/p&gt;

&lt;p&gt;例えば以下のようなコンストラクタを準備する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;
const (
     EnvTestDSN = &amp;quot;TEST_DSN&amp;quot;
)

func NewTestDB(t *testing.T) (DB, func()) {
     dsn := os.Getenv(EnvTestDSN)
     if len(den) == 0 {
           t.Log(&amp;quot;Use TestDB&amp;quot;)
           return &amp;amp;TestDB{}, func() {}
     }

    db, err := NewPostgreSQL(dsn)
     if err != nil {
         t.Fatal(“NewPostgreSQL failed: ”,err)
      }

     return db, func() {
         pSQL := db.(*PostgreSQL)
         pSQL.DB.DropTable(&amp;amp;SplunkInfo{})
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;環境変数として接続情報（&lt;code&gt;DSN&lt;/code&gt;）が与えられた場合は実際の実装である&lt;code&gt;PosgreSQL&lt;/code&gt;を返し実際のDBでテストし．与えられない場合はモックの実装でテストを行う．&lt;/p&gt;

&lt;p&gt;ちなみに2つ目の返り値はDBをCleanupするための関数で呼び出し側では&lt;code&gt;defer&lt;/code&gt;と一緒に使う（例えばDockerなどでEphemeralなデータストアを使う場合にデータを消してまっさらな状態に戻す）．&lt;/p&gt;

&lt;h2 id=&#34;外部パッケージの一部をinterfaceとして切り出す&#34;&gt;外部パッケージの一部をinterfaceとして切り出す&lt;/h2&gt;

&lt;p&gt;例えば外部のAPIを利用する場合は公式などが提供しているClientパッケージを使ってしまうのが手っ取り早い．特にAPIの場合はリクエストに制限があったり安易に呼び出せないものあるのでモックが大切になる．この場合は自分は必要な部分のみをinterfaceとして切り出すという方法をとる（他にもレスポンスを保存する&lt;a href=&#34;https://blog.gopheracademy.com/advent-2015/symmetric-api-testing-in-go/&#34;&gt;Symmetric API Testing&lt;/a&gt;という方法もある）．&lt;/p&gt;

&lt;p&gt;例えばGitHubのAPIを使いたい場合は &lt;a href=&#34;https://github.com/google/go-github&#34;&gt;https://github.com/google/go-github&lt;/a&gt; を使うが，以下のように必要なものを切り出してしまう．そしてメインロジックではこのinterfaceを利用するようにする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;type GitHub interface {
    CreateRelease(ctx context.Context, opt Option) (string, error)
    GetRelease(ctx context.Context, tag string) (string, error)
    DeleteRelease(ctx context.Context, releaseID int) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing-as-public-api&#34;&gt;Testing as Public API&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://speakerdeck.com/mitchellh/advanced-testing-with-go&#34;&gt;&amp;ldquo;Advanced Testing with Go&amp;rdquo;&lt;/a&gt; の発表を見てなるほどなあと思い実践始めたのはtest用の関数をAPIとして公開する方法．&lt;/p&gt;

&lt;p&gt;すべてを&lt;code&gt;main&lt;/code&gt;パッケージに実装している間は良いがある程度の規模になるとパッケージの切り出しが大切になる．&lt;code&gt;*_test.go&lt;/code&gt;に記述した関数は別のパッケージからは参照できないためモックの実装をどこに書くかが問題になる（呼び出し側で何度も実装するのは非効率）．この方法は&lt;code&gt;testing.go&lt;/code&gt;や&lt;code&gt;testing_*.go&lt;/code&gt;といったファイルを準備し外部から参照可能なテスト用のヘルパー関数を提供する，つまりテスト関数もAPIとして提供してしまう方法である．&lt;/p&gt;

&lt;p&gt;例えば以下のような関数を準備する．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func TestDB(t *testing.T) DB
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func TestConfig(t *testing.T) *Config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで呼び出し側でのテスト用のモックなどの再実装を防ぐことができる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;ただしやりすぎると可読性が下がるのでやりすぎには注意する必要がある．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PagerDutyのOn-callを一時的に自分にアサインするdutymeというツールを書いた</title>
      <link>http://deeeet.com/writing/2016/10/24/dutyme/</link>
      <pubDate>Mon, 24 Oct 2016 09:00:14 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/10/24/dutyme/</guid>
      <description>

&lt;p&gt;現在のチームではインシデント管理に&lt;a href=&#34;http://www.pagerduty.com/&#34;&gt;PagerDuty&lt;/a&gt;を使っている．On-callはPrimaryとSecondaryの2人体勢でそれを1週間ごとにローテーションで回している．On-Callにアサインされている場合は夜中であれ日中であれPrimaryにアラートが飛ぶ（Primaryが反応できなければSecondaryにエスカレートされる）．そしてアラートを受けたら何かしらの対応を行う．&lt;/p&gt;

&lt;p&gt;これはうまく回っているが問題もある．業務中（日中）はPrimaryやSecondaryに関係なくチームメンバーはどんどんデプロイしたりProduction環境で作業をしたりする．そしてオペレーションやデプロイ対象のコンポーネントによってはアラートが発生してしまうことがある．つまり作業者に関係なくアラートがPrimaryやSecondaryに飛んでしまう（Slackと連携しているので全員がそれをみることにはなるが）．&lt;/p&gt;

&lt;p&gt;デプロイやオペレーションは各個人の責任でやっているのでまずは本人が対応するべきである．またPrimaryであれインシデントがない場合は自分のタスクに集中しているのでアラートが飛べばDisturbされてしまう（自分がPrimaryの場合は嫌だし自分のオペレーションで誰かをDisturbしたくもない）．そもそもスケジュールの粒度をもう少し細かく簡単に変更したい．&lt;/p&gt;

&lt;p&gt;この問題を解決するために&lt;a href=&#34;https://github.com/tcnksm/dutyme&#34;&gt;&lt;code&gt;dutyme&lt;/code&gt;&lt;/a&gt;というOn-callを一時的に自分にアサインするツールを書いた．以下ではこのツールの簡単な紹介を行う．なおコードは &lt;a href=&#34;https://github.com/tcnksm/dutyme&#34;&gt;tcnksm/dutyme&lt;/a&gt; に公開している．&lt;/p&gt;

&lt;h2 id=&#34;requirement&#34;&gt;Requirement&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;dutyme&lt;/code&gt;を使うには&lt;a href=&#34;https://v2.developer.pagerduty.com/v2/page/api-reference&#34;&gt;PagerDuty API v2&lt;/a&gt;のTokenが必要になる．TokenはReadとWriteの権限を持っている必要がある．詳しくは&lt;a href=&#34;https://support.pagerduty.com/hc/en-us/articles/202829310-Generating-an-API-Key&#34;&gt;&amp;ldquo;Generating an API Key – PagerDuty Support and Help&amp;rdquo;&lt;/a&gt;を参考．&lt;/p&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;使い方は以下．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dutyme start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコマンドを実行し必要な情報（PagerDutyのEmailスケジュール）を入力するだけでアサインが変更される．一度入力した情報はファイルに保存できるので次回からは何も入力することなくアサインを変更できる．&lt;/p&gt;

&lt;p&gt;以下は利用の様子．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/dutyme.gif&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;dutyme&lt;/code&gt;はスケジュールを書き換えているわけではない．Pagedutyの&lt;a href=&#34;https://support.pagerduty.com/hc/en-us/articles/202830170-Creating-and-Deleting-Overrides&#34;&gt;Override&lt;/a&gt;という機能を使ってスケジュールの上書きをしている．なのでベースのスケジュールが壊れる心配はない（Overrideは消すのも簡単）．&lt;/p&gt;

&lt;p&gt;実装はGo言語でclientには &lt;a href=&#34;https://github.com/PagerDuty/go-pagerduty&#34;&gt;https://github.com/PagerDuty/go-pagerduty&lt;/a&gt; を使い（Go言語でPagerDuty関連のツールを作りたい場合はこれを使えば良さそう），tty プロンプトの制御には自分で書いた &lt;a href=&#34;https://github.com/tcnksm/go-input&#34;&gt;https://github.com/tcnksm/go-input&lt;/a&gt; を使っている．&lt;/p&gt;

&lt;h2 id=&#34;install&#34;&gt;Install&lt;/h2&gt;

&lt;p&gt;インストールは&lt;code&gt;go get&lt;/code&gt;もしくは&lt;code&gt;brew&lt;/code&gt;が使える．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ brew tap tcnksm/dutyme
$ brew install dutyme
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;要望やBugなどは &lt;a href=&#34;https://github.com/tcnksm/dutyme/issues&#34;&gt;https://github.com/tcnksm/dutyme/issues&lt;/a&gt; までお願いします．現状は最低限使うための機能しかないがもう少し機能の追加はする予定．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sync.ErrGroupで複数のgoroutineを制御する</title>
      <link>http://deeeet.com/writing/2016/10/12/errgroup/</link>
      <pubDate>Wed, 12 Oct 2016 09:36:20 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/10/12/errgroup/</guid>
      <description>

&lt;p&gt;Golangの並行処理は強力である一方で同期処理を慎重に実装する必要がある．&lt;a href=&#34;http://motemen.hatenablog.com/entry/2016/05/go-concurrent-building-blocks&#34;&gt;&amp;ldquo;Go 言語における並行処理の構築部材&amp;rdquo;&lt;/a&gt;にまとめられているようにGolangは様々な方法でそれを実装することができる．実現したいタスクに合わせてこれらを適切に選択する必要がある．&lt;/p&gt;

&lt;p&gt;この同期処理の機構として新たに&lt;a href=&#34;https://godoc.org/golang.org/x/sync/errgroup&#34;&gt;golang.org/x/sync/errgroup&lt;/a&gt;というパッケージが登場した．実際に自分のツールで使ってみて便利だったので簡単に紹介する．&lt;/p&gt;

&lt;h2 id=&#34;使いどころ&#34;&gt;使いどころ&lt;/h2&gt;

&lt;p&gt;時間のかかる1つのタスクを複数のサブタスクとして並行実行しそれらが全て終了するのを待ち合わせる処理（Latch）を書きたい場合に&lt;code&gt;errgroup&lt;/code&gt;は使える．その中でも「1つでもサブタスクでエラーが発生した場合に他のサブタスクを全てを終了しエラーを返したい」（複数のサブタスクが全て正常に終了して初めて1つの処理として完結する）場合が主な使いどころである．&lt;/p&gt;

&lt;h2 id=&#34;実例&#34;&gt;実例&lt;/h2&gt;

&lt;p&gt;ここでは例として複数の&lt;code&gt;worker&lt;/code&gt;サブタスクをgoroutineで並行実行しそれらすべての終了を待ち合わせるという処理を考える．最初に今までのやりかたとして&lt;code&gt;sync.WaitGroup&lt;/code&gt;を使った実装を，次に&lt;code&gt;errgroup&lt;/code&gt;を使った実装を紹介する．&lt;/p&gt;

&lt;h3 id=&#34;sync-waitgroup&#34;&gt;sync.WaitGroup&lt;/h3&gt;

&lt;p&gt;goroutineの待機処理としてよく使われるのが&lt;code&gt;sync.WaitGroup&lt;/code&gt;である．その名前の通り指定した数の処理（goroutine）の実行の待ち合わせに利用する．例えば以下のように書くことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;var wg sync.WaitGroup
errCh := make(chan error, 1)
for i := 0; i &amp;lt; 10; i++ {
    wg.Add(1)
    go func(i int) {
        defer wg.Done()
        worker(i)
    }(i)
}

wg.Wait()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新たなgoroutineを生成する度に&lt;code&gt;Add&lt;/code&gt;でWaitGroupをインクリメントし処理が終了したときに&lt;code&gt;Done&lt;/code&gt;を呼ぶ．そして全ての&lt;code&gt;worker&lt;/code&gt;の処理が終了するまで&lt;code&gt;Wait&lt;/code&gt;で処理をブロックする．これはchannelを使っても実装できるが&lt;code&gt;sync.WaitGroup&lt;/code&gt;を使ったほうが読みやすいことも多い．&lt;/p&gt;

&lt;p&gt;では&lt;code&gt;worker&lt;/code&gt;でのエラーを処理をしたい場合にはどうするのが良いだろうか? sliceでエラーをため終了後にそれを取り出す，&lt;code&gt;error&lt;/code&gt;のchannelを作り外部でそれを受け取るといったパターンが考えられる．何にせよ別途自分で処理を実装する必要がある．&lt;/p&gt;

&lt;h3 id=&#34;sync-errgroup&#34;&gt;sync.ErrGroup&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/sync/errgroup&#34;&gt;errgroup&lt;/a&gt;パッケージを使う以下のように書くことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;eg := errgroup.Group{}
for i := 0; i &amp;lt; 10; i++ {
    i := i
    eg.Go(func() error {
        return worker(i)
    })
}

if err := eg.Wait(); err != nil {
    log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;errgroup&lt;/code&gt;では&lt;code&gt;Go&lt;/code&gt;メソッドを使いサブタスクを実行する．ここに与えられた処理は新たなgoroutineで実行される．&lt;code&gt;Wait&lt;/code&gt;は&lt;code&gt;sync.WaitGroup&lt;/code&gt;と同様に&lt;code&gt;Go&lt;/code&gt;メソッドで実行された全てのサブタスクが終了するまで処理をブロックする．そして（もしあれば）&lt;code&gt;Go&lt;/code&gt;メソッド内で最初に返されたnon-nilの&lt;code&gt;error&lt;/code&gt;を返す．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;errgroup&lt;/code&gt;が強力なのは&lt;code&gt;context&lt;/code&gt;パッケージを使い，1つのサブタスクでエラーが発生したときに他の全てのサブタスクをキャンセルできるところである．例えば以下のように書くことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;eg, ctx := errgroup.WithContext(context.TODO())
for i := 0; i &amp;lt; 10; i++ {
    i := i
    eg.Go(func() error {
        return workerContext(ctx, i)
    })
}

if err := eg.Wait(); err != nil {
    log.Println(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;違いは新たなGroupを&lt;code&gt;WithContext&lt;/code&gt;で生成し，かつ同時に新たな&lt;code&gt;Context&lt;/code&gt;も生成している部分である．また&lt;code&gt;worker&lt;/code&gt;を&lt;code&gt;workerContext&lt;/code&gt;とし&lt;code&gt;Context&lt;/code&gt;を渡せるようにしている．これにより1つのサブタスクでエラーが発生した場合に生成した&lt;code&gt;Context&lt;/code&gt;をキャンセルすることができる．つまり（&lt;code&gt;workerContext&lt;/code&gt;をちゃんと実装すれば）適切なリソース解放を行い処理を終了させることができる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;これだけでなく&lt;a href=&#34;https://godoc.org/golang.org/x/sync/errgroup&#34;&gt;GoDoc&lt;/a&gt;のExampleにも挙げられているようにpipeline処理にも使うことができる．これらの処理はGolangではよく実装するパターンでありもしかしたら標準に仲間入りするかもしれない．&lt;/p&gt;

&lt;p&gt;とりあえずサブタスクを全て実行してしまいたい，発生したエラーは全て取り出したい，といった場合は別のパターンを実装するのが良い．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oreilly.com/learning/run-strikingly-fast-parallel-file-searches-in-go-with-sync-errgroup&#34;&gt;Run strikingly fast parallel file searches in Go with sync.ErrGroup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/matope/talks/2016/context/context.slide#1&#34;&gt;context パッケージの紹介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://deeeet.com/writing/2016/07/22/context/&#34;&gt;Go1.7のcontextパッケージ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GolangでAmazon EchoのSmart Home Skillを書く</title>
      <link>http://deeeet.com/writing/2016/08/30/alexa-irkit-ac/</link>
      <pubDate>Tue, 30 Aug 2016 09:56:39 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/08/30/alexa-irkit-ac/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.amazon.com/dp/B00X4WHP5E&#34;&gt;Amazon Echo&lt;/a&gt;（以下Alexa）はAmazonが開発・販売している音声アシスタント+Bluetoothスマートスピーカーである．音楽を流す，今日の天気やニュースを聞く，Googleカレンダーの予定を聞く，TODOを追加する，家電を操作するなどなど&amp;hellip; といった多くのことを全て音声を通じて実行することができる（&lt;a href=&#34;https://www.youtube.com/watch?v=KkOCeAtKHIc&#34;&gt;こちらの動画&lt;/a&gt;がわかりやすい）．&lt;/p&gt;

&lt;p&gt;現時点（2016年8月）では音声認識は英語のみで対応地域もUSのみとなっている（例えば天気を聞くと地域を指定しない限りUSの天気が返ってくる）．また連携できるサービスも日本で使えるものは少ない．ただ発表当時から「これは完全に買いだ」と思っており先日&lt;a href=&#34;http://deeeet.com/writing/2016/07/12/gophercon2016-lt/&#34;&gt;GopherCon2016で渡米したとき&lt;/a&gt;にいきおいで購入した（自分は音声アシスタントはSiriなどのスマートフォンに搭載されているものよりも据え置き型のものに未来を感じている．実は大学院では&lt;a href=&#34;http://link.springer.com/chapter/10.1007%2F978-1-4614-8280-2_14&#34;&gt;会話ロボットの研究&lt;/a&gt;をしていたのでこの分野には思うことはたくさんある．がそれは別途書く）．&lt;/p&gt;

&lt;p&gt;Alexaをしばらく使った感想としてはとにかく音声認識がすごい！ Living roomに置いているがどこから話しても認識してくれる（最悪玄関から「Turn-off AC」と叫んでも認識してくれる）．音声認識の研究をしていた身からして一番驚いたのはAlexaのスピーカーから音楽を流していても認識がまともに働くこと．音楽のシグナルと言葉のシグナルを分離する的な研究はあったがここまで実用的になっているのは正直驚いた．また自分は対話システムにおけるバージイン（割り込み）を研究テーマにしていたことがあるがそちらも完璧に実用的である．Alexaの上に乗るアプリケーションにはもちろん感動するが音声対話システムとしての基礎がものすごくしっかりしていることにとても感動した．&lt;/p&gt;

&lt;p&gt;さてAlexaは音楽を流す，天気を聞くといったBuilt-inのSkillに加えてサードパーティが提供するSkillを有効にして機能拡張することができる．そしてSkillは自分で開発することもできる．Skillは&lt;a href=&#34;https://docs.aws.amazon.com/lambda/latest/dg/welcome.html&#34;&gt;AWS Lambda&lt;/a&gt;のFunctionとして実装するので現状はLambdaが対応するPython，Node.jsもしくはJavaでの開発が前提となる．がGolangの場合はシングルバイナリをデプロイしてNode.jsから実行するという方法が使えるためGolangも開発の選択肢になる．&lt;/p&gt;

&lt;p&gt;今回Golangを使い実用的なAlexa Skillを書いた．本記事ではその実装方法を簡単に紹介する．なおコードは全て &lt;a href=&#34;https://github.com/tcnksm/alexa-irkit-ac&#34;&gt;https://github.com/tcnksm/alexa-irkit-ac&lt;/a&gt; に公開している．&lt;/p&gt;

&lt;h2 id=&#34;デモ&#34;&gt;デモ&lt;/h2&gt;

&lt;p&gt;以下は今回作成したAlexa Skillのデモ動画．自宅のエアコンのON/OFFを行う．ON/OFFのシグナルの送信には&lt;a href=&#34;http://getirkit.com/&#34;&gt;IRKit&lt;/a&gt;を使っている．&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;https://player.vimeo.com/video/179021210&#34; width=&#34;640&#34; height=&#34;360&#34; frameborder=&#34;0&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href=&#34;https://vimeo.com/179021210&#34;&gt;Turn on/off air conditioner by Amazon Echo and IRKit&lt;/a&gt; from &lt;a href=&#34;https://vimeo.com/user5121880&#34;&gt;deeeet&lt;/a&gt; on &lt;a href=&#34;https://vimeo.com&#34;&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;

&lt;h2 id=&#34;実装の概要&#34;&gt;実装の概要&lt;/h2&gt;

&lt;p&gt;Alexaの独自Skillの開発には&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/getting-started-guide&#34;&gt;Alexa Skill Kit&lt;/a&gt;を用いる．Skill Kitには以下の2種類がある．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/overviews/understanding-custom-skills&#34;&gt;Custom Skill&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/overviews/understanding-the-smart-home-skill-api&#34;&gt;Smart Home Skill&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Custom SkillはよりGeneralなリクエストを受けるのに利用する．例えばWeb Seriviceに情報を問い合わせるやピザを注文するなど．若干冗長な言い回しをしないといけないが自由なワードを認識させる事ができる．Smart Home Skillは家電操作に特化したリクエストを受けるのに利用する．受け付ける言い回しは限定されているがより自然な命令ができる．今回はエアコンの操作なのでSmart Home Skillを利用した（Custom Skillを使ったNode.jsの実装はIRKitの作者の&lt;a href=&#34;https://twitter.com/maaash&#34;&gt;@maaash&lt;/a&gt;さんの&lt;a href=&#34;http://maaash.jp/2016/07/alexa-air-conditioner/&#34;&gt;&amp;ldquo;Amazon Alexaにエアコンをつけてもらう&amp;rdquo;&lt;/a&gt;が参考になる）．&lt;/p&gt;

&lt;p&gt;Smart Home Skillのリクエストの流れは以下のようになる．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://developer.amazon.com/public/binaries/content/gallery/developerportalpublic/alexa_smart_home_ecosystem.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;自分で書く必要があるのは4のLambda Functionである．Alexa Serviceからリクエストを受け家電を操作するためのAPI（この場合はIRKitのInternet HTTP API）にリクエストを投げる．&lt;/p&gt;

&lt;p&gt;これに加えてSmart Home Skillの場合は&lt;a href=&#34;https://tools.ietf.org/html/rfc6749&#34;&gt;OAuth 2.0 Authorization Framework&lt;/a&gt;を使った&lt;a href=&#34;https://developer.amazon.com/appsandservices/solutions/alexa/alexa-skills-kit/docs/linking-an-alexa-user-with-a-user-in-your-system&#34;&gt;Account Linking&lt;/a&gt;が必須になる．今回作成したSkillは完全に個人用途なのでAlexa Serviceからのリクエストを最小限でハンドルするシンプルなOAuthサーバーをGoで書いて&lt;a href=&#34;https://console.ng.bluemix.net/&#34;&gt;IBM Bluemix&lt;/a&gt;にPushして済ませた（実はここが一番めんどくさかった．ドキュメントが不足していたので自分でRFCを読まないといけなかった）．&lt;/p&gt;

&lt;p&gt;コードは&lt;a href=&#34;https://gist.github.com/tcnksm/3ca4ad1709da91386c9173ff0d926aa8&#34;&gt;&amp;ldquo;Amazon Alexa Simple Account Linking Server by Golang&amp;rdquo;&lt;/a&gt;に置いた．&lt;/p&gt;

&lt;h2 id=&#34;golangでlambda-functionを書く&#34;&gt;GolangでLambda Functionを書く&lt;/h2&gt;

&lt;p&gt;GolangによるLambda FunctionのデプロイとNode.jsとの連携には&lt;a href=&#34;http://apex.run/&#34;&gt;apex&lt;/a&gt;を利用した．この場合は以下のような&lt;code&gt;HandleFunc&lt;/code&gt;を実装すればよい．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {
    apex.HandleFunc(func(event json.RawMessage, ctx *apex.Context) (interface{}, error) {        

    // Handle Request...
    
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alexa Skillの場合は入力の&lt;code&gt;event&lt;/code&gt;はAlexa Serviceからのリクエストで，返り値の&lt;code&gt;interface{}&lt;/code&gt;はAlexa Serviceへのレスポンスである．やることは非常に単純で&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/smart-home-skill-api-reference&#34;&gt;Smart Home Skill API Reference&lt;/a&gt;を参考にjsonを頑張ってパースするだけ．&lt;/p&gt;

&lt;p&gt;今回の場合は少なくとも以下の2つのリクエストを処理できる必要がある．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/smart-home-skill-api-reference#Discovery Messages&#34;&gt;Discovery Messages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/smart-home-skill-api-reference#On/Off Messages&#34;&gt;On/Off Messages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Discovery MessageはユーザがSkillを有効にするときにリクエストされる．このレスポンスでデバイス名前やリクエスト可能なコマンド（e.g., &lt;code&gt;turnOn&lt;/code&gt;と&lt;code&gt;turnOff&lt;/code&gt;）などを返す．On/Off Messageは名前の通りにOn/Offのコマンドの処理を行う．今回の場合はここでIRKitへリクエストを行う．&lt;/p&gt;

&lt;h2 id=&#34;golangでirkitを操作する&#34;&gt;GolangでIRKitを操作する&lt;/h2&gt;

&lt;p&gt;IRKitには&lt;a href=&#34;http://getirkit.com/en/#IRKit-Internet-API&#34;&gt;Internet HTTP API&lt;/a&gt;があり&lt;a href=&#34;https://api.getirkit.com&#34;&gt;api.getirkit.com&lt;/a&gt;経由で自宅のIRKitを操作することができる．これは単純なHTTP Requestなので標準の&lt;code&gt;net/http&lt;/code&gt;パッケージでなんとかなる．が他にもやりたいことがあったのでClientパッケージ &lt;a href=&#34;https://github.com/tcnksm/go-irkit&#34;&gt;tcnksm/go-irkit&lt;/a&gt; を書いた（自分が欲しいものしか書いてないので完全なClientではない）．&lt;/p&gt;

&lt;p&gt;例えばSignalを送るには以下のようにする．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;f, err := os.Open(filePath)
if err != nil {
    log.Fatalf(&amp;quot;[ERROR] %s&amp;quot;, err)
}

var msg irkit.Message
decoder := json.NewDecoder(f)
if err := decoder.Decode(&amp;amp;msg); err != nil {
    log.Fatalf(&amp;quot;[ERROR] %s&amp;quot;, err)
}

c := irkit.DefaultInternetClient()
err = c.SendMessages(context.Background(), key, id, &amp;amp;msg)
if err != nil {
    log.Fatalf(&amp;quot;[ERROR] %s&amp;quot;, err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（&lt;code&gt;context&lt;/code&gt;パッケージを使いモダンな感じに仕上げてある）&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;Golangを使ったAmazon EchoのSmart Home Skillの開発を紹介した．日本に上陸したときは皆GolangでSkillを書きましょう．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go1.7のSubtestsとSub-benchmarks</title>
      <link>http://deeeet.com/writing/2016/08/02/go1_7-subtest/</link>
      <pubDate>Tue, 02 Aug 2016 09:00:00 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/08/02/go1_7-subtest/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://tip.golang.org/doc/go1.7&#34;&gt;Go1.7&lt;/a&gt;では&lt;a href=&#34;https://github.com/golang/go/wiki/TableDrivenTests&#34;&gt;SubtestsとSub-benchmarks&lt;/a&gt;という機能が&lt;code&gt;testing&lt;/code&gt;パッケージに導入される．これを使うとテスト関数/ベンチマーク関数の中にテスト/ベンチマークを定義できるようになる．テストの場合はテストに階層を持たせることができ，ベンチマークの場合は&lt;a href=&#34;https://github.com/golang/go/wiki/TableDrivenTests&#34;&gt;Table Driven&lt;/a&gt;的にベンチマークを記述することができるようになる．さらに一連のテスト/ベンチマークに対して共通のsetupとtear-downを持たせることもできる．&lt;/p&gt;

&lt;p&gt;テストの場合は&lt;a href=&#34;https://github.com/golang/go/wiki/TableDrivenTests&#34;&gt;Table Driven Tests&lt;/a&gt;で十分なことも多く恩恵は少ないかもしれない．それよりもベンチーマークで効果を発揮することが多い．&lt;/p&gt;

&lt;p&gt;例えば以下のように異なる設定値を使って&lt;code&gt;Foo&lt;/code&gt;のベンチマークをとるとする．今までであればそれぞれ設定値ごとにベンチマーク関数を準備する必要があった．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func BenchmarkFoo1(b *testing.B)   { benchFoo(b, 1) }
func BenchmarkFoo10(b *testing.B)  { benchFoo(b, 10) }
func BenchmarkFoo100(b *testing.B) { benchFoo(b, 100) }

func benchFoo(b *testing.B, base int) {
    for i := 0; i &amp;lt; b.N; i++ {
        Foo(base)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go1.7のSub-benchmarkを使うと以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func BenchmarkFoo(b *testing.B) {
    cases := []struct {
        Base int
    }{
        {Base: 1},
        {Base: 10},
        {Base: 100},
    }

    for _, bc := range cases {
        b.Run(fmt.Sprintf(&amp;quot;%d&amp;quot;, bc.Base), func(b *testing.B) { benchFoo(b, bc.Base) })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず複数の関数を一つの関数にまとめることができる．そして設定値をTable-Driven的に書くことができる．これによりシンプルになりかつ可読性も上がる．Sub-benchmark名はトップレベルの関数名（&lt;code&gt;BenchmarkFoo&lt;/code&gt;）と&lt;code&gt;Run&lt;/code&gt;関数に渡す文字列を&lt;code&gt;/&lt;/code&gt;で繋いだものになる．例えば上の例の場合は&lt;code&gt;BenchmarkFoo/1&lt;/code&gt;&amp;hellip;となる．またforループの前後に&lt;code&gt;BenchmarkFoo&lt;/code&gt;専用のsetup・tear-down処理を記述することもできる．&lt;/p&gt;

&lt;p&gt;標準パッケージの変更を見ていてもSubtestよりもSub-benchmarkで恩恵を得ているのがわかる．例えば以下のような使われ方をしている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://go-review.googlesource.com/#/c/23428/&#34;&gt;https://go-review.googlesource.com/#/c/23428/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://go-review.googlesource.com/#/c/23429/&#34;&gt;https://go-review.googlesource.com/#/c/23429/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://go-review.googlesource.com/#/c/23420/&#34;&gt;https://go-review.googlesource.com/#/c/23420/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;またSubtestsはParallelテストの制御にも使える．&lt;code&gt;t.Parallel()&lt;/code&gt;を使えば個々のテストは並行処理される．そして全てのサブテストが終了した時点でトップレベルの関数に戻る．これを使えば，並行でテストを走らせて全ての処理が終了したら後処理を行うといったことができる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;GopherCon 2016のLT &lt;a href=&#34;http://go-talks.appspot.com/github.com/freeformz/talks/20160712_gophercon/talk.slide#1&#34;&gt;&amp;ldquo;State of Go 2016&amp;rdquo;&lt;/a&gt; によるとベンチマークを書いてるひとは&lt;a href=&#34;http://go-talks.appspot.com/github.com/freeformz/talks/20160712_gophercon/talk.slide#30&#34;&gt;まだ少ない&lt;/a&gt;．この変更でもう少し増えると良い．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go1.7のcontextパッケージ</title>
      <link>http://deeeet.com/writing/2016/07/22/context/</link>
      <pubDate>Fri, 22 Jul 2016 09:12:28 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/07/22/context/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://tip.golang.org/doc/go1.7&#34;&gt;Go1.7&lt;/a&gt;では&lt;a href=&#34;https://godoc.org/golang.org/x/net/context&#34;&gt;golang.org/x/net/context&lt;/a&gt;が&lt;code&gt;context&lt;/code&gt;パッケージとして標準パッケージに仲間入りする．そしていくつかの標準パッケージでは&lt;code&gt;context&lt;/code&gt;パッケージを使ったメソッド/関数も新たに登場する．&lt;code&gt;context&lt;/code&gt;パッケージは今後さらに重要な，Gopherは普通に扱うべき，パッケージになると考えられる．本記事ではそもそも&lt;code&gt;context&lt;/code&gt;パッケージとは何か？なぜ登場したのか？なぜ重要なのか？どのように使うべきか？についてまとめる．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;パッケージが初めて紹介されたのは2014年のThe Go Blogの記事 &lt;a href=&#34;https://blog.golang.org/context&#34;&gt;&amp;ldquo;Go Concurrency Patterns: Context&amp;rdquo;&lt;/a&gt;である．この記事ではなぜGoogleが&lt;code&gt;context&lt;/code&gt;パッケージを開発したのか，どのように使うのか具体的な検索タスクを例に解説されている．まだ読んだことがない人はそちらを先に読むと良い．&lt;/p&gt;

&lt;h2 id=&#34;contextパッケージとは何か&#34;&gt;contextパッケージとは何か&lt;/h2&gt;

&lt;p&gt;ここでは具体的な利用例から&lt;code&gt;context&lt;/code&gt;とは何かを説明する．&lt;/p&gt;

&lt;p&gt;例えばGoの典型的な利用例であるWebアプリケーションを考える．Goのサーバにおいてリクエストはそれぞれ個別のgoroutineで処理される．そしてリクエストHandlerは新たなgoroutineを生成しバックエンドのDBや別のサーバにリクエストを投げ結果を得てユーザに対してレスポンスを返す．&lt;/p&gt;

&lt;p&gt;このような別サーバへのリクエストのように時間のかかる処理をgoroutineで実行する場合どのようなことに注意する必要があるだろうか．まず最初に注意するべきはその処理に適切なTimeoutやDeadlineを設定して処理が停滞するのを防ぐことである．例えば別のサーバにリクエストを投げる場合にネットワークの問題でリクエストに時間がかかってしまうことは大いに考えられる．リクエストにTimeoutを設定して早めにレスポンスを返しリトライを促すべきである．&lt;/p&gt;

&lt;p&gt;次に注意するべきは生成したgoroutineを適切にキャンセルしリソースを解放することである．例えば別のサーバにリクエストを投げる場合に適切なキャンセル処理を行わないとTimeout後もネットワークリソースが使われ続けることになる（CPUやメモリを使い続けるかもしれない）．この場合&lt;code&gt;net/http&lt;/code&gt;パッケージレベルでリクエストをキャンセルするべきである．&lt;/p&gt;

&lt;p&gt;さらにそのgoroutineは別のgoroutineを呼び出しそれがまた別の&amp;hellip;と呼び出しの連鎖は深くなることが考えられる．その場合も親のTimeoutに合わせてその子は全て適切にキャンセルされリソースは解放されるべきである．．&lt;/p&gt;

&lt;p&gt;このようにキャンセル処理は重要である．&lt;code&gt;context&lt;/code&gt;パッケージはこのキャンセルのためのシグナルをAPIの境界を超えて受け渡すための仕組みである．ある関数から別の関数へと，親から子へと，キャンセルを伝搬させる．&lt;/p&gt;

&lt;p&gt;これは&lt;code&gt;context&lt;/code&gt;を使わなくても実現できる．しかし標準パッケージになったことで&lt;code&gt;context&lt;/code&gt;は「キャンセルのためのシグナルの受け渡しの標準的なインターフェース」として使える．この流れは別の標準パッケージに新たに追加された関数に見ることができる．&lt;/p&gt;

&lt;p&gt;（後述するが&lt;code&gt;context&lt;/code&gt;パッケージは限定されたスコープの値，例えば認証情報など，の受け渡しとしても利用できる．しかし筆者はこれは付随的な機能でありキャンセル機構としての&lt;code&gt;context&lt;/code&gt;の方が重要であると考えている）&lt;/p&gt;

&lt;h2 id=&#34;コードで追うcontextパッケージ&#34;&gt;コードで追うcontextパッケージ&lt;/h2&gt;

&lt;p&gt;言葉のみでは伝わりにくいので具体的なサンプルコードを使って&lt;code&gt;context&lt;/code&gt;パッケージの使いどころを説明する．&lt;/p&gt;

&lt;p&gt;以下のような単純なリクエストHandlerを考える．このHandlerはユーザからのリクエストを受けバックエンドのサービスにリクエストを投げる．そして得た結果をユーザに返す（具体的なレスポンスの書き込みなどは省略している）．リクエストは別のgoroutineで投げ，エラーをchannelで受け取る．このコードを改善していく．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    // 新たにgoroutineを生成してバックエンドにリクエストを投げる
    // 結果をerror channelに入れる
    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request()
    }()

    // error channelにリクエストの結果が返ってくるのを待つ
    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;まず現状のコードはネットワークの問題などで&lt;code&gt;request()&lt;/code&gt;に時間がかかりユーザへのレスポンスが停止してしまう可能性がある．これを防ぐためにはTimeoutを設定するべきである．&lt;code&gt;time&lt;/code&gt;パッケージの&lt;code&gt;time.After&lt;/code&gt;を使うと以下のようにTimeoutを設定することができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request()
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
        
    // Timeout（2秒）を設定する．
    // 例えばしばらく経ってから再度リクエストをするように
    // レスポンスを返す．
    case &amp;lt;-time.After(2 * time.Second):
        log.Println(&amp;quot;failed: timeout&amp;quot;)
        return
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでリクエストがネットワークなどの不調によりリクエストが停滞してしまう問題は解決できた．しかしこれでは不十分である．Timeoutでリクエストをユーザに返した後も&lt;code&gt;request&lt;/code&gt;は別のgoroutineで動き続ける．つまりサーバのリソースを使い続ける．少量であれば問題ないがリクエストが増えれば増えるほど問題になる．これを防ぐには&lt;code&gt;request()&lt;/code&gt;をキャンセル可能にリソースを解放するべきである．&lt;code&gt;context&lt;/code&gt;を使わない場合は，これは例えば以下のように実装できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    // handlerからrequestをキャンセルするためのchannelを準備する
    doneCh := make(chan struct{}, 1)
    
    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request(doneCh)
    }()

    // 別途goroutineを準備してTimeoutを設定する
    go func() {
        &amp;lt;-time.After(2 * time.Second)
        // Timeout後にdoneChをクローズする
        // 参考: https://blog.golang.org/pipelines
        close(doneCh)
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;request()&lt;/code&gt;は以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func request(doneCh chan struct{}) error {
    tr := &amp;amp;http.Transport{}
    client := &amp;amp;http.Client{Transport: tr}
    
    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, backendService, nil)
    if err != nil {
        return err
    }
　　
    // 新たにgoroutineを生成して実際のリクエストを行う
    // 結果はerror channelに投げる
    errCh := make(chan error, 1)
    go func() {
        _, err := client.Do(req)
        errCh &amp;lt;- err
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            return err
        }
    
    // doneChはhandlerからのキャンセル シグナル（close(doneCh)）
    // を待ち受ける
    case &amp;lt;-doneCh:
        // キャンセルが実行されたら適切にリクエストを停止して
        // エラーを返す．
        tr.CancelRequest(req)
        &amp;lt;-errCh
        return fmt.Errorf(&amp;quot;canceled&amp;quot;)
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;パッケージを使うとこれはより簡単に書くことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    // 2秒でTimeoutするcontextを生成する
    // cancelを実行することでTimeout前にキャンセルを実行することができる
    //     
    // また後述するようにGo1.7ではnet/httpパッケージでcontext
    // を扱えるようになる．例えば*http.Requestからそのリクエストの
    // contextを取得できる．
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    errCh := make(chan error, 1)
    go func() {
        errCh &amp;lt;- request3(ctx)
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            log.Println(&amp;quot;failed:&amp;quot;, err)
            return
        }
    }

    log.Println(&amp;quot;success&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;request()&lt;/code&gt;は以下のように書ける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func request(ctx context.Context) error {
    tr := &amp;amp;http.Transport{}
    client := &amp;amp;http.Client{Transport: tr}
    
    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, backendService, nil)
    if err != nil {
        return err
    }

    // 新たにgoroutineを生成して実際のリクエストを行う
    // 結果はerror channelに投げる
    errCh := make(chan error, 1)
    go func() {
        _, err := client.Do(req)
        errCh &amp;lt;- err
    }()

    select {
    case err := &amp;lt;-errCh:
        if err != nil {
            return err
        }
    
    // Timeoutが発生する，もしくはCancelが実行されると
    // Channelが返る
    case &amp;lt;-ctx.Done():
        tr.CancelRequest(req)
        &amp;lt;-errCh
        return ctx.Err()
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;doneCh&lt;/code&gt;と比べると&lt;code&gt;context&lt;/code&gt;を使った場合はよりシンプルに書けているのがわかる．これだけではない．標準パッケージになるということは，今後はこの重要なキャンセル処理を統一的なインターフェースとして書くことができるということである．&lt;/p&gt;

&lt;h2 id=&#34;contextの契約&#34;&gt;contextの契約&lt;/h2&gt;

&lt;p&gt;具体的な使い方は&lt;a href=&#34;https://tip.golang.org/pkg/context/&#34;&gt;ドキュメント&lt;/a&gt;が詳しいのでそれを読むのが良い．大きなパッケージではないのですぐに読めると思う．以下では注意するべきことを簡単にまとめる．&lt;/p&gt;

&lt;p&gt;まず自分で&lt;code&gt;context&lt;/code&gt;を前提としたメソッド/関数を提供する場合は以下の形式を守る．必ずメソッド/関数の第一引数に&lt;code&gt;context.Context&lt;/code&gt;を渡せるようにする．structなどに埋め込んではいけない．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func DoSomething(ctx context.Context, arg Arg) error {
    // ... use ctx ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに&lt;code&gt;context&lt;/code&gt;をもつ関数は適切なキャンセル処理を実装するべきである．この関数を使う側は呼び出し側（つまり親&lt;code&gt;context&lt;/code&gt;）でTimeoutが発生した，もしくは&lt;code&gt;Cancel&lt;/code&gt;を実行した場合に適切にキャンセル処理・リソースの解放が実行されることを期待する．例えば，上のサンプルコードで示したようにHTTPリクエストであれば&lt;code&gt;CancelRequest&lt;/code&gt;を呼び確実に処理を終了させる必要がある．&lt;/p&gt;

&lt;p&gt;内部で別の関数を呼ぶ場合も&lt;code&gt;context&lt;/code&gt;を前提とし親&lt;code&gt;context&lt;/code&gt;からキャンセル可能にするべきである．標準パッケージで&lt;code&gt;context&lt;/code&gt;を前提としたメソッド/関数が実装され始めているのはこの理由によると思う．&lt;/p&gt;

&lt;p&gt;これらがGopherの間の&lt;code&gt;context&lt;/code&gt;の契約になると思う．&lt;/p&gt;

&lt;h2 id=&#34;valueの扱い&#34;&gt;Valueの扱い&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;パッケージは限定されたスコープの値，例えば認証情報など，の受け渡しとしても利用できる．しかしこれはキーと値を&lt;code&gt;interface{}&lt;/code&gt;型で指定するため利用には注意が必要である．ドキュメントにも利用するときの注意点がしっかり書かれている．例えば，値の取り出しには専用のメソッド/関数を準備してちゃんとした型として値を返すようにする，キーは公開しないなどである．&lt;/p&gt;

&lt;p&gt;またどのような値を渡すべきかに関しては&lt;a href=&#34;http://peter.bourgon.org/go-kit/&#34;&gt;go-kit&lt;/a&gt;の開発者である&lt;a href=&#34;https://twitter.com/peterbourgon&#34;&gt;Peter Bourgo&lt;/a&gt;氏のブログが非常に参考になる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://peter.bourgon.org/blog/2016/07/11/context.html&#34;&gt;context&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;標準パッケージの中のcontext&#34;&gt;標準パッケージの中のcontext&lt;/h2&gt;

&lt;p&gt;先にも述べたようにGo1.7ではいくつかの標準パッケージで&lt;code&gt;context&lt;/code&gt;パッケージを使ったメソッド/関数が実装された．実装されたのは&lt;code&gt;net&lt;/code&gt;と&lt;code&gt;net/http&lt;/code&gt;，そして&lt;code&gt;os/exec&lt;/code&gt;である．それぞれ簡単に紹介する．&lt;/p&gt;

&lt;h3 id=&#34;net&#34;&gt;net&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;net&lt;/code&gt;パッケージには&lt;code&gt;Dialer&lt;/code&gt;に新たに&lt;code&gt;DialContext()&lt;/code&gt;メソッドが追加された．これは既存の&lt;code&gt;Dial()&lt;/code&gt;メソッドに&lt;code&gt;context.Context&lt;/code&gt;を渡せるようにしたメソッドである．例えば以下のように使うことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)
defer cancel()

var dialer net.Dialer
conn, err := dialer.DialContext(ctx, &amp;quot;tcp&amp;quot;, &amp;quot;google.com:80&amp;quot;)
if err != nil {
    log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;net-http&#34;&gt;net/http&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;net/http&lt;/code&gt;には&lt;code&gt;Request&lt;/code&gt;に新たに&lt;code&gt;Context()&lt;/code&gt;メソッドと&lt;code&gt;WithContext()&lt;/code&gt;メソッドが追加された．&lt;code&gt;Context()&lt;/code&gt;はそのリクエストにおける&lt;code&gt;context.Context&lt;/code&gt;を取得するために，&lt;code&gt;WithContext()&lt;/code&gt;は変更に用いる．&lt;/p&gt;

&lt;p&gt;Clientとしては以下のようにリクエストのキャンセルに使うことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;req, err := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;http://google.com&amp;quot;, nil)
if err != nil {
    log.Fatal(err)
}

ctx, cancel := context.WithTimeout(req.Context(), 100*time.Millisecond)
defer cancel()

req = req.WithContext(ctx)

client := http.DefaultClient
res, err := client.Do(req)
if err != nil {
    log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;サーバーとしては以下のように&lt;code&gt;context.WithValue()&lt;/code&gt;を用いて各リクエストのスコープに限定した値の受け渡しなどに使うことができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;const tokenKey = &amp;quot;tokenKey&amp;quot;

func withAuth(a Authorizer next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        auth := r.Header.Get(&amp;quot;Authorization&amp;quot;)
        token := a.Auth(auth)
        
        ctx := r.Context()
        ctx = context.WithValue(ctx, tokenKey, token)
        next.ServeHTTP(w, r.WithContext(ctx))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;またデフォルトで&lt;code&gt;ServerContextKey&lt;/code&gt;と&lt;code&gt;LocalAddrContextKey&lt;/code&gt;というキーでリクエストの&lt;code&gt;context.Context&lt;/code&gt;にそれぞれ&lt;code&gt;*http.Server&lt;/code&gt;と&lt;code&gt;net.Addr&lt;/code&gt;の値がセットされておりそれを使うこともできる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func handler(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    srv := ctx.Value(ServerContextKey)
    ....
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;os-exec&#34;&gt;os/exec&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;os/exec&lt;/code&gt;には&lt;code&gt;CommandContext()&lt;/code&gt;関数が追加された．これは既存の&lt;code&gt;Command()&lt;/code&gt;関数に&lt;code&gt;context.Context&lt;/code&gt;を渡せるようにした関数である．例えば以下のように使うことができる&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;cmd := exec.CommandContext(ctx, &amp;quot;sleep&amp;quot;, &amp;quot;2&amp;quot;)
if err := cmd.Run(); err != nil {
    log.Fatal(err) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;context.Context&lt;/code&gt;が終了すると&lt;code&gt;os.Process.Kill&lt;/code&gt;が実行される．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;context&lt;/code&gt;は&lt;code&gt;net&lt;/code&gt;関連で主に使われてきたが，そうではない場合であってもタスクにDeadlineやTimeout，Cancelを持たせるための標準的なインターフェースに利用可能であることを示す良い例である．&lt;/p&gt;

&lt;h2 id=&#34;context-leakを避ける&#34;&gt;Context leakを避ける&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;WithCancel&lt;/code&gt;や&lt;code&gt;WithTimeout&lt;/code&gt;，&lt;code&gt;WithDeadline&lt;/code&gt;で返される&lt;code&gt;cancel&lt;/code&gt;が呼ばれないと，その親&lt;code&gt;Context&lt;/code&gt;が&lt;code&gt;cancel&lt;/code&gt;されるまでその子&lt;code&gt;Context&lt;/code&gt;がLeakする（context leak）．Go1.7からの&lt;code&gt;go vet&lt;/code&gt;はそれを検出する（&lt;code&gt;-lostcancel&lt;/code&gt;）．例えば以下のような出力が得られる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func leak() {
    var ctx, cancel = context.WithCancel() 
    // the cancel function is not used on all paths 
    // (possible context leak)
    
    // this return statement may be reached 
    // without using the cancel var defined on line x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://go-review.googlesource.com/#/c/24150/13/src/cmd/vet/testdata/lostcancel.go&#34;&gt;こちらの変更&lt;/a&gt;を見ると別の検出パターンもわかる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;どんどん使っていきましょう．&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tip.golang.org/doc/go1.7&#34;&gt;Go 1.7 Release Notes DRAFT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dahernan.github.io/2015/02/04/context-and-cancellation-of-goroutines/&#34;&gt;Context and Cancellation of goroutines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://talks.golang.org/2014/gotham-context.slide#1&#34;&gt;Cancelation, Context, and Plumbing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39#.im1d1tr4r&#34;&gt;How to correctly use context.Context in Go 1.7&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GopherCon 2016でLTした</title>
      <link>http://deeeet.com/writing/2016/07/12/gophercon2016-lt/</link>
      <pubDate>Tue, 12 Jul 2016 19:04:47 -0600</pubDate>
      
      <guid>http://deeeet.com/writing/2016/07/12/gophercon2016-lt/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://gophercon.com/&#34;&gt;GopherCon 2016&lt;/a&gt;でLTをした．&lt;a href=&#34;https://twitter.com/tenntenn&#34;&gt;@tenntenn&lt;/a&gt;さんがやった通常トーク（50分）はなかなかハードルが高いがLTは初めの一歩として良いと思う．来年もDenverで再び開催されることがアナウンスされているので来年以降に発表するひとのためにどんな感じだったかを簡単に書いておく．&lt;/p&gt;

&lt;h2 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://go-talks.appspot.com/github.com/tcnksm/talks/2016/07/gophercon/gophercon.slide#1&#34;&gt;発表スライド&lt;/a&gt;を見てもらえばわかるが特に新しい話をしたわけではない．日本のミートアップなどで話したこと，ブログに書いたことを英語にしただけにすぎない（ただ実演デモをするという挑戦はした）．&lt;/p&gt;

&lt;p&gt;「大御所たちと同じステージで喋る機会を逃すのはもったいない」（ちなみに当日のLTは僕の次が&lt;a href=&#34;https://twitter.com/robertgriesemer&#34;&gt;Robert Griesemer&lt;/a&gt;氏でその次が&lt;a href=&#34;https://twitter.com/bradfitz&#34;&gt;Brad Fitzpatrick&lt;/a&gt;氏だった！），「日本のGo界隈にこんなやつおるでってのを知ってもらいたい」というモチベーションで発表した．あとなんとなく自分の中でここでぶっ込まないと一生逃げると思ったのもある（通常セッションにしろやって話だが50分喋る良いネタがなかった..）．&lt;/p&gt;

&lt;h2 id=&#34;流れ&#34;&gt;流れ&lt;/h2&gt;

&lt;p&gt;まずLTセッションの募集は会議開催の10日前ほどにアナウンスされた（&lt;a href=&#34;https://blog.gopheracademy.com/gophercon-2016/gophercon2016-lightning-announce/&#34;&gt;&amp;ldquo;GopherCon 2016 - Lightning Talk Annoucement&amp;rdquo;&lt;/a&gt;）．逃さないためにはtwitterの&lt;a href=&#34;https://twitter.com/gophercon&#34;&gt;@GopherCon&lt;/a&gt;や&lt;a href=&#34;https://invite.slack.golangbridge.org/&#34;&gt;Gophers slack&lt;/a&gt;をちゃんとウォッチしておくと良い．&lt;/p&gt;

&lt;p&gt;CFPは&lt;a href=&#34;https://www.papercall.io/gophercon-lightning-talks-2016&#34;&gt;PaperCall&lt;/a&gt;で行われた．タイトルや発表内容をちゃんと書く．&lt;/p&gt;

&lt;p&gt;結果の発表は開催前日に，発表日は通常会議の初日に，発表順は当日その場で発表された．そのため資料の準備と練習の時間はほとんどない．飛行機での移動中などに形だけ資料を完成させ会議の合間に練習するしかない．また事前にディスプレイの接続チェックなどはできないので特殊なことはしないほうがよい．&lt;/p&gt;

&lt;p&gt;発表場所は上の写真のメインルーム．発表時間は6分で，質疑応答は次の発表者の準備が完了するまで行われた．&lt;/p&gt;

&lt;p&gt;LTセッションは通常会議が行われた2日間両方で行われ，発表人数はそれぞれ12名だった．他の発表や自分の発表を考えると採択率は高いと感じた（直前なので申し込む人が少なかったのかもしれない）．&lt;/p&gt;

&lt;p&gt;この流れは来年変わるかもしれないし変わらないかもしれない．もし来年移行挑戦する人がいればぜひ参考にしてください．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;偉そうに書いたが採択されてからひたすら緊張し「聴衆として普通に楽しむだけにすればよかった」と何度も思った．ただ終わってみればやってよかったという気持ちしかない（&lt;a href=&#34;https://twitter.com/___leigh___/status/753005029993381896&#34;&gt;こういうリプライ&lt;/a&gt;もらえたり，終わった後に議論できて良かった）．機会があるひとはどんどん挑戦しましょう．&lt;/p&gt;

&lt;p&gt;ちなみに通常セッションのトークは以下が最高だったのでビデオが公開されたら全部観ましょう．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Understanding nil&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Navigating Unfamiliar Code with the Go Guru&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go for Data Science&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Visualizing Concurrency in Go&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go for Crypto Developers&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Inside the Map Implementation&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go Without the Operating System&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The Design of the Go Assembler&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;cgo: Safely Taming the Beast&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golangの新しいGCアルゴリズム Transaction Oriented Collector（TOC）</title>
      <link>http://deeeet.com/writing/2016/06/29/toc/</link>
      <pubDate>Wed, 29 Jun 2016 10:31:00 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/06/29/toc/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://golang.org/s/gctoc&#34;&gt;http://golang.org/s/gctoc&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Goの新しいGCのProposalが出た．まだProposal段階であり具体的な実装はないが簡単にどのようなものであるかをまとめておく．&lt;/p&gt;

&lt;p&gt;GoのGCはGo1.5において単純なStop The World（STW）からConcurrent Mark &amp;amp; Sweepへと変更され大きな改善があった（詳しくは&lt;a href=&#34;http://deeeet.com/writing/2016/05/08/gogc-2016/&#34;&gt;&amp;ldquo;GolangのGCを追う&amp;rdquo;&lt;/a&gt;に書いた）．先の記事に書いたようにGo1.5におけるGCの改善は主にレイテンシ（最大停止時間）に重きが置かれいた．数値目標として10msが掲げられGo1.6においては大きなヒープサイズ（500GB）においてそれを達成していた．&lt;/p&gt;

&lt;p&gt;GCの評価項目はレイテンシのみではない．スループットやヒープの使用効率（断片化の対処）なども重要である．Go1.6までのGCではそれらについて大きく言及されていなかった（と思う）．例えばスループットに関してはハードウェアの進化がそれを改善するはずであるという前提が置かれていた（&lt;a href=&#34;https://blog.golang.org/go15gc&#34;&gt;&amp;ldquo;Go GC: Prioritizing low latency and simplicity&amp;rdquo;&lt;/a&gt;）．&lt;/p&gt;

&lt;p&gt;今回提案されたTransaction Oriented Collector（TOC）アルゴリズムはGCのスループットを改善するものである．&lt;/p&gt;

&lt;h2 id=&#34;tocアルゴリズムの経験則&#34;&gt;TOCアルゴリズムの経験則&lt;/h2&gt;

&lt;p&gt;Transaction Oriented Collector（TOC）アルゴリズムは「あるTransactionで生成されたオブジェクトはTransactionが終了すると同時にすぐ死ぬことが多い」という経験則に基づくアルゴリズムである．ここでいうTransactionとはいわゆる&lt;a href=&#34;https://en.wikipedia.org/wiki/ACID&#34;&gt;ACID&lt;/a&gt;における不可分な処理単位ではなく，Webサービスなどでリクエスト受けてレスポンスを返すまでの一連の処理を示す．&lt;/p&gt;

&lt;p&gt;この仮定はGenerational GC（世代別GC）が利用している「多くのオブジェクトは生成されてすぐにゴミとなりわずかなオブジェクトだけが長く生き残る」という経験則に似ている．TOCアルゴリズムはこの経験則のGoなりの再解釈のようにも見える．&lt;/p&gt;

&lt;p&gt;このTOCアルゴリズムの経験則はどこから来たか? Goが多くサポートしているCloudアプリケーションである．このようなアプリーションは，他のネットワークや他のGoroutineからメッセージを受け，それをUnmarshalし，それを使い計算をし，結果をMarshalし，それを他のネットワークやGoroutineに投げる．そしてそのGoroutineは死ぬか他のリクエストを受けるために停止状態になる．&lt;/p&gt;

&lt;p&gt;リクエスト中での計算では大きなヒープからデータを読み込むことはあるかもしれないが典型的には書き込みは滅多に起きずヒープはTransaction間で一定になる．そしてGoroutine内で新たにアロケートしたオブジェクトは他のGoroutineに共有される（publish）かもしれないし共有されない（local）かもしれない．TOCアルゴリズムはこの共有されない場合の観測結果を使う，つまり「もしGoroutineがその中でアロケートしたオブジェクトを共有しない場合，そのオブジェクトはGC時に到達不可能になり関連するメモリ領域はすぐにアロケートできる」である．&lt;/p&gt;

&lt;p&gt;TOCアルゴリズムの恩恵を受けるのは&lt;code&gt;net/http#Server&lt;/code&gt;や&lt;code&gt;net/rpc#Server&lt;/code&gt;を使ったアプリケーションであると想像できる．&lt;/p&gt;

&lt;h2 id=&#34;tocアルゴリズムの実装の提案&#34;&gt;TOCアルゴリズムの実装の提案&lt;/h2&gt;

&lt;p&gt;TOCアルゴリズムの実装はProposalの&lt;a href=&#34;https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/edit#heading=h.aqj7hn20fsaw&#34;&gt;Examples&lt;/a&gt;をみるとわかりやすい．&lt;/p&gt;

&lt;p&gt;（まず前提としてGoのGCのMarkはBitmapで管理されている．BitmapはオブジェクトのヘッダにMarkbitを持たせるのではなく関連するメモリ領域をBitのテーブルとして別で集中管理する手法である．これはCopy-On-Writeとの相性が良いなどがある）．&lt;/p&gt;

&lt;p&gt;TOCアルゴリズムでは各Goroutineは2つのPointerをもつ．1つはCurrent Sweep Pointerである．このPointerはどこまでSweepを行ったか（Allocateしたか）を示す．もう1つはInitial Sweep Pointerである．これはそのGoroutine開始時のSweep Pointerを示す．この2つのPointerの間のオブジェクトはMarkされていようがMarkされていまいが「そのGoroutineで新たにアロケートされたオブジェクト」となる．そしてMarkされていないオブジェクトは共有されていない（Publishされていない）オブジェクトであるとする．&lt;/p&gt;

&lt;p&gt;これをどのように実現するか? ライトバリア（Write barrier）を使う．このライトバリアはそのGoroutine内で新たにアロケートされたオブジェクトがInvariantであることを保証する．つまりそのオブジェクトが他に共有されればMarkをつける．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;10011110010100101010100001001011010010110100101001011101010111101
　　　　^                 &amp;lt;- before  ^  after -&amp;gt;
　　　　Initial Sweep Pointer        Current Sweep Pointer     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（Proposalの図を拝借させてもらった．1は前回のGCで到達可能であったオブジェクト，もしくはGoroutineで新たにアロケートされそしてPublishされたオブジェクトである．BeforeとInitialの間にある0はアロケートされたがPublishされていないオブジェクトである．Afterにある0はまだアロケートされていないオブジェクトである）&lt;/p&gt;

&lt;p&gt;あとはGoroutine終了時にCurrent Sweep PointerをInitial Sweep Pointerへと戻せば良い．新たにオブジェクトが生成されていようとそれが共有されていなければMarkは立っていないので，次回のGCサイクルを待たずに次回のSweepにおいてアロケートの対象になる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;簡単にGoの新たなGCのProposalを追ってみた．今後の実装とそれによる効果がどうなるかが楽しみである．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GolangでFlame Graphを描く</title>
      <link>http://deeeet.com/writing/2016/05/29/go-flame-graph/</link>
      <pubDate>Sun, 29 May 2016 14:22:17 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/05/29/go-flame-graph/</guid>
      <description>

&lt;p&gt;アプリケーションのパフォーマンス問題の解決やチューニングで大切なのは問題のコアやボトルネックに最短パスで到達することである．&lt;/p&gt;

&lt;p&gt;基本的なパフォーマンス分析の入り口はアプリケーションのスレッドがon-CPUで時間を消費しているかoff-CPUで時間を消費しているかを理解するところから始まる．on-CPUの場合はそれがuserモードかkernelモードかを特定し，さらにCPUプロファイリングによってどのcode pathがCPUを消費しているのかの分析に向かう．off-CPUの場合はI/OやLock，pagingといった問題の分析に向かう．&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;&gt;Flame Graph&lt;/a&gt;はon-CPUでのパフォーマンスの問題が発覚した時に行うCPUプロファイリングを助ける．どのcode pathがボトルネックになっているのかを1つのグラフ上で理解できる．本記事ではFlame Graphとは何か? なぜ必要なのか? を解説しGoのアプリケーションでそれを用いるために方法を解説する．&lt;/p&gt;

&lt;h2 id=&#34;flame-graphとは何か&#34;&gt;Flame Graphとは何か?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.brendangregg.com/flamegraphs.html&#34;&gt;Flame Graph&lt;/a&gt;はCPUプロファイリング結果をvisualizeしたグラフである．元Joyent，現Netflixの&lt;a href=&#34;http://www.brendangregg.com/index.html&#34;&gt;Brendan Gregg&lt;/a&gt;氏によって開発された．例えば以下はMySQLのCPUプロファイリング結果をFlame Graphで描画したものである．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.brendangregg.com/FlameGraphs/cpu-mysql-filt.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;cpu-プロファイリング&#34;&gt;CPU プロファイリング&lt;/h3&gt;

&lt;p&gt;CPUプロファイリングの共通のテクニックはStack traceのサンプリングである．Stack traceというのは関数コールのリストで，code pathの先祖を追うことができる．例えば，以下はGolangのstack traceで子から親へStackと辿ることができる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;syscall.Syscall
syscall.write
syscall.Write
os.(*File).write
os.(*File).Write
log.(*Logger).Output
log.Printf
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flame-graphの初期衝動&#34;&gt;Flame Graphの初期衝動&lt;/h3&gt;

&lt;p&gt;CPUプロファイリングの出力は往々にしてverboseである．例えば，Brendan Gregg氏がFlame GraphをつくるきっかけとなったプロダクションのMySQLのプロファイリングの出力は500,000行近くもあったという（&lt;a href=&#34;http://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs/16&#34;&gt;参考画像&lt;/a&gt;&amp;hellip;やばいw）．&lt;/p&gt;

&lt;p&gt;Flame Graphはそのような膨大なCPUプロファイリングを一つのグラフ上で直感的かつ簡単に理解するために開発された．&lt;/p&gt;

&lt;h3 id=&#34;flame-graphの読み方&#34;&gt;Flame Graphの読み方&lt;/h3&gt;

&lt;p&gt;以下はFlame Graphを単純化したものである．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deliveryimages.acm.org/10.1145/2930000/2927301/gregg6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stack traceは長方形のボックスの列で表現される．1つ1つのボックスは関数（Stack frame）を示す&lt;/li&gt;
&lt;li&gt;y軸はStackの深さを示す．一番上のボックスはStack traceが収集された時にon-CPUであった関数であり，その下にあるボックスはすべて先祖になる．あるボックスの下にあるボックスはその関数の親である（高いほど悪いわけではない）&lt;/li&gt;
&lt;li&gt;x軸はその関数のSampleの割合を示す．&lt;strong&gt;時間ではない&lt;/strong&gt;．それぞれの関数はアルファベット順にソートされているだけ&lt;/li&gt;
&lt;li&gt;それぞれのボックスの幅はその関数の出現頻度を示す（長いほどStack trace中に多く登場したこと意味する）&lt;/li&gt;
&lt;li&gt;色には特に意味はない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ではこのFlame Graphからどのようなことがわかるか?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Q. 最もon-CPUだったのはどの関数か?

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;g()&lt;/code&gt;（グラフの一番上を見れば良い）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Q. なぜ&lt;code&gt;g()&lt;/code&gt;はon-CPUなのか?

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;a()&lt;/code&gt; -&amp;gt; &lt;code&gt;b()&lt;/code&gt; -&amp;gt; &lt;code&gt;c()&lt;/code&gt; -&amp;gt; &lt;code&gt;e()&lt;/code&gt; -&amp;gt; &lt;code&gt;f()&lt;/code&gt; -&amp;gt; &lt;code&gt;g()&lt;/code&gt;（y軸を見る）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Q. &lt;code&gt;b()&lt;/code&gt;と&lt;code&gt;h()&lt;/code&gt;を比べると?

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;b()&lt;/code&gt;は&lt;code&gt;h()&lt;/code&gt;より多く登場した（およそ5倍）（ボックスの幅を比較する）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Q. なぜ&lt;code&gt;g()&lt;/code&gt;を実行しているのか

&lt;ul&gt;
&lt;li&gt;A. &lt;code&gt;a()&lt;/code&gt;が&lt;code&gt;b()&lt;/code&gt;を選択し，&lt;code&gt;d()&lt;/code&gt;が&lt;code&gt;f()&lt;/code&gt;を選択したため&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;goでflame-graphを描く&#34;&gt;GoでFlame Graphを描く&lt;/h2&gt;

&lt;p&gt;GoでFlame Graphを描くにはUberの&lt;a href=&#34;https://github.com/uber/go-torch&#34;&gt;go-torch&lt;/a&gt;を使えば良い．Gopherfest Sprint 2016の&lt;a href=&#34;https://github.com/prashantv&#34;&gt;Parashant&lt;/a&gt;氏の発表&lt;a href=&#34;https://www.youtube.com/watch?v=N3PWzBeLX2M&#34;&gt;&amp;ldquo;Profiling and Optimizing Go&amp;rdquo;&lt;/a&gt;でこの&lt;code&gt;go-torch&lt;/code&gt;を使ってパフォーマンスをチューニングする様子が観れる．ライブデモが華麗すぎて感動するので今すぐ観ると良い．&lt;/p&gt;

&lt;h3 id=&#34;goのプロファイリングの基礎&#34;&gt;Goのプロファイリングの基礎&lt;/h3&gt;

&lt;p&gt;Goにはプロファイリングのためのパッケージが標準で準備されている．Webサーバーであれば&lt;code&gt;net/http/pprof&lt;/code&gt;，通常のツールであれば&lt;code&gt;runtime/pprof&lt;/code&gt;を使う．&lt;code&gt;runtime/pprof&lt;/code&gt;についてはRuss Coss氏の&lt;a href=&#34;http://blog.golang.org/profiling-go-programs&#34;&gt;&amp;ldquo;Profiling Go Programs&amp;rdquo;&lt;/a&gt;を読むと良い．ここでは&lt;code&gt;net/http/pprof&lt;/code&gt;を使って解説をする．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;net/http/pprof&lt;/code&gt;を使ってプロファイリングを有効にするのは非常に簡単である．以下をコードに追加すればよい．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;import _ net/http/pprof 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけで&lt;code&gt;/debug/pprof&lt;/code&gt;というエンドポイントが新たに追加される．ここでは現在動いているgoroutineのStackやHeapの状態，GCの実行状況などを確認することができる．&lt;/p&gt;

&lt;p&gt;このエンドポイントを&lt;code&gt;go tool pprof&lt;/code&gt;で解析するには以下のようあコマンドを叩けば良い（&lt;code&gt;go-wrk&lt;/code&gt;などである程度ロードを与えておくと良い）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go tool pprof -seconds 5 http://localhost:9090/debug/pprof/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;するとインタラクティブなモードが始まり，以下のような専用のコマンドでプロファイリング結果を確認できるようになる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ (pprof) top10
3400ms of 3770ms total (90.19%)
Dropped 60 nodes (cum &amp;lt;= 18.85ms)
Showing top 10 nodes out of 98 (cum &amp;gt;= 30ms)
flat  flat%   sum%        cum   cum%
1680ms 44.56% 44.56%     1680ms 44.56%  syscall.Syscall
1030ms 27.32% 71.88%     1040ms 27.59%  syscall.Syscall6
190ms  5.04% 76.92%      190ms  5.04%  runtime.kevent
140ms  3.71% 80.64%      140ms  3.71%  runtime.indexbytebody
120ms  3.18% 83.82%      120ms  3.18%  runtime.usleep
70ms  1.86% 85.68%       70ms  1.86%  runtime.mach_semaphore_signal
70ms  1.86% 87.53%       70ms  1.86%  runtime.mach_semaphore_wait
50ms  1.33% 88.86%       50ms  1.33%  runtime.memclr
30ms   0.8% 89.66%       30ms   0.8%  net/http.(*ServeMux).match
20ms  0.53% 90.19%       30ms   0.8%  fmt.(*pp).doPrintf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テキストだけではなく，以下のコマンドでグラフ（&lt;code&gt;svg&lt;/code&gt;形式）でプロファイリング結果を表示することもできる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;(pprof) web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/pprof.png&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;コードベースが小さければこれだけでも十分強力だが，コードが増えるほどグラフは複雑になり結果を直感的に理解するのが難しくなる．&lt;/p&gt;

&lt;h3 id=&#34;go-torchを使う&#34;&gt;go-torchを使う&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go-torch&lt;/code&gt;を使うには&lt;code&gt;net/http/pprof&lt;/code&gt;によるエンドポイントを有効にしておくだけで良い．そして&lt;code&gt;go tool pprof&lt;/code&gt;を使うのと同じように以下のようなコマンドを叩くだけで&lt;code&gt;.svg&lt;/code&gt;形式のFlame Graphが出力される（&lt;code&gt;go-torch&lt;/code&gt;に加えてBrendan Gregg氏のPerlスクリプト&lt;a href=&#34;https://github.com/brendangregg/FlameGraph&#34;&gt;brendangregg/FlameGraph&lt;/a&gt;をダウンロードして&lt;code&gt;PATH&lt;/code&gt;を通しておく必要がある）．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go-torch --time 5 --url http://localhost:9090/debug/pprof/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;結果は以下．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://deeeet.com/images/torch.svg&#34; class=&#34;image&#34;&gt;&lt;/p&gt;

&lt;p&gt;（例えば上は単純なWebサーバーの場合である．&lt;code&gt;logRequest&lt;/code&gt;という関数の&lt;code&gt;os.Hostname()&lt;/code&gt;が怪しいのがすぐわかる）&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;グラフの生成はとても簡単なので読み方さえわかればFlame Graphはとても強力である．Flame Graphで問題の原因の大まかなあたりを付け&lt;code&gt;go tool pprof&lt;/code&gt;で詳細な解析をするという流れが良いと思う．&lt;/p&gt;

&lt;p&gt;Flame GraphはJavaやNode，RubyといったVM言語でも使うことができる．またCPUだけではなくてMemoryやIOのプロファイルにも利用することができる．気になる人はいろいろ漁ってみると良さそう．&lt;/p&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.jp/Systems-Performance-Enterprise-Brendan-Gregg-ebook/dp/B00FLYU9T2&#34;&gt;&amp;ldquo;Systems Performance: Enterprise and the Cloud&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://queue.acm.org/detail.cfm?id=2927301&#34;&gt;The Flame Graph - ACM Queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs&#34;&gt;Blazing Performance with Flame Graphs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Known unknowns</title>
      <link>http://deeeet.com/writing/2016/05/24/known-unknowns/</link>
      <pubDate>Tue, 24 May 2016 08:07:56 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/05/24/known-unknowns/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.amazon.co.jp/Systems-Performance-Enterprise-Brendan-Gregg-ebook/dp/B00FLYU9T2&#34;&gt;&amp;ldquo;Systems Performance: Enterprise and the Cloud&amp;rdquo;&lt;/a&gt; をずっと読んでいる．この本はNetflixの&lt;a href=&#34;http://www.brendangregg.com/&#34;&gt;Brendan Gregg&lt;/a&gt;氏がJoyent時代に書いた本である．その名の通りLinux（とSolaris）のシステムのパフォーマンスの本である（とにかく一つ一つが丁寧かつ深く解説されておりページをめくるごとに学びしかないのでパフォーマンスに関わるひとは今すぐ読むと良い）．&lt;/p&gt;

&lt;p&gt;この本で一貫して現れてくる，通底するのが，known-knowns，known-unknownsそしてunknown-unknownsという概念である．元ネタは&lt;a href=&#34;https://en.wikipedia.org/wiki/Donald_Rumsfeld&#34;&gt;Donald Rumsfeld&lt;/a&gt; 氏の会見でのコメントだが（cf. &lt;a href=&#34;https://en.wikipedia.org/wiki/There_are_known_knowns&#34;&gt;There are known knowns&lt;/a&gt;），複雑なシステムのパフォーマンスの重要な原則を集約している．良い概念なので簡単に紹介する．&lt;/p&gt;

&lt;p&gt;それぞれをパフォーマンスの観点から説明すると以下のようになる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;known-knowns&lt;/strong&gt; - 知っていること．そのパフォーマンスのメトリクスをチェックするべきことを知っているし，現在の値も知っている．例えば，CPUの利用率をチェックするべきことを知っているし，その平均的な値が10%であることも知っている&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;known-unknowns&lt;/strong&gt; - 「知らないこと」を知っていること．そのパフォーマンスのメトリクスをチェックできること，そのようなサブシステムが存在してることを知っているが，まだそれらを観測したことがない（知らない）．例えば，profilingによって何がCPUを使いまくっているのかチェックできるのを知っているけどまだそれを実施してない．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unknown-unknowns&lt;/strong&gt; - 「知らないこと」を知らないこと．例えば，デバイス割り込みがCPUを多く消費することを知らず，そのためチェックしてないかもしれない．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;パフォーマンスというのは「知れば知るほど知らないことが増える」という分野である．システムについて学べば学ぶほど，unknown-unknownsに気づき，それはknown-unknownになり，次回からはそれをチェックできるようになる．&lt;/p&gt;

&lt;p&gt;そしてこれはパフォーマンスに限った話ではない．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GolangのGCを追う</title>
      <link>http://deeeet.com/writing/2016/05/08/gogc-2016/</link>
      <pubDate>Sun, 08 May 2016 23:01:06 +0900</pubDate>
      
      <guid>http://deeeet.com/writing/2016/05/08/gogc-2016/</guid>
      <description>

&lt;p&gt;Go1.5とGo1.6でGoのGCのレイテンシが大きく改善された．この変更について「ちゃんと」理解するため，アルゴリズムレベルでGoのGCについて追ってみた．&lt;/p&gt;

&lt;p&gt;まずGoのGCの現状をパフォーマンス（レイテンシ）の観点からまとめる．次に具体的なアルゴリズムについて，そして最後に実際の現場でのチューニングはどうすれば良いのかについて解説する．&lt;/p&gt;

&lt;h2 id=&#34;goのgcの今&#34;&gt;GoのGCの今&lt;/h2&gt;

&lt;p&gt;最初にGoのGCの最近の流れ（2016年5月まで）をまとめる．&lt;/p&gt;

&lt;p&gt;Go1.4までは単純なStop The World（STW）GCが実装されていたがGo1.5からは新たなGCアルゴリズムが導入された．導入の際に設定された数値目標は大きなヒープサイズにおいてもレイテンシを10ms以下に抑えることであった．Go1.5で新たなアルゴリムが実装されGo1.6で最適化が行われた．&lt;/p&gt;

&lt;p&gt;以下は公開されているベンチマーク．まずはGo1.5を見る．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.github.com/tcnksm/talks/master/2016/02/go1.6/img/go15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=aiv1JOfMjm0&#34;&gt;GopherCon 2015: Rick Hudson - Go GC: Solving the Latency Problem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;グラフの横軸はヒープサイズで縦軸はレイテンシである（小さいほどよい）．以前のバージョンと比較するとヒープの増加に伴ってレイテンシが3.0sを超えていたのがほぼ0sに抑えらているのがわかる．コミュニティからも以下のようなベンチマークが公開されている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/brianhatfield/status/634166123605331968&#34;&gt;https://twitter.com/brianhatfield/status/634166123605331968&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@robin.verlangen/billions-of-request-per-day-meet-go-1-5-362bfefa0911#.vyckzy74d&#34;&gt;Billions of request per day meet Go 1.5&lt;/a&gt; (The new version of Go reduces our 95-percentile garbage collector from 279 milliseconds down to just 10 ms)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次に以下はGo1.6のベンチマーク．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.github.com/tcnksm/talks/master/2016/02/go1.6/img/go16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.infoq.com/presentations/go-gc-performance&#34;&gt;QCon: Go GC: Prioritizing Low Latency and Simplicity&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;縦軸と横軸はGo1.5と同じ．まずGo1.5のグラフと比べると10倍のヒープサイズでベンチマークが行われているのがわかる．Go1.5が50GBに達する前にレイテンシが増大しているのに対してGo1.6は250GBのヒープに対しても10msのレイテンシで抑えらているのが確認できる．&lt;/p&gt;

&lt;p&gt;Go1.7のリリースが近いが，既に今までと同じくTwitterの&lt;a href=&#34;https://twitter.com/brianhatfield&#34;&gt;@brianhatfield&lt;/a&gt;氏がCanaryテストを行い，さらにGCのレイテンシが改善されたことが報告されている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-dev/n-D2RYU4nIs&#34;&gt;Go 1.7 observed performance changes (production canary@eeca3ba)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらのアップデートからGoにおいてGCのレイテンシは大規模プロダクション環境においても全く問題にならないレベルになっていることがわかる．つまりパフォーマンスに問題があったときに疑うべき場所としては優先度は低いと言える．&lt;/p&gt;

&lt;p&gt;以下ではこれらをどのように達成したのかを追っていく．&lt;/p&gt;

&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;

&lt;p&gt;まず最初に筆者はGCに関してはほぼ初心者であった．GoのGCを少しでも「ちゃんと」理解したいがために勉強したにすぎない．そのためGCの知識は素人に毛が生えた程度でしかない．先に参考文献やリンクをまとめておくので，気になるひとは自分でそれらを追ってみるのが良い．&lt;/p&gt;

&lt;p&gt;まずGCの基礎については以下の書籍が勉強になった．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tatsu-zine.com/books/gcbook&#34;&gt;ガベージコレクションのアルゴリズムと実装&lt;/a&gt; - とにかく初心者はまずこれを読むのが良い．本書はアルゴリズム編と実装編に分かれている．アルゴリズム編では基本となるアルゴリズムが図解と疑似コードで丁寧に解説されておりGCの基礎を抑えることができる．中で述べられているようにGCの基本はGCが登場して50年たってもそれほど変わっていないのでこれらを抑えるだけでもだいぶ話に入っていける．実装編では実際のruntime例えばPythonやV8などをのコードを追っていく．これで「GCのコードの追い方」がなんとなくわかった&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.co.jp/dp/B01CYDGUT0&#34;&gt;ガベージコレクション&lt;/a&gt; - こちらは最近（2016年3月）発売されたばかりの本．先に上げた「ガベージコレクションのアルゴリズムと実装」がカジュアルな本であるのに対してこちらは膨大なGC研究がまとめられておりより硬派な本であると言える．基礎アルゴリズムから説明していくのは同じであるが本書は並列・並行処理/マルチコア時代のことが意識されているのが特徴的である．Goで採用されているConcurrent GCはこちらで学んだ．また参照局所性といったハードウェアに対する言及も多い&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;次にGoのGCそのものについての解説は以下のRick Hudson氏の一連の発表及びブログ，デザインノートを見るとよい．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=aiv1JOfMjm0&#34;&gt;GopherCon 2015: Rick Hudson - Go GC: Solving the Latency Problem&lt;/a&gt; (&lt;a href=&#34;https://talks.golang.org/2015/go-gc.pdf&#34;&gt;slide&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/go15gc&#34;&gt;Go GC: Prioritizing low latency and simplicity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/document/d/16Y4IsnNRCN43Mx0NZc5YXZLovrHvvLhK_h0KN8woTO4&#34;&gt;Go 1.4+ Garbage Collection (GC) Plan and Roadmap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GopherConとQconの内容は基本的に同じだが後者はGo1.6に関するアップデートを幾つか含んでいる．&lt;/p&gt;

&lt;p&gt;以下の論文が参考として挙げられている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://research.microsoft.com/en-us/um/people/lamport/pubs/garbage.pdf&#34;&gt;On-the-Fly Garbage Collection: An Exercise in Cooperation&lt;/a&gt; - 基礎となったアルゴリズムについて述べた論文&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;ftp://ftp.cs.umass.edu/pub/osl/papers/sapphire-2003.pdf&#34;&gt;Sapphire: Copying GC Without Stopping the World&lt;/a&gt; - 上記のアルゴリズムの正確さと完全性，GCが「終了すること」を示した論文&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;また&lt;a href=&#34;https://golang.org/pkg/runtime/&#34;&gt;runtime package&lt;/a&gt;のソースコード（&lt;code&gt;mgc.go&lt;/code&gt;）にも具体的な実装の解説がコメントで書かれているので参考になる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/src/runtime/mgc.go&#34;&gt;https://golang.org/src/runtime/mgc.go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;またGo1.4以前のGCの歴史はstackovwerflowに良い回答があったのでそちらを見ると良い．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/7823725/what-kind-of-garbage-collection-does-go-use/7824353#7824353&#34;&gt;What kind of Garbage Collection does Go use?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下はこれらを自分の言葉で整理し直したものである．&lt;/p&gt;

&lt;h2 id=&#34;ハードウェアの進化とソフトウェアの進化&#34;&gt;ハードウェアの進化とソフトウェアの進化&lt;/h2&gt;

&lt;p&gt;Rick Hudson氏が発表でもブログでも述べていたことだが，GoのGCは現在だけではなくて10年後も使えるものを目指している．ハードウェアの進化を見据えてソフトウェアを改善している．&lt;/p&gt;

&lt;p&gt;今回のGoのGCの変更で仮定されているのは「将来のハードウェアがGCのスループットを改善する」である．そのためGCが目指したのはレイテンシの改善である（レイテンシのためにスループットを犠牲にされている）．&lt;/p&gt;

&lt;h2 id=&#34;goのgcアルゴリズム&#34;&gt;GoのGCアルゴリズム&lt;/h2&gt;

&lt;p&gt;Go1.5以降のGCアルゴリズムはConcurrent Mark &amp;amp; Sweepである．GC中のオブジェクトの状態の表現にはTri-color markig（三色マーキング）を用いている．&lt;/p&gt;

&lt;h3 id=&#34;mark-sweep&#34;&gt;Mark &amp;amp; Sweep&lt;/h3&gt;

&lt;p&gt;まずMark &amp;amp; Sweepについて説明する．Mark &amp;amp; Sweepは基礎中の基礎のGCアルゴリズムである．アルゴリズムはその名前の通りMarkとSweepという2つのフェーズに分けられる．まずMarkフェーズではルートを起点にポインタを辿りオブジェクトにマークをつけていく．次にSweepフェーズではマークが付けられていないオブジェクトをフリーリストに追加していく．フリーリストに追加された領域は次回のアロケーションで利用可能になる．&lt;/p&gt;

&lt;p&gt;つまりMark &amp;amp; Sweepではルートから到達可能なオブジェクトを生きているオブジェクトとし到達不可能なオブジェクトを死んでいると判別し回収する．オブジェクトがミューテータ（アプリケーション）に実際に使われているか?  といった判別は行わない（つまり全く使われていないにもかかわらずルートから到達できればオブジェクトは掃除されることはない）．&lt;/p&gt;

&lt;h3 id=&#34;gcはなぜ問題になるのか&#34;&gt;GCはなぜ問題になるのか?&lt;/h3&gt;

&lt;p&gt;こう見るとGCは非常に単純に見える．しかしGCは多くのアプリケーションで大きな問題になる．それはStop The World（STW），つまりミューテータの実行を止めること，が必要になるからである．なぜならミューテータはGCがオブジェクトが生きているか死んでいるかを判断している間にヒープのトポロジを変更してしまうからである．&lt;/p&gt;

&lt;p&gt;例えば，GCの途中にミューテータが新たにアロケーションを行ってしまった場合を考える．するとそのオブジェクトはマークされず，生きているのにもかかわらずSweepの対象になってしまうかもしれない．これは大きなバグになる．GCの正確さを保証するためにはミューテータとコレクタの動作を同期させる必要がある．&lt;/p&gt;

&lt;p&gt;この同期のための最も単純な戦略はGCを行っている間はミューテータを完全に止めてしまう方法である．しかしこれではアプリケーションはまともなサービスを提供できなくなる．例えばWebアプリケーションにおいてはしばらくレスポンスを返せないなどといった状況が発生してしまうかもしれない．GCの研究においてSTWをいかに短くするか，レイテンシをいかに小さくするか，もしくは避けるか，は大きな分野である（他には断片化をいかに少なくしてヒープの使用効率を良くするかといった方向もある）．&lt;/p&gt;

&lt;p&gt;Go1.4以前のGCはこの単純なSTWであり，レイテンシが大きな問題になっていた．以下で説明する，Tri-color markingやConcurrent GCはSTWを減らし，レイテンシを改善するための方法である．&lt;/p&gt;

&lt;h3 id=&#34;tri-color-marking&#34;&gt;Tri-color marking&lt;/h3&gt;

&lt;p&gt;一度にGCのプロセスを全て実行するのではなく，GCの実行を分割し，ミューテータと交互に実行させることでレイテンシを小さくすることができる．このように実行するGCをインクリメンタルGCと呼ぶ．Tri-color marking（三色マーキング）は，インクリメンタルGCを可能にするためのオブジェクトの抽象化である．&lt;/p&gt;

&lt;p&gt;Tri-color markingはその名の通りGC中のオブジェクトを状態に応じて以下の3種類に分類する．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;白 - まだ探索されていないオブジェクト&lt;/li&gt;
&lt;li&gt;グレー - 探索途中のオブジェクト&lt;/li&gt;
&lt;li&gt;黒 - 探索済みのオブジェクト&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mark &amp;amp; SweepをTri-color markingを使ってインクリメンタルに実行すると以下の3つのフェーズに分けることができる．GCの開始時点では全てのオブジェクトの色は白である．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ルートスキャンフェーズ - ルートから直接参照可能なオブジェクトをグレーに塗る&lt;/li&gt;
&lt;li&gt;マークフェーズ - グレーのオブジェクトを取り出し，その子オブジェクトをグレーに塗る．全ての子オブジェクトがグレーに塗られたらそのオブジェクトは黒に塗られる&lt;/li&gt;
&lt;li&gt;スイープフェーズ - ヒープ領域をスキャンし白いオブジェクトを死んでいるオブジェクトであると判別してフリーリストに連結する．また黒いオブジェクトは白色に戻す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ルートスキャンフェーズはGCの開始時に一度だけ実行される．マークフェーズでは，全てのグレーオブジェクトを一度に全て処理するのではなく，一定個数だけ処理して中断し，ミューテータの実行を再開する．これを繰り返しグレーのオブジェクトがなくなるまでこのフェーズを続ける．スイープフェーズもヒープを一括でスキャンするのではなく順次スキャンする．ミューテーターは，ルートスキャンフェーズとマークフェーズの間，マークフェーズの間，そしてスイープフェーズの間に実行が再開される．&lt;/p&gt;

&lt;h3 id=&#34;ライトバリア&#34;&gt;ライトバリア&lt;/h3&gt;

&lt;p&gt;マークフェーズを中断しミューテータを再開する場合を考える．この時に何も考慮しないと問題が発生する．&lt;/p&gt;

&lt;p&gt;例えば，ミューテータを再開した際に，グレーのオブジェクトAから参照された白いオブジェクトBがあるとする．ミューテータがこのオブジェクトBを別の黒いオブジェクトCから参照するようにポインタを更新し，かつオブジェクトAからの参照を削除してしまったとする．このままマークフェーズが再開するとどうなるか? 黒いオブジェクトCは「探索済み」である．よってオブジェクトCは再びスキャンされることはない．新たに参照された白いオブジェクトBもスキャンされることはなく「マーク漏れ」が発生する．つまり生きいるのに回収されるという大きな問題が発生してしまう．&lt;/p&gt;

&lt;p&gt;この「マーク漏れ」（オブジェクトの迷子）が発生するのは以下の2つの条件が成立する時である．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ミューテータが白いオブジェクトへのポインタを黒いオブジェクトに書き込む&lt;/li&gt;
&lt;li&gt;すべてのグレーのオブジェクトから，その白いオブジェクトへの経路が削除される&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを防ぐのがライトバリアである．ライトバリアはGenerational GC（世代別GC）などでも使われる手法である．インクリメンタルGCのライトバリアはいくつか提案されている．Dijkstraによって提案された手法では「新たに参照されるオブジェクトが白いオブジェクトであればそれをグレーとする」．上の例だと，白いオブジェクトBを黒いオブジェクトCから参照するときにオブジェクトBをグレーにする．こうすることでBの「マーク漏れ」を防ぐことができる．&lt;/p&gt;

&lt;p&gt;インクリメンタルGCによりミューテータの実行を長時間妨げることはなくなり，レイテンシは大きく改善できる．しかし，このライトバリアによってオーバーヘッドを避けることができない．よってスループットを犠牲にする必要がある．&lt;/p&gt;

&lt;h3 id=&#34;concurrent-mark-sweep&#34;&gt;Concurrent Mark &amp;amp; Sweep&lt;/h3&gt;

&lt;p&gt;これらをConcurentに実行しているのがGoのGCである．並行への移行は単純なステップである．新たに加わる困難はコレクタとミューテータが適切に同期してヒープの一貫したビューを維持することである．&lt;/p&gt;

&lt;p&gt;GoはそれぞれのOSスレッド上にスケジューリングのコンテキストを持つ．このコンテキストはGoroutineのためのローカルのスケジューラであるとみなせ，&lt;code&gt;runtime&lt;/code&gt;のコードではPと呼ばれる（詳しくは&lt;a href=&#34;https://morsmachine.dk/go-scheduler&#34;&gt;&amp;ldquo;The Go scheduler&amp;rdquo;&lt;/a&gt; がわかりやすい）．GCにおいては，フェーズ（スキャンフェーズなど）が変わるたびに，すべてのPからのackを待つことで複数のスレッド間の同期を行っている．&lt;/p&gt;

&lt;p&gt;GCは終了することが重要である．Concurrent GCではミューテータがGCプロセスと同時に動くためオブジェクトは次々に新たにアロケートされていく．このためマークフェーズが収束しない可能性がある．これを解決するためにGoではマークフェーズ後に&lt;code&gt;marktermination&lt;/code&gt;フェーズが存在する．ここでは新たなオブジェクトは全て黒色でアロケートされる．これによりGCは収束に向かう．&lt;/p&gt;

&lt;h2 id=&#34;gogc-goのgcをチューニングする&#34;&gt;GOGC（GOのGCをチューニングする）&lt;/h2&gt;

&lt;p&gt;GCというとJavaのようなたくさんのチューニングパラメーター（&lt;code&gt;xms&lt;/code&gt;や&lt;code&gt;xmx&lt;/code&gt;）を思い浮かべる．Goにはただ1つの&lt;code&gt;GOGC&lt;/code&gt;という環境変数がGCをチューニングするパラメーターとして提供されている．&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GOGC&lt;/code&gt;はGoにおける最も古い環境変数の1つである（&lt;a href=&#34;http://dave.cheney.net/2015/11/29/a-whirlwind-tour-of-gos-runtime-environment-variables&#34;&gt;A whirlwind tour of Go&amp;rsquo;s runtime environment variables&lt;/a&gt;）．この環境変数はGCのAggressivenessを決める．&lt;/p&gt;

&lt;p&gt;デフォルト値は&lt;code&gt;100&lt;/code&gt;である．これはある時点でのGC完了後に到達可能であったオブジェクトのサイズよりも100%，つまり2倍大きなヒープサイズが消費されたら次のGCを実行するという意味である．&lt;/p&gt;

&lt;p&gt;どのようにチューニングするか? まずより大きな値，例えば&lt;code&gt;200&lt;/code&gt;をセットする．これはある時点でのGC完了後に到達可能であったあったオブジェクトのサイズよりも200%，つまり3倍のヒープサイズが消費されたら次のGCを実行するという意味である．つまりGCの実行を遅らせることができる．RAMに余裕がありGCに使われる合計時間を減らしたい（スループットを向上させたい）場合は大きな値を設定する．．&lt;/p&gt;

&lt;p&gt;次により小さな値を設定するとGCの実行間隔が短くなる．メモリの使用量を少なくしたい場合は小さな値を設定する（&lt;code&gt;off&lt;/code&gt;を設定するとGCは実行されなくなる）．&lt;/p&gt;

&lt;p&gt;GoのGCはハードウェアの進化が考慮されているのであった．もしハードウェアが進化してRAMの容量が2倍なったらどうするか．&lt;code&gt;GOGC&lt;/code&gt;の値を2倍にすればGCのサイクルを半分にすることができ，チューニングなしでアプリケーションを簡単にスケールさせることができる．&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;p&gt;GoのGCの変更について追ってみた．追ってみて他の言語と比べてもシンプルなGCが実装されているなあと感じた．そのためアルゴリズムなどを理解するのは容易だった．シンプルさの思想がGCにもあるのは良いなあと感じた．&lt;/p&gt;

&lt;p&gt;GCにはレイテンシやスループット以外にも解決するべき問題がある．例えばGoの場合は断片化の問題などは考慮されていない．今後その他の問題にどのように対処していくのかも楽しみになった．&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>